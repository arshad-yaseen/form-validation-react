{"ast":null,"code":"'use strict';\n\n/**\n * @param typeMap [Object] Map of MIME type -> Array[extensions]\n * @param ...\n */\nfunction Mime() {\n  this._types = Object.create(null);\n  this._extensions = Object.create(null);\n  for (let i = 0; i < arguments.length; i++) {\n    this.define(arguments[i]);\n  }\n  this.define = this.define.bind(this);\n  this.getType = this.getType.bind(this);\n  this.getExtension = this.getExtension.bind(this);\n}\n\n/**\n * Define mimetype -> extension mappings.  Each key is a mime-type that maps\n * to an array of extensions associated with the type.  The first extension is\n * used as the default extension for the type.\n *\n * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});\n *\n * If a type declares an extension that has already been defined, an error will\n * be thrown.  To suppress this error and force the extension to be associated\n * with the new type, pass `force`=true.  Alternatively, you may prefix the\n * extension with \"*\" to map the type to extension, without mapping the\n * extension to the type.\n *\n * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});\n *\n *\n * @param map (Object) type definitions\n * @param force (Boolean) if true, force overriding of existing definitions\n */\nMime.prototype.define = function (typeMap, force) {\n  for (let type in typeMap) {\n    let extensions = typeMap[type].map(function (t) {\n      return t.toLowerCase();\n    });\n    type = type.toLowerCase();\n    for (let i = 0; i < extensions.length; i++) {\n      const ext = extensions[i];\n\n      // '*' prefix = not the preferred type for this extension.  So fixup the\n      // extension, and skip it.\n      if (ext[0] === '*') {\n        continue;\n      }\n      if (!force && ext in this._types) {\n        throw new Error('Attempt to change mapping for \"' + ext + '\" extension from \"' + this._types[ext] + '\" to \"' + type + '\". Pass `force=true` to allow this, otherwise remove \"' + ext + '\" from the list of extensions for \"' + type + '\".');\n      }\n      this._types[ext] = type;\n    }\n\n    // Use first extension as default\n    if (force || !this._extensions[type]) {\n      const ext = extensions[0];\n      this._extensions[type] = ext[0] !== '*' ? ext : ext.substr(1);\n    }\n  }\n};\n\n/**\n * Lookup a mime type based on extension\n */\nMime.prototype.getType = function (path) {\n  path = String(path);\n  let last = path.replace(/^.*[/\\\\]/, '').toLowerCase();\n  let ext = last.replace(/^.*\\./, '').toLowerCase();\n  let hasPath = last.length < path.length;\n  let hasDot = ext.length < last.length - 1;\n  return (hasDot || !hasPath) && this._types[ext] || null;\n};\n\n/**\n * Return file extension associated with a mime type\n */\nMime.prototype.getExtension = function (type) {\n  type = /^\\s*([^;\\s]*)/.test(type) && RegExp.$1;\n  return type && this._extensions[type.toLowerCase()] || null;\n};\nmodule.exports = Mime;","map":{"version":3,"names":["Mime","_types","Object","create","_extensions","i","arguments","length","define","bind","getType","getExtension","prototype","typeMap","force","type","extensions","map","t","toLowerCase","ext","Error","substr","path","String","last","replace","hasPath","hasDot","test","RegExp","$1","module","exports"],"sources":["/Users/arshadyaseen/Desktop/ReactFromValidator/form-validation-react/node_modules/mime/Mime.js"],"sourcesContent":["'use strict';\n\n/**\n * @param typeMap [Object] Map of MIME type -> Array[extensions]\n * @param ...\n */\nfunction Mime() {\n  this._types = Object.create(null);\n  this._extensions = Object.create(null);\n\n  for (let i = 0; i < arguments.length; i++) {\n    this.define(arguments[i]);\n  }\n\n  this.define = this.define.bind(this);\n  this.getType = this.getType.bind(this);\n  this.getExtension = this.getExtension.bind(this);\n}\n\n/**\n * Define mimetype -> extension mappings.  Each key is a mime-type that maps\n * to an array of extensions associated with the type.  The first extension is\n * used as the default extension for the type.\n *\n * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});\n *\n * If a type declares an extension that has already been defined, an error will\n * be thrown.  To suppress this error and force the extension to be associated\n * with the new type, pass `force`=true.  Alternatively, you may prefix the\n * extension with \"*\" to map the type to extension, without mapping the\n * extension to the type.\n *\n * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});\n *\n *\n * @param map (Object) type definitions\n * @param force (Boolean) if true, force overriding of existing definitions\n */\nMime.prototype.define = function(typeMap, force) {\n  for (let type in typeMap) {\n    let extensions = typeMap[type].map(function(t) {\n      return t.toLowerCase();\n    });\n    type = type.toLowerCase();\n\n    for (let i = 0; i < extensions.length; i++) {\n      const ext = extensions[i];\n\n      // '*' prefix = not the preferred type for this extension.  So fixup the\n      // extension, and skip it.\n      if (ext[0] === '*') {\n        continue;\n      }\n\n      if (!force && (ext in this._types)) {\n        throw new Error(\n          'Attempt to change mapping for \"' + ext +\n          '\" extension from \"' + this._types[ext] + '\" to \"' + type +\n          '\". Pass `force=true` to allow this, otherwise remove \"' + ext +\n          '\" from the list of extensions for \"' + type + '\".'\n        );\n      }\n\n      this._types[ext] = type;\n    }\n\n    // Use first extension as default\n    if (force || !this._extensions[type]) {\n      const ext = extensions[0];\n      this._extensions[type] = (ext[0] !== '*') ? ext : ext.substr(1);\n    }\n  }\n};\n\n/**\n * Lookup a mime type based on extension\n */\nMime.prototype.getType = function(path) {\n  path = String(path);\n  let last = path.replace(/^.*[/\\\\]/, '').toLowerCase();\n  let ext = last.replace(/^.*\\./, '').toLowerCase();\n\n  let hasPath = last.length < path.length;\n  let hasDot = ext.length < last.length - 1;\n\n  return (hasDot || !hasPath) && this._types[ext] || null;\n};\n\n/**\n * Return file extension associated with a mime type\n */\nMime.prototype.getExtension = function(type) {\n  type = /^\\s*([^;\\s]*)/.test(type) && RegExp.$1;\n  return type && this._extensions[type.toLowerCase()] || null;\n};\n\nmodule.exports = Mime;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}