{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar tslib = require('tslib');\nvar React = require('react');\nvar heyListen = require('hey-listen');\nvar styleValueTypes = require('style-value-types');\nvar popmotion = require('popmotion');\nvar sync = require('framesync');\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n  n['default'] = e;\n  return Object.freeze(n);\n}\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\nvar React__default = /*#__PURE__*/_interopDefaultLegacy(React);\nvar sync__default = /*#__PURE__*/_interopDefaultLegacy(sync);\nvar createDefinition = function (propNames) {\n  return {\n    isEnabled: function (props) {\n      return propNames.some(function (name) {\n        return !!props[name];\n      });\n    }\n  };\n};\nvar featureDefinitions = {\n  measureLayout: createDefinition([\"layout\", \"layoutId\", \"drag\", \"_layoutResetTransform\"]),\n  animation: createDefinition([\"animate\", \"exit\", \"variants\", \"whileHover\", \"whileTap\", \"whileFocus\", \"whileDrag\"]),\n  exit: createDefinition([\"exit\"]),\n  drag: createDefinition([\"drag\", \"dragControls\"]),\n  focus: createDefinition([\"whileFocus\"]),\n  hover: createDefinition([\"whileHover\", \"onHoverStart\", \"onHoverEnd\"]),\n  tap: createDefinition([\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"]),\n  pan: createDefinition([\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"]),\n  layoutAnimation: createDefinition([\"layout\", \"layoutId\"])\n};\nfunction loadFeatures(features) {\n  for (var key in features) {\n    var Component = features[key];\n    if (Component !== null) featureDefinitions[key].Component = Component;\n  }\n}\nvar LazyContext = React.createContext({\n  strict: false\n});\nvar featureNames = Object.keys(featureDefinitions);\nvar numFeatures = featureNames.length;\n/**\n * Load features via renderless components based on the provided MotionProps.\n */\nfunction useFeatures(props, visualElement, preloadedFeatures) {\n  var features = [];\n  var lazyContext = React.useContext(LazyContext);\n  if (!visualElement) return null;\n  /**\n   * If we're in development mode, check to make sure we're not rendering a motion component\n   * as a child of LazyMotion, as this will break the file-size benefits of using it.\n   */\n  if (process.env.NODE_ENV !== \"production\" && preloadedFeatures && lazyContext.strict) {\n    heyListen.invariant(false, \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\");\n  }\n  for (var i = 0; i < numFeatures; i++) {\n    var name_1 = featureNames[i];\n    var _a = featureDefinitions[name_1],\n      isEnabled = _a.isEnabled,\n      Component = _a.Component;\n    /**\n     * It might be possible in the future to use this moment to\n     * dynamically request functionality. In initial tests this\n     * was producing a lot of duplication amongst bundles.\n     */\n    if (isEnabled(props) && Component) {\n      features.push(React__namespace.createElement(Component, tslib.__assign({\n        key: name_1\n      }, props, {\n        visualElement: visualElement\n      })));\n    }\n  }\n  return features;\n}\n\n/**\n * @public\n */\nvar MotionConfigContext = React.createContext({\n  transformPagePoint: function (p) {\n    return p;\n  },\n  isStatic: false\n});\nvar MotionContext = React.createContext({});\nfunction useVisualElementContext() {\n  return React.useContext(MotionContext).visualElement;\n}\n\n/**\n * @public\n */\nvar PresenceContext = React.createContext(null);\n\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */\nfunction useConstant(init) {\n  var ref = React.useRef(null);\n  if (ref.current === null) {\n    ref.current = init();\n  }\n  return ref.current;\n}\n\n/**\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\n * to access information about whether it's still present in the React tree.\n *\n * ```jsx\n * import { usePresence } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const [isPresent, safeToRemove] = usePresence()\n *\n *   useEffect(() => {\n *     !isPresent && setTimeout(safeToRemove, 1000)\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\n *\n * @public\n */\nfunction usePresence() {\n  var context = React.useContext(PresenceContext);\n  if (context === null) return [true, null];\n  var isPresent = context.isPresent,\n    onExitComplete = context.onExitComplete,\n    register = context.register;\n  // It's safe to call the following hooks conditionally (after an early return) because the context will always\n  // either be null or non-null for the lifespan of the component.\n  // Replace with useOpaqueId when released in React\n  var id = useUniqueId();\n  React.useEffect(function () {\n    return register(id);\n  }, []);\n  var safeToRemove = function () {\n    return onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete(id);\n  };\n  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\n}\n/**\n * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.\n * There is no `safeToRemove` function.\n *\n * ```jsx\n * import { useIsPresent } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const isPresent = useIsPresent()\n *\n *   useEffect(() => {\n *     !isPresent && console.log(\"I've been removed!\")\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * @public\n */\nfunction useIsPresent() {\n  return isPresent(React.useContext(PresenceContext));\n}\nfunction isPresent(context) {\n  return context === null ? true : context.isPresent;\n}\nvar counter = 0;\nvar incrementId = function () {\n  return counter++;\n};\nvar useUniqueId = function () {\n  return useConstant(incrementId);\n};\n\n/**\n * @internal\n */\nvar LayoutGroupContext = React.createContext(null);\nvar isBrowser = typeof window !== \"undefined\";\nvar useIsomorphicLayoutEffect = isBrowser ? React.useLayoutEffect : React.useEffect;\nfunction useLayoutId(_a) {\n  var layoutId = _a.layoutId;\n  var layoutGroupId = React.useContext(LayoutGroupContext);\n  return layoutGroupId && layoutId !== undefined ? layoutGroupId + \"-\" + layoutId : layoutId;\n}\nfunction useVisualElement(Component, visualState, props, createVisualElement) {\n  var config = React.useContext(MotionConfigContext);\n  var lazyContext = React.useContext(LazyContext);\n  var parent = useVisualElementContext();\n  var presenceContext = React.useContext(PresenceContext);\n  var layoutId = useLayoutId(props);\n  var visualElementRef = React.useRef(undefined);\n  /**\n   * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n   */\n  if (!createVisualElement) createVisualElement = lazyContext.renderer;\n  if (!visualElementRef.current && createVisualElement) {\n    visualElementRef.current = createVisualElement(Component, {\n      visualState: visualState,\n      parent: parent,\n      props: tslib.__assign(tslib.__assign({}, props), {\n        layoutId: layoutId\n      }),\n      presenceId: presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id,\n      blockInitialAnimation: (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false\n    });\n  }\n  var visualElement = visualElementRef.current;\n  useIsomorphicLayoutEffect(function () {\n    if (!visualElement) return;\n    visualElement.setProps(tslib.__assign(tslib.__assign(tslib.__assign({}, config), props), {\n      layoutId: layoutId\n    }));\n    visualElement.isPresent = isPresent(presenceContext);\n    visualElement.isPresenceRoot = !parent || parent.presenceId !== (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id);\n    /**\n     * Fire a render to ensure the latest state is reflected on-screen.\n     */\n    visualElement.syncRender();\n  });\n  React.useEffect(function () {\n    var _a;\n    if (!visualElement) return;\n    /**\n     * In a future refactor we can replace the features-as-components and\n     * have this loop through them all firing \"effect\" listeners\n     */\n    (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.animateChanges();\n  });\n  useIsomorphicLayoutEffect(function () {\n    return function () {\n      return visualElement === null || visualElement === void 0 ? void 0 : visualElement.notifyUnmount();\n    };\n  }, []);\n  return visualElement;\n}\nfunction isRefObject(ref) {\n  return typeof ref === \"object\" && Object.prototype.hasOwnProperty.call(ref, \"current\");\n}\n\n/**\n * Creates a ref function that, when called, hydrates the provided\n * external ref and VisualElement.\n */\nfunction useMotionRef(visualState, visualElement, externalRef) {\n  return React.useCallback(function (instance) {\n    var _a;\n    instance && ((_a = visualState.mount) === null || _a === void 0 ? void 0 : _a.call(visualState, instance));\n    if (visualElement) {\n      instance ? visualElement.mount(instance) : visualElement.unmount();\n    }\n    if (externalRef) {\n      if (typeof externalRef === \"function\") {\n        externalRef(instance);\n      } else if (isRefObject(externalRef)) {\n        externalRef.current = instance;\n      }\n    }\n  },\n  /**\n   * Only pass a new ref callback to React if we've received a visual element\n   * factory. Otherwise we'll be mounting/remounting every time externalRef\n   * or other dependencies change.\n   */\n  [visualElement]);\n}\n\n/**\n * Decides if the supplied variable is an array of variant labels\n */\nfunction isVariantLabels(v) {\n  return Array.isArray(v);\n}\n/**\n * Decides if the supplied variable is variant label\n */\nfunction isVariantLabel(v) {\n  return typeof v === \"string\" || isVariantLabels(v);\n}\n/**\n * Creates an object containing the latest state of every MotionValue on a VisualElement\n */\nfunction getCurrent(visualElement) {\n  var current = {};\n  visualElement.forEachValue(function (value, key) {\n    return current[key] = value.get();\n  });\n  return current;\n}\n/**\n * Creates an object containing the latest velocity of every MotionValue on a VisualElement\n */\nfunction getVelocity$1(visualElement) {\n  var velocity = {};\n  visualElement.forEachValue(function (value, key) {\n    return velocity[key] = value.getVelocity();\n  });\n  return velocity;\n}\nfunction resolveVariantFromProps(props, definition, custom, currentValues, currentVelocity) {\n  var _a;\n  if (currentValues === void 0) {\n    currentValues = {};\n  }\n  if (currentVelocity === void 0) {\n    currentVelocity = {};\n  }\n  if (typeof definition === \"string\") {\n    definition = (_a = props.variants) === null || _a === void 0 ? void 0 : _a[definition];\n  }\n  return typeof definition === \"function\" ? definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity) : definition;\n}\nfunction resolveVariant(visualElement, definition, custom) {\n  var props = visualElement.getProps();\n  return resolveVariantFromProps(props, definition, custom !== null && custom !== void 0 ? custom : props.custom, getCurrent(visualElement), getVelocity$1(visualElement));\n}\nfunction checkIfControllingVariants(props) {\n  var _a;\n  return typeof ((_a = props.animate) === null || _a === void 0 ? void 0 : _a.start) === \"function\" || isVariantLabel(props.initial) || isVariantLabel(props.animate) || isVariantLabel(props.whileHover) || isVariantLabel(props.whileDrag) || isVariantLabel(props.whileTap) || isVariantLabel(props.whileFocus) || isVariantLabel(props.exit);\n}\nfunction checkIfVariantNode(props) {\n  return Boolean(checkIfControllingVariants(props) || props.variants);\n}\nfunction getCurrentTreeVariants(props, context) {\n  if (checkIfControllingVariants(props)) {\n    var initial = props.initial,\n      animate = props.animate;\n    return {\n      initial: initial === false || isVariantLabel(initial) ? initial : undefined,\n      animate: isVariantLabel(animate) ? animate : undefined\n    };\n  }\n  return props.inherit !== false ? context : {};\n}\nfunction useCreateMotionContext(props, isStatic) {\n  var _a = getCurrentTreeVariants(props, React.useContext(MotionContext)),\n    initial = _a.initial,\n    animate = _a.animate;\n  return React.useMemo(function () {\n    return {\n      initial: initial,\n      animate: animate\n    };\n  },\n  /**\n   * Only break memoisation in static mode\n   */\n  isStatic ? [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)] : []);\n}\nfunction variantLabelsAsDependency(prop) {\n  return Array.isArray(prop) ? prop.join(\" \") : prop;\n}\n\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n *\n * @internal\n */\nfunction createMotionComponent(_a) {\n  var preloadedFeatures = _a.preloadedFeatures,\n    createVisualElement = _a.createVisualElement,\n    useRender = _a.useRender,\n    useVisualState = _a.useVisualState,\n    Component = _a.Component;\n  preloadedFeatures && loadFeatures(preloadedFeatures);\n  function MotionComponent(props, externalRef) {\n    /**\n     * If we're rendering in a static environment, we only visually update the component\n     * as a result of a React-rerender rather than interactions or animations. This\n     * means we don't need to load additional memory structures like VisualElement,\n     * or any gesture/animation features.\n     */\n    var isStatic = React.useContext(MotionConfigContext).isStatic;\n    var features = null;\n    /**\n     * Create the tree context. This is memoized and will only trigger renders\n     * when the current tree variant changes in static mode.\n     */\n    var context = useCreateMotionContext(props, isStatic);\n    /**\n     *\n     */\n    var visualState = useVisualState(props, isStatic);\n    if (!isStatic && isBrowser) {\n      /**\n       * Create a VisualElement for this component. A VisualElement provides a common\n       * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n       * providing a way of rendering to these APIs outside of the React render loop\n       * for more performant animations and interactions\n       */\n      context.visualElement = useVisualElement(Component, visualState, props, createVisualElement);\n      /**\n       * Load Motion gesture and animation features. These are rendered as renderless\n       * components so each feature can optionally make use of React lifecycle methods.\n       *\n       * TODO: The intention is to move these away from a React-centric to a\n       * VisualElement-centric lifecycle scheme.\n       */\n      features = useFeatures(props, context.visualElement, preloadedFeatures);\n    }\n    /**\n     * The mount order and hierarchy is specific to ensure our element ref\n     * is hydrated by the time features fire their effects.\n     */\n    return React__namespace.createElement(React__namespace.Fragment, null, React__namespace.createElement(MotionContext.Provider, {\n      value: context\n    }, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic)), features);\n  }\n  return React.forwardRef(MotionComponent);\n}\n\n/**\n * Convert any React component into a `motion` component. The provided component\n * **must** use `React.forwardRef` to the underlying DOM component you want to animate.\n *\n * ```jsx\n * const Component = React.forwardRef((props, ref) => {\n *   return <div ref={ref} />\n * })\n *\n * const MotionComponent = motion(Component)\n * ```\n *\n * @public\n */\nfunction createMotionProxy(createConfig) {\n  function custom(Component, customMotionComponentConfig) {\n    if (customMotionComponentConfig === void 0) {\n      customMotionComponentConfig = {};\n    }\n    return createMotionComponent(createConfig(Component, customMotionComponentConfig));\n  }\n  /**\n   * A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.\n   * Rather than generating them anew every render.\n   */\n  var componentCache = new Map();\n  return new Proxy(custom, {\n    /**\n     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.\n     * The prop name is passed through as `key` and we can use that to generate a `motion`\n     * DOM component with that name.\n     */\n    get: function (_target, key) {\n      /**\n       * If this element doesn't exist in the component cache, create it and cache.\n       */\n      if (!componentCache.has(key)) {\n        componentCache.set(key, custom(key));\n      }\n      return componentCache.get(key);\n    }\n  });\n}\n\n/**\n * We keep these listed seperately as we use the lowercase tag names as part\n * of the runtime bundle to detect SVG components\n */\nvar lowercaseSVGElements = [\"animate\", \"circle\", \"defs\", \"desc\", \"ellipse\", \"g\", \"image\", \"line\", \"filter\", \"marker\", \"mask\", \"metadata\", \"path\", \"pattern\", \"polygon\", \"polyline\", \"rect\", \"stop\", \"svg\", \"switch\", \"symbol\", \"text\", \"tspan\", \"use\", \"view\"];\nfunction isSVGComponent(Component) {\n  if (\n  /**\n   * If it's not a string, it's a custom React component. Currently we only support\n   * HTML custom React components.\n   */\n  typeof Component !== \"string\" ||\n  /**\n   * If it contains a dash, the element is a custom HTML webcomponent.\n   */\n  Component.includes(\"-\")) {\n    return false;\n  } else if (\n  /**\n   * If it's in our list of lowercase SVG tags, it's an SVG component\n   */\n  lowercaseSVGElements.indexOf(Component) > -1 ||\n  /**\n   * If it contains a capital letter, it's an SVG component\n   */\n  /[A-Z]/.test(Component)) {\n    return true;\n  }\n  return false;\n}\nvar valueScaleCorrection = {};\n/**\n * @internal\n */\nfunction addScaleCorrection(correctors) {\n  for (var key in correctors) {\n    valueScaleCorrection[key] = correctors[key];\n  }\n}\n\n/**\n * A list of all transformable axes. We'll use this list to generated a version\n * of each axes for each transform.\n */\nvar transformAxes = [\"\", \"X\", \"Y\", \"Z\"];\n/**\n * An ordered array of each transformable value. By default, transform values\n * will be sorted to this order.\n */\nvar order = [\"translate\", \"scale\", \"rotate\", \"skew\"];\n/**\n * Generate a list of every possible transform key.\n */\nvar transformProps = [\"transformPerspective\", \"x\", \"y\", \"z\"];\norder.forEach(function (operationKey) {\n  return transformAxes.forEach(function (axesKey) {\n    return transformProps.push(operationKey + axesKey);\n  });\n});\n/**\n * A function to use with Array.sort to sort transform keys by their default order.\n */\nfunction sortTransformProps(a, b) {\n  return transformProps.indexOf(a) - transformProps.indexOf(b);\n}\n/**\n * A quick lookup for transform props.\n */\nvar transformPropSet = new Set(transformProps);\nfunction isTransformProp(key) {\n  return transformPropSet.has(key);\n}\n/**\n * A quick lookup for transform origin props\n */\nvar transformOriginProps = new Set([\"originX\", \"originY\", \"originZ\"]);\nfunction isTransformOriginProp(key) {\n  return transformOriginProps.has(key);\n}\nfunction isForcedMotionValue(key, _a) {\n  var layout = _a.layout,\n    layoutId = _a.layoutId;\n  return isTransformProp(key) || isTransformOriginProp(key) || (layout || layoutId !== undefined) && (!!valueScaleCorrection[key] || key === \"opacity\");\n}\nvar isMotionValue = function (value) {\n  return value !== null && typeof value === \"object\" && value.getVelocity;\n};\nvar translateAlias = {\n  x: \"translateX\",\n  y: \"translateY\",\n  z: \"translateZ\",\n  transformPerspective: \"perspective\"\n};\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\nfunction buildTransform(_a, _b, transformIsDefault, transformTemplate) {\n  var transform = _a.transform,\n    transformKeys = _a.transformKeys;\n  var _c = _b.enableHardwareAcceleration,\n    enableHardwareAcceleration = _c === void 0 ? true : _c,\n    _d = _b.allowTransformNone,\n    allowTransformNone = _d === void 0 ? true : _d;\n  // The transform string we're going to build into.\n  var transformString = \"\";\n  // Transform keys into their default order - this will determine the output order.\n  transformKeys.sort(sortTransformProps);\n  // Track whether the defined transform has a defined z so we don't add a\n  // second to enable hardware acceleration\n  var transformHasZ = false;\n  // Loop over each transform and build them into transformString\n  var numTransformKeys = transformKeys.length;\n  for (var i = 0; i < numTransformKeys; i++) {\n    var key = transformKeys[i];\n    transformString += (translateAlias[key] || key) + \"(\" + transform[key] + \") \";\n    if (key === \"z\") transformHasZ = true;\n  }\n  if (!transformHasZ && enableHardwareAcceleration) {\n    transformString += \"translateZ(0)\";\n  } else {\n    transformString = transformString.trim();\n  }\n  // If we have a custom `transform` template, pass our transform values and\n  // generated transformString to that before returning\n  if (transformTemplate) {\n    transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n  } else if (allowTransformNone && transformIsDefault) {\n    transformString = \"none\";\n  }\n  return transformString;\n}\n/**\n * Build a transformOrigin style. Uses the same defaults as the browser for\n * undefined origins.\n */\nfunction buildTransformOrigin(_a) {\n  var _b = _a.originX,\n    originX = _b === void 0 ? \"50%\" : _b,\n    _c = _a.originY,\n    originY = _c === void 0 ? \"50%\" : _c,\n    _d = _a.originZ,\n    originZ = _d === void 0 ? 0 : _d;\n  return originX + \" \" + originY + \" \" + originZ;\n}\n\n/**\n * Returns true if the provided key is a CSS variable\n */\nfunction isCSSVariable$1(key) {\n  return key.startsWith(\"--\");\n}\n\n/**\n * Provided a value and a ValueType, returns the value as that value type.\n */\nvar getValueAsType = function (value, type) {\n  return type && typeof value === \"number\" ? type.transform(value) : value;\n};\nvar int = tslib.__assign(tslib.__assign({}, styleValueTypes.number), {\n  transform: Math.round\n});\nvar numberValueTypes = {\n  // Border props\n  borderWidth: styleValueTypes.px,\n  borderTopWidth: styleValueTypes.px,\n  borderRightWidth: styleValueTypes.px,\n  borderBottomWidth: styleValueTypes.px,\n  borderLeftWidth: styleValueTypes.px,\n  borderRadius: styleValueTypes.px,\n  radius: styleValueTypes.px,\n  borderTopLeftRadius: styleValueTypes.px,\n  borderTopRightRadius: styleValueTypes.px,\n  borderBottomRightRadius: styleValueTypes.px,\n  borderBottomLeftRadius: styleValueTypes.px,\n  // Positioning props\n  width: styleValueTypes.px,\n  maxWidth: styleValueTypes.px,\n  height: styleValueTypes.px,\n  maxHeight: styleValueTypes.px,\n  size: styleValueTypes.px,\n  top: styleValueTypes.px,\n  right: styleValueTypes.px,\n  bottom: styleValueTypes.px,\n  left: styleValueTypes.px,\n  // Spacing props\n  padding: styleValueTypes.px,\n  paddingTop: styleValueTypes.px,\n  paddingRight: styleValueTypes.px,\n  paddingBottom: styleValueTypes.px,\n  paddingLeft: styleValueTypes.px,\n  margin: styleValueTypes.px,\n  marginTop: styleValueTypes.px,\n  marginRight: styleValueTypes.px,\n  marginBottom: styleValueTypes.px,\n  marginLeft: styleValueTypes.px,\n  // Transform props\n  rotate: styleValueTypes.degrees,\n  rotateX: styleValueTypes.degrees,\n  rotateY: styleValueTypes.degrees,\n  rotateZ: styleValueTypes.degrees,\n  scale: styleValueTypes.scale,\n  scaleX: styleValueTypes.scale,\n  scaleY: styleValueTypes.scale,\n  scaleZ: styleValueTypes.scale,\n  skew: styleValueTypes.degrees,\n  skewX: styleValueTypes.degrees,\n  skewY: styleValueTypes.degrees,\n  distance: styleValueTypes.px,\n  translateX: styleValueTypes.px,\n  translateY: styleValueTypes.px,\n  translateZ: styleValueTypes.px,\n  x: styleValueTypes.px,\n  y: styleValueTypes.px,\n  z: styleValueTypes.px,\n  perspective: styleValueTypes.px,\n  transformPerspective: styleValueTypes.px,\n  opacity: styleValueTypes.alpha,\n  originX: styleValueTypes.progressPercentage,\n  originY: styleValueTypes.progressPercentage,\n  originZ: styleValueTypes.px,\n  // Misc\n  zIndex: int,\n  // SVG\n  fillOpacity: styleValueTypes.alpha,\n  strokeOpacity: styleValueTypes.alpha,\n  numOctaves: int\n};\nfunction buildHTMLStyles(state, latestValues, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin) {\n  var _a;\n  var style = state.style,\n    vars = state.vars,\n    transform = state.transform,\n    transformKeys = state.transformKeys,\n    transformOrigin = state.transformOrigin;\n  // Empty the transformKeys array. As we're throwing out refs to its items\n  // this might not be as cheap as suspected. Maybe using the array as a buffer\n  // with a manual incrementation would be better.\n  transformKeys.length = 0;\n  // Track whether we encounter any transform or transformOrigin values.\n  var hasTransform = false;\n  var hasTransformOrigin = false;\n  // Does the calculated transform essentially equal \"none\"?\n  var transformIsNone = true;\n  /**\n   * Loop over all our latest animated values and decide whether to handle them\n   * as a style or CSS variable.\n   *\n   * Transforms and transform origins are kept seperately for further processing.\n   */\n  for (var key in latestValues) {\n    var value = latestValues[key];\n    /**\n     * If this is a CSS variable we don't do any further processing.\n     */\n    if (isCSSVariable$1(key)) {\n      vars[key] = value;\n      continue;\n    }\n    // Convert the value to its default value type, ie 0 -> \"0px\"\n    var valueType = numberValueTypes[key];\n    var valueAsType = getValueAsType(value, valueType);\n    if (isTransformProp(key)) {\n      // If this is a transform, flag to enable further transform processing\n      hasTransform = true;\n      transform[key] = valueAsType;\n      transformKeys.push(key);\n      // If we already know we have a non-default transform, early return\n      if (!transformIsNone) continue;\n      // Otherwise check to see if this is a default transform\n      if (value !== ((_a = valueType.default) !== null && _a !== void 0 ? _a : 0)) transformIsNone = false;\n    } else if (isTransformOriginProp(key)) {\n      transformOrigin[key] = valueAsType;\n      // If this is a transform origin, flag and enable further transform-origin processing\n      hasTransformOrigin = true;\n    } else {\n      /**\n       * If layout projection is on, and we need to perform scale correction for this\n       * value type, perform it.\n       */\n      if ((projection === null || projection === void 0 ? void 0 : projection.isHydrated) && (layoutState === null || layoutState === void 0 ? void 0 : layoutState.isHydrated) && valueScaleCorrection[key]) {\n        var correctedValue = valueScaleCorrection[key].process(value, layoutState, projection);\n        /**\n         * Scale-correctable values can define a number of other values to break\n         * down into. For instance borderRadius needs applying to borderBottomLeftRadius etc\n         */\n        var applyTo = valueScaleCorrection[key].applyTo;\n        if (applyTo) {\n          var num = applyTo.length;\n          for (var i = 0; i < num; i++) {\n            style[applyTo[i]] = correctedValue;\n          }\n        } else {\n          style[key] = correctedValue;\n        }\n      } else {\n        style[key] = valueAsType;\n      }\n    }\n  }\n  if (layoutState && projection && buildProjectionTransform && buildProjectionTransformOrigin) {\n    style.transform = buildProjectionTransform(layoutState.deltaFinal, layoutState.treeScale, hasTransform ? transform : undefined);\n    if (transformTemplate) {\n      style.transform = transformTemplate(transform, style.transform);\n    }\n    style.transformOrigin = buildProjectionTransformOrigin(layoutState);\n  } else {\n    if (hasTransform) {\n      style.transform = buildTransform(state, options, transformIsNone, transformTemplate);\n    }\n    if (hasTransformOrigin) {\n      style.transformOrigin = buildTransformOrigin(transformOrigin);\n    }\n  }\n}\nvar createHtmlRenderState = function () {\n  return {\n    style: {},\n    transform: {},\n    transformKeys: [],\n    transformOrigin: {},\n    vars: {}\n  };\n};\nfunction copyRawValuesOnly(target, source, props) {\n  for (var key in source) {\n    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n      target[key] = source[key];\n    }\n  }\n}\nfunction useInitialMotionValues(_a, visualState, isStatic) {\n  var transformTemplate = _a.transformTemplate;\n  return React.useMemo(function () {\n    var state = createHtmlRenderState();\n    buildHTMLStyles(state, visualState, undefined, undefined, {\n      enableHardwareAcceleration: !isStatic\n    }, transformTemplate);\n    var vars = state.vars,\n      style = state.style;\n    return tslib.__assign(tslib.__assign({}, vars), style);\n  }, [visualState]);\n}\nfunction useStyle(props, visualState, isStatic) {\n  var styleProp = props.style || {};\n  var style = {};\n  /**\n   * Copy non-Motion Values straight into style\n   */\n  copyRawValuesOnly(style, styleProp, props);\n  Object.assign(style, useInitialMotionValues(props, visualState, isStatic));\n  if (props.transformValues) {\n    style = props.transformValues(style);\n  }\n  return style;\n}\nfunction useHTMLProps(props, visualState, isStatic) {\n  // The `any` isn't ideal but it is the type of createElement props argument\n  var htmlProps = {};\n  var style = useStyle(props, visualState, isStatic);\n  if (Boolean(props.drag)) {\n    // Disable the ghost element when a user drags\n    htmlProps.draggable = false;\n    // Disable text selection\n    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = \"none\";\n    // Disable scrolling on the draggable direction\n    style.touchAction = props.drag === true ? \"none\" : \"pan-\" + (props.drag === \"x\" ? \"y\" : \"x\");\n  }\n  htmlProps.style = style;\n  return htmlProps;\n}\n\n/**\n * A list of all valid MotionProps.\n *\n * @internalremarks\n * This doesn't throw if a `MotionProp` name is missing - it should.\n */\nvar validMotionProps = new Set([\"initial\", \"animate\", \"exit\", \"style\", \"variants\", \"transition\", \"transformTemplate\", \"transformValues\", \"custom\", \"inherit\", \"layout\", \"layoutId\", \"_layoutResetTransform\", \"onLayoutAnimationComplete\", \"onViewportBoxUpdate\", \"onLayoutMeasure\", \"onBeforeLayoutMeasure\", \"onAnimationStart\", \"onAnimationComplete\", \"onUpdate\", \"onDragStart\", \"onDrag\", \"onDragEnd\", \"onMeasureDragConstraints\", \"onDirectionLock\", \"onDragTransitionEnd\", \"drag\", \"dragControls\", \"dragListener\", \"dragConstraints\", \"dragDirectionLock\", \"_dragX\", \"_dragY\", \"dragElastic\", \"dragMomentum\", \"dragPropagation\", \"dragTransition\", \"whileDrag\", \"onPan\", \"onPanStart\", \"onPanEnd\", \"onPanSessionStart\", \"onTap\", \"onTapStart\", \"onTapCancel\", \"onHoverStart\", \"onHoverEnd\", \"whileFocus\", \"whileTap\", \"whileHover\"]);\n/**\n * Check whether a prop name is a valid `MotionProp` key.\n *\n * @param key - Name of the property to check\n * @returns `true` is key is a valid `MotionProp`.\n *\n * @public\n */\nfunction isValidMotionProp(key) {\n  return validMotionProps.has(key);\n}\nvar shouldForward = function (key) {\n  return !isValidMotionProp(key);\n};\n/**\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\n * of these should be passed to the underlying DOM node.\n *\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\n *\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\n * actually required.\n */\ntry {\n  var emotionIsPropValid_1 = require(\"@emotion/is-prop-valid\").default;\n  shouldForward = function (key) {\n    // Handle events explicitly as Emotion validates them all as true\n    if (key.startsWith(\"on\")) {\n      return !isValidMotionProp(key);\n    } else {\n      return emotionIsPropValid_1(key);\n    }\n  };\n} catch (_a) {\n  // We don't need to actually do anything here - the fallback is the existing `isPropValid`.\n}\nfunction filterProps(props, isDom, forwardMotionProps) {\n  var filteredProps = {};\n  for (var key in props) {\n    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key)) {\n      filteredProps[key] = props[key];\n    }\n  }\n  return filteredProps;\n}\nfunction calcOrigin$1(origin, offset, size) {\n  return typeof origin === \"string\" ? origin : styleValueTypes.px.transform(offset + size * origin);\n}\n/**\n * The SVG transform origin defaults are different to CSS and is less intuitive,\n * so we use the measured dimensions of the SVG to reconcile these.\n */\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n  var pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);\n  var pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);\n  return pxOriginX + \" \" + pxOriginY;\n}\n\n// Convert a progress 0-1 to a pixels value based on the provided length\nvar progressToPixels = function (progress, length) {\n  return styleValueTypes.px.transform(progress * length);\n};\nvar dashKeys = {\n  offset: \"stroke-dashoffset\",\n  array: \"stroke-dasharray\"\n};\nvar camelKeys = {\n  offset: \"strokeDashoffset\",\n  array: \"strokeDasharray\"\n};\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */\nfunction buildSVGPath(attrs, totalLength, length, spacing, offset, useDashCase) {\n  if (spacing === void 0) {\n    spacing = 1;\n  }\n  if (offset === void 0) {\n    offset = 0;\n  }\n  if (useDashCase === void 0) {\n    useDashCase = true;\n  }\n  // We use dash case when setting attributes directly to the DOM node and camel case\n  // when defining props on a React component.\n  var keys = useDashCase ? dashKeys : camelKeys;\n  // Build the dash offset\n  attrs[keys.offset] = progressToPixels(-offset, totalLength);\n  // Build the dash array\n  var pathLength = progressToPixels(length, totalLength);\n  var pathSpacing = progressToPixels(spacing, totalLength);\n  attrs[keys.array] = pathLength + \" \" + pathSpacing;\n}\n\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */\nfunction buildSVGAttrs(state, _a, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin) {\n  var attrX = _a.attrX,\n    attrY = _a.attrY,\n    originX = _a.originX,\n    originY = _a.originY,\n    pathLength = _a.pathLength,\n    _b = _a.pathSpacing,\n    pathSpacing = _b === void 0 ? 1 : _b,\n    _c = _a.pathOffset,\n    pathOffset = _c === void 0 ? 0 : _c,\n    // This is object creation, which we try to avoid per-frame.\n    latest = tslib.__rest(_a, [\"attrX\", \"attrY\", \"originX\", \"originY\", \"pathLength\", \"pathSpacing\", \"pathOffset\"]);\n  buildHTMLStyles(state, latest, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin);\n  state.attrs = state.style;\n  state.style = {};\n  var attrs = state.attrs,\n    style = state.style,\n    dimensions = state.dimensions,\n    totalPathLength = state.totalPathLength;\n  /**\n   * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n   * and copy it into style.\n   */\n  if (attrs.transform) {\n    if (dimensions) style.transform = attrs.transform;\n    delete attrs.transform;\n  }\n  // Parse transformOrigin\n  if (dimensions && (originX !== undefined || originY !== undefined || style.transform)) {\n    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n  }\n  // Treat x/y not as shortcuts but as actual attributes\n  if (attrX !== undefined) attrs.x = attrX;\n  if (attrY !== undefined) attrs.y = attrY;\n  // Build SVG path if one has been measured\n  if (totalPathLength !== undefined && pathLength !== undefined) {\n    buildSVGPath(attrs, totalPathLength, pathLength, pathSpacing, pathOffset, false);\n  }\n}\nvar createSvgRenderState = function () {\n  return tslib.__assign(tslib.__assign({}, createHtmlRenderState()), {\n    attrs: {}\n  });\n};\nfunction useSVGProps(props, visualState) {\n  var visualProps = React.useMemo(function () {\n    var state = createSvgRenderState();\n    buildSVGAttrs(state, visualState, undefined, undefined, {\n      enableHardwareAcceleration: false\n    }, props.transformTemplate);\n    return tslib.__assign(tslib.__assign({}, state.attrs), {\n      style: tslib.__assign({}, state.style)\n    });\n  }, [visualState]);\n  if (props.style) {\n    var rawStyles = {};\n    copyRawValuesOnly(rawStyles, props.style, props);\n    visualProps.style = tslib.__assign(tslib.__assign({}, rawStyles), visualProps.style);\n  }\n  return visualProps;\n}\nfunction createUseRender(forwardMotionProps) {\n  if (forwardMotionProps === void 0) {\n    forwardMotionProps = false;\n  }\n  var useRender = function (Component, props, ref, _a, isStatic) {\n    var latestValues = _a.latestValues;\n    var useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;\n    var visualProps = useVisualProps(props, latestValues, isStatic);\n    var filteredProps = filterProps(props, typeof Component === \"string\", forwardMotionProps);\n    var elementProps = tslib.__assign(tslib.__assign(tslib.__assign({}, filteredProps), visualProps), {\n      ref: ref\n    });\n    return React.createElement(Component, elementProps);\n  };\n  return useRender;\n}\nvar CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;\nvar REPLACE_TEMPLATE = \"$1-$2\";\n/**\n * Convert camelCase to dash-case properties.\n */\nvar camelToDash = function (str) {\n  return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();\n};\nfunction renderHTML(element, _a) {\n  var style = _a.style,\n    vars = _a.vars;\n  // Directly assign style into the Element's style prop. In tests Object.assign is the\n  // fastest way to assign styles.\n  Object.assign(element.style, style);\n  // Loop over any CSS variables and assign those.\n  for (var key in vars) {\n    element.style.setProperty(key, vars[key]);\n  }\n}\n\n/**\n * A set of attribute names that are always read/written as camel case.\n */\nvar camelCaseAttributes = new Set([\"baseFrequency\", \"diffuseConstant\", \"kernelMatrix\", \"kernelUnitLength\", \"keySplines\", \"keyTimes\", \"limitingConeAngle\", \"markerHeight\", \"markerWidth\", \"numOctaves\", \"targetX\", \"targetY\", \"surfaceScale\", \"specularConstant\", \"specularExponent\", \"stdDeviation\", \"tableValues\", \"viewBox\", \"gradientTransform\"]);\nfunction renderSVG(element, renderState) {\n  renderHTML(element, renderState);\n  for (var key in renderState.attrs) {\n    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\n  }\n}\nfunction scrapeMotionValuesFromProps$1(props) {\n  var style = props.style;\n  var newValues = {};\n  for (var key in style) {\n    if (isMotionValue(style[key]) || isForcedMotionValue(key, props)) {\n      newValues[key] = style[key];\n    }\n  }\n  return newValues;\n}\nfunction scrapeMotionValuesFromProps(props) {\n  var newValues = scrapeMotionValuesFromProps$1(props);\n  for (var key in props) {\n    if (isMotionValue(props[key])) {\n      var targetKey = key === \"x\" || key === \"y\" ? \"attr\" + key.toUpperCase() : key;\n      newValues[targetKey] = props[key];\n    }\n  }\n  return newValues;\n}\nfunction isAnimationControls(v) {\n  return typeof v === \"object\" && typeof v.start === \"function\";\n}\nvar isKeyframesTarget = function (v) {\n  return Array.isArray(v);\n};\nvar isCustomValue = function (v) {\n  return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\nvar resolveFinalValueInKeyframes = function (v) {\n  // TODO maybe throw if v.length - 1 is placeholder token?\n  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n\n/**\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\n *\n * TODO: Remove and move to library\n *\n * @internal\n */\nfunction resolveMotionValue(value) {\n  var unwrappedValue = isMotionValue(value) ? value.get() : value;\n  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;\n}\nfunction makeState(_a, props, context, presenceContext) {\n  var scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps,\n    createRenderState = _a.createRenderState,\n    onMount = _a.onMount;\n  var state = {\n    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),\n    renderState: createRenderState()\n  };\n  if (onMount) {\n    state.mount = function (instance) {\n      return onMount(props, instance, state);\n    };\n  }\n  return state;\n}\nvar makeUseVisualState = function (config) {\n  return function (props, isStatic) {\n    var context = React.useContext(MotionContext);\n    var presenceContext = React.useContext(PresenceContext);\n    return isStatic ? makeState(config, props, context, presenceContext) : useConstant(function () {\n      return makeState(config, props, context, presenceContext);\n    });\n  };\n};\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n  var values = {};\n  var blockInitialAnimation = (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false;\n  var motionValues = scrapeMotionValues(props);\n  for (var key in motionValues) {\n    values[key] = resolveMotionValue(motionValues[key]);\n  }\n  var initial = props.initial,\n    animate = props.animate;\n  var isControllingVariants = checkIfControllingVariants(props);\n  var isVariantNode = checkIfVariantNode(props);\n  if (context && isVariantNode && !isControllingVariants && props.inherit !== false) {\n    initial !== null && initial !== void 0 ? initial : initial = context.initial;\n    animate !== null && animate !== void 0 ? animate : animate = context.animate;\n  }\n  var variantToSet = blockInitialAnimation || initial === false ? animate : initial;\n  if (variantToSet && typeof variantToSet !== \"boolean\" && !isAnimationControls(variantToSet)) {\n    var list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\n    list.forEach(function (definition) {\n      var resolved = resolveVariantFromProps(props, definition);\n      if (!resolved) return;\n      var transitionEnd = resolved.transitionEnd;\n      resolved.transition;\n      var target = tslib.__rest(resolved, [\"transitionEnd\", \"transition\"]);\n      for (var key in target) values[key] = target[key];\n      for (var key in transitionEnd) values[key] = transitionEnd[key];\n    });\n  }\n  return values;\n}\nvar svgMotionConfig = {\n  useVisualState: makeUseVisualState({\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n    createRenderState: createSvgRenderState,\n    onMount: function (props, instance, _a) {\n      var renderState = _a.renderState,\n        latestValues = _a.latestValues;\n      try {\n        renderState.dimensions = typeof instance.getBBox === \"function\" ? instance.getBBox() : instance.getBoundingClientRect();\n      } catch (e) {\n        // Most likely trying to measure an unrendered element under Firefox\n        renderState.dimensions = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n      }\n      if (isPath(instance)) {\n        renderState.totalPathLength = instance.getTotalLength();\n      }\n      buildSVGAttrs(renderState, latestValues, undefined, undefined, {\n        enableHardwareAcceleration: false\n      }, props.transformTemplate);\n      // TODO: Replace with direct assignment\n      renderSVG(instance, renderState);\n    }\n  })\n};\nfunction isPath(element) {\n  return element.tagName === \"path\";\n}\nvar htmlMotionConfig = {\n  useVisualState: makeUseVisualState({\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,\n    createRenderState: createHtmlRenderState\n  })\n};\nfunction createDomMotionConfig(Component, _a, preloadedFeatures, createVisualElement) {\n  var _b = _a.forwardMotionProps,\n    forwardMotionProps = _b === void 0 ? false : _b;\n  var baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;\n  return tslib.__assign(tslib.__assign({}, baseConfig), {\n    preloadedFeatures: preloadedFeatures,\n    useRender: createUseRender(forwardMotionProps),\n    createVisualElement: createVisualElement,\n    Component: Component\n  });\n}\nvar AnimationType;\n(function (AnimationType) {\n  AnimationType[\"Animate\"] = \"animate\";\n  AnimationType[\"Hover\"] = \"whileHover\";\n  AnimationType[\"Tap\"] = \"whileTap\";\n  AnimationType[\"Drag\"] = \"whileDrag\";\n  AnimationType[\"Focus\"] = \"whileFocus\";\n  AnimationType[\"Exit\"] = \"exit\";\n})(AnimationType || (AnimationType = {}));\nfunction addDomEvent(target, eventName, handler, options) {\n  target.addEventListener(eventName, handler, options);\n  return function () {\n    return target.removeEventListener(eventName, handler, options);\n  };\n}\n/**\n * Attaches an event listener directly to the provided DOM element.\n *\n * Bypassing React's event system can be desirable, for instance when attaching non-passive\n * event handlers.\n *\n * ```jsx\n * const ref = useRef(null)\n *\n * useDomEvent(ref, 'wheel', onWheel, { passive: false })\n *\n * return <div ref={ref} />\n * ```\n *\n * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.\n * @param eventName - Name of the event you want listen for.\n * @param handler - Function to fire when receiving the event.\n * @param options - Options to pass to `Event.addEventListener`.\n *\n * @public\n */\nfunction useDomEvent(ref, eventName, handler, options) {\n  React.useEffect(function () {\n    var element = ref.current;\n    if (handler && element) {\n      return addDomEvent(element, eventName, handler, options);\n    }\n  }, [ref, eventName, handler, options]);\n}\n\n/**\n *\n * @param props\n * @param ref\n * @internal\n */\nfunction useFocusGesture(_a) {\n  var whileFocus = _a.whileFocus,\n    visualElement = _a.visualElement;\n  var onFocus = function () {\n    var _a;\n    (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Focus, true);\n  };\n  var onBlur = function () {\n    var _a;\n    (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Focus, false);\n  };\n  useDomEvent(visualElement, \"focus\", whileFocus ? onFocus : undefined);\n  useDomEvent(visualElement, \"blur\", whileFocus ? onBlur : undefined);\n}\nfunction isMouseEvent(event) {\n  // PointerEvent inherits from MouseEvent so we can't use a straight instanceof check.\n  if (typeof PointerEvent !== \"undefined\" && event instanceof PointerEvent) {\n    return !!(event.pointerType === \"mouse\");\n  }\n  return event instanceof MouseEvent;\n}\nfunction isTouchEvent(event) {\n  var hasTouches = !!event.touches;\n  return hasTouches;\n}\n\n/**\n * Filters out events not attached to the primary pointer (currently left mouse button)\n * @param eventHandler\n */\nfunction filterPrimaryPointer(eventHandler) {\n  return function (event) {\n    var isMouseEvent = event instanceof MouseEvent;\n    var isPrimaryPointer = !isMouseEvent || isMouseEvent && event.button === 0;\n    if (isPrimaryPointer) {\n      eventHandler(event);\n    }\n  };\n}\nvar defaultPagePoint = {\n  pageX: 0,\n  pageY: 0\n};\nfunction pointFromTouch(e, pointType) {\n  if (pointType === void 0) {\n    pointType = \"page\";\n  }\n  var primaryTouch = e.touches[0] || e.changedTouches[0];\n  var point = primaryTouch || defaultPagePoint;\n  return {\n    x: point[pointType + \"X\"],\n    y: point[pointType + \"Y\"]\n  };\n}\nfunction pointFromMouse(point, pointType) {\n  if (pointType === void 0) {\n    pointType = \"page\";\n  }\n  return {\n    x: point[pointType + \"X\"],\n    y: point[pointType + \"Y\"]\n  };\n}\nfunction extractEventInfo(event, pointType) {\n  if (pointType === void 0) {\n    pointType = \"page\";\n  }\n  return {\n    point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)\n  };\n}\nfunction getViewportPointFromEvent(event) {\n  return extractEventInfo(event, \"client\");\n}\nvar wrapHandler = function (handler, shouldFilterPrimaryPointer) {\n  if (shouldFilterPrimaryPointer === void 0) {\n    shouldFilterPrimaryPointer = false;\n  }\n  var listener = function (event) {\n    return handler(event, extractEventInfo(event));\n  };\n  return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;\n};\n\n// We check for event support via functions in case they've been mocked by a testing suite.\nvar supportsPointerEvents = function () {\n  return isBrowser && window.onpointerdown === null;\n};\nvar supportsTouchEvents = function () {\n  return isBrowser && window.ontouchstart === null;\n};\nvar supportsMouseEvents = function () {\n  return isBrowser && window.onmousedown === null;\n};\nvar mouseEventNames = {\n  pointerdown: \"mousedown\",\n  pointermove: \"mousemove\",\n  pointerup: \"mouseup\",\n  pointercancel: \"mousecancel\",\n  pointerover: \"mouseover\",\n  pointerout: \"mouseout\",\n  pointerenter: \"mouseenter\",\n  pointerleave: \"mouseleave\"\n};\nvar touchEventNames = {\n  pointerdown: \"touchstart\",\n  pointermove: \"touchmove\",\n  pointerup: \"touchend\",\n  pointercancel: \"touchcancel\"\n};\nfunction getPointerEventName(name) {\n  if (supportsPointerEvents()) {\n    return name;\n  } else if (supportsTouchEvents()) {\n    return touchEventNames[name];\n  } else if (supportsMouseEvents()) {\n    return mouseEventNames[name];\n  }\n  return name;\n}\nfunction addPointerEvent(target, eventName, handler, options) {\n  return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\nfunction usePointerEvent(ref, eventName, handler, options) {\n  return useDomEvent(ref, getPointerEventName(eventName), handler && wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\nfunction createLock(name) {\n  var lock = null;\n  return function () {\n    var openLock = function () {\n      lock = null;\n    };\n    if (lock === null) {\n      lock = name;\n      return openLock;\n    }\n    return false;\n  };\n}\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\nvar globalVerticalLock = createLock(\"dragVertical\");\nfunction getGlobalLock(drag) {\n  var lock = false;\n  if (drag === \"y\") {\n    lock = globalVerticalLock();\n  } else if (drag === \"x\") {\n    lock = globalHorizontalLock();\n  } else {\n    var openHorizontal_1 = globalHorizontalLock();\n    var openVertical_1 = globalVerticalLock();\n    if (openHorizontal_1 && openVertical_1) {\n      lock = function () {\n        openHorizontal_1();\n        openVertical_1();\n      };\n    } else {\n      // Release the locks because we don't use them\n      if (openHorizontal_1) openHorizontal_1();\n      if (openVertical_1) openVertical_1();\n    }\n  }\n  return lock;\n}\nfunction isDragActive() {\n  // Check the gesture lock - if we get it, it means no drag gesture is active\n  // and we can safely fire the tap gesture.\n  var openGestureLock = getGlobalLock(true);\n  if (!openGestureLock) return true;\n  openGestureLock();\n  return false;\n}\nfunction createHoverEvent(visualElement, isActive, callback) {\n  return function (event, info) {\n    var _a;\n    if (!isMouseEvent(event) || isDragActive()) return;\n    callback === null || callback === void 0 ? void 0 : callback(event, info);\n    (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Hover, isActive);\n  };\n}\nfunction useHoverGesture(_a) {\n  var onHoverStart = _a.onHoverStart,\n    onHoverEnd = _a.onHoverEnd,\n    whileHover = _a.whileHover,\n    visualElement = _a.visualElement;\n  usePointerEvent(visualElement, \"pointerenter\", onHoverStart || whileHover ? createHoverEvent(visualElement, true, onHoverStart) : undefined);\n  usePointerEvent(visualElement, \"pointerleave\", onHoverEnd || whileHover ? createHoverEvent(visualElement, false, onHoverEnd) : undefined);\n}\n\n/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */\nvar isNodeOrChild = function (parent, child) {\n  if (!child) {\n    return false;\n  } else if (parent === child) {\n    return true;\n  } else {\n    return isNodeOrChild(parent, child.parentElement);\n  }\n};\nfunction useUnmountEffect(callback) {\n  return React.useEffect(function () {\n    return function () {\n      return callback();\n    };\n  }, []);\n}\n\n/**\n * @param handlers -\n * @internal\n */\nfunction useTapGesture(_a) {\n  var onTap = _a.onTap,\n    onTapStart = _a.onTapStart,\n    onTapCancel = _a.onTapCancel,\n    whileTap = _a.whileTap,\n    visualElement = _a.visualElement;\n  var hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;\n  var isPressing = React.useRef(false);\n  var cancelPointerEndListeners = React.useRef(null);\n  function removePointerEndListener() {\n    var _a;\n    (_a = cancelPointerEndListeners.current) === null || _a === void 0 ? void 0 : _a.call(cancelPointerEndListeners);\n    cancelPointerEndListeners.current = null;\n  }\n  function checkPointerEnd() {\n    var _a;\n    removePointerEndListener();\n    isPressing.current = false;\n    (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Tap, false);\n    return !isDragActive();\n  }\n  function onPointerUp(event, info) {\n    if (!checkPointerEnd()) return;\n    /**\n     * We only count this as a tap gesture if the event.target is the same\n     * as, or a child of, this component's element\n     */\n    !isNodeOrChild(visualElement.getInstance(), event.target) ? onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info) : onTap === null || onTap === void 0 ? void 0 : onTap(event, info);\n  }\n  function onPointerCancel(event, info) {\n    if (!checkPointerEnd()) return;\n    onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info);\n  }\n  function onPointerDown(event, info) {\n    var _a;\n    removePointerEndListener();\n    if (isPressing.current) return;\n    isPressing.current = true;\n    cancelPointerEndListeners.current = popmotion.pipe(addPointerEvent(window, \"pointerup\", onPointerUp), addPointerEvent(window, \"pointercancel\", onPointerCancel));\n    onTapStart === null || onTapStart === void 0 ? void 0 : onTapStart(event, info);\n    (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Tap, true);\n  }\n  usePointerEvent(visualElement, \"pointerdown\", hasPressListeners ? onPointerDown : undefined);\n  useUnmountEffect(removePointerEndListener);\n}\nvar makeRenderlessComponent = function (hook) {\n  return function (props) {\n    hook(props);\n    return null;\n  };\n};\nvar gestureAnimations = {\n  tap: makeRenderlessComponent(useTapGesture),\n  focus: makeRenderlessComponent(useFocusGesture),\n  hover: makeRenderlessComponent(useHoverGesture)\n};\nfunction shallowCompare(next, prev) {\n  if (!Array.isArray(prev)) return false;\n  var prevLength = prev.length;\n  if (prevLength !== next.length) return false;\n  for (var i = 0; i < prevLength; i++) {\n    if (prev[i] !== next[i]) return false;\n  }\n  return true;\n}\n\n/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\nvar secondsToMilliseconds = function (seconds) {\n  return seconds * 1000;\n};\nvar easingLookup = {\n  linear: popmotion.linear,\n  easeIn: popmotion.easeIn,\n  easeInOut: popmotion.easeInOut,\n  easeOut: popmotion.easeOut,\n  circIn: popmotion.circIn,\n  circInOut: popmotion.circInOut,\n  circOut: popmotion.circOut,\n  backIn: popmotion.backIn,\n  backInOut: popmotion.backInOut,\n  backOut: popmotion.backOut,\n  anticipate: popmotion.anticipate,\n  bounceIn: popmotion.bounceIn,\n  bounceInOut: popmotion.bounceInOut,\n  bounceOut: popmotion.bounceOut\n};\nvar easingDefinitionToFunction = function (definition) {\n  if (Array.isArray(definition)) {\n    // If cubic bezier definition, create bezier curve\n    heyListen.invariant(definition.length === 4, \"Cubic bezier arrays must contain four numerical values.\");\n    var _a = tslib.__read(definition, 4),\n      x1 = _a[0],\n      y1 = _a[1],\n      x2 = _a[2],\n      y2 = _a[3];\n    return popmotion.cubicBezier(x1, y1, x2, y2);\n  } else if (typeof definition === \"string\") {\n    // Else lookup from table\n    heyListen.invariant(easingLookup[definition] !== undefined, \"Invalid easing type '\" + definition + \"'\");\n    return easingLookup[definition];\n  }\n  return definition;\n};\nvar isEasingArray = function (ease) {\n  return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\n/**\n * Check if a value is animatable. Examples:\n *\n * : 100, \"100px\", \"#fff\"\n * : \"block\", \"url(2.jpg)\"\n * @param value\n *\n * @internal\n */\nvar isAnimatable = function (key, value) {\n  // If the list of keys tat might be non-animatable grows, replace with Set\n  if (key === \"zIndex\") return false;\n  // If it's a number or a keyframes array, we can animate it. We might at some point\n  // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n  // but for now lets leave it like this for performance reasons\n  if (typeof value === \"number\" || Array.isArray(value)) return true;\n  if (typeof value === \"string\" &&\n  // It's animatable if we have a string\n  styleValueTypes.complex.test(value) &&\n  // And it contains numbers and/or colors\n  !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n  ) {\n    return true;\n  }\n  return false;\n};\nvar underDampedSpring = function () {\n  return {\n    type: \"spring\",\n    stiffness: 500,\n    damping: 25,\n    restDelta: 0.5,\n    restSpeed: 10\n  };\n};\nvar criticallyDampedSpring = function (to) {\n  return {\n    type: \"spring\",\n    stiffness: 550,\n    damping: to === 0 ? 2 * Math.sqrt(550) : 30,\n    restDelta: 0.01,\n    restSpeed: 10\n  };\n};\nvar linearTween = function () {\n  return {\n    type: \"keyframes\",\n    ease: \"linear\",\n    duration: 0.3\n  };\n};\nvar keyframes = function (values) {\n  return {\n    type: \"keyframes\",\n    duration: 0.8,\n    values: values\n  };\n};\nvar defaultTransitions = {\n  x: underDampedSpring,\n  y: underDampedSpring,\n  z: underDampedSpring,\n  rotate: underDampedSpring,\n  rotateX: underDampedSpring,\n  rotateY: underDampedSpring,\n  rotateZ: underDampedSpring,\n  scaleX: criticallyDampedSpring,\n  scaleY: criticallyDampedSpring,\n  scale: criticallyDampedSpring,\n  opacity: linearTween,\n  backgroundColor: linearTween,\n  color: linearTween,\n  default: criticallyDampedSpring\n};\nvar getDefaultTransition = function (valueKey, to) {\n  var transitionFactory;\n  if (isKeyframesTarget(to)) {\n    transitionFactory = keyframes;\n  } else {\n    transitionFactory = defaultTransitions[valueKey] || defaultTransitions.default;\n  }\n  return tslib.__assign({\n    to: to\n  }, transitionFactory(to));\n};\n\n/**\n * A map of default value types for common values\n */\nvar defaultValueTypes = tslib.__assign(tslib.__assign({}, numberValueTypes), {\n  // Color props\n  color: styleValueTypes.color,\n  backgroundColor: styleValueTypes.color,\n  outlineColor: styleValueTypes.color,\n  fill: styleValueTypes.color,\n  stroke: styleValueTypes.color,\n  // Border props\n  borderColor: styleValueTypes.color,\n  borderTopColor: styleValueTypes.color,\n  borderRightColor: styleValueTypes.color,\n  borderBottomColor: styleValueTypes.color,\n  borderLeftColor: styleValueTypes.color,\n  filter: styleValueTypes.filter,\n  WebkitFilter: styleValueTypes.filter\n});\n/**\n * Gets the default ValueType for the provided value key\n */\nvar getDefaultValueType = function (key) {\n  return defaultValueTypes[key];\n};\nfunction getAnimatableNone(key, value) {\n  var _a;\n  var defaultValueType = getDefaultValueType(key);\n  if (defaultValueType !== styleValueTypes.filter) defaultValueType = styleValueTypes.complex;\n  // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n  return (_a = defaultValueType.getAnimatableNone) === null || _a === void 0 ? void 0 : _a.call(defaultValueType, value);\n}\n\n/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */\nfunction isTransitionDefined(_a) {\n  _a.when;\n  _a.delay;\n  _a.delayChildren;\n  _a.staggerChildren;\n  _a.staggerDirection;\n  _a.repeat;\n  _a.repeatType;\n  _a.repeatDelay;\n  _a.from;\n  var transition = tslib.__rest(_a, [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\", \"repeat\", \"repeatType\", \"repeatDelay\", \"from\"]);\n  return !!Object.keys(transition).length;\n}\nvar legacyRepeatWarning = false;\n/**\n * Convert Framer Motion's Transition type into Popmotion-compatible options.\n */\nfunction convertTransitionToAnimationOptions(_a) {\n  var ease = _a.ease,\n    times = _a.times,\n    yoyo = _a.yoyo,\n    flip = _a.flip,\n    loop = _a.loop,\n    transition = tslib.__rest(_a, [\"ease\", \"times\", \"yoyo\", \"flip\", \"loop\"]);\n  var options = tslib.__assign({}, transition);\n  if (times) options[\"offset\"] = times;\n  /**\n   * Convert any existing durations from seconds to milliseconds\n   */\n  if (transition.duration) options[\"duration\"] = secondsToMilliseconds(transition.duration);\n  if (transition.repeatDelay) options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);\n  /**\n   * Map easing names to Popmotion's easing functions\n   */\n  if (ease) {\n    options[\"ease\"] = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);\n  }\n  /**\n   * Support legacy transition API\n   */\n  if (transition.type === \"tween\") options.type = \"keyframes\";\n  /**\n   * TODO: These options are officially removed from the API.\n   */\n  if (yoyo || loop || flip) {\n    heyListen.warning(!legacyRepeatWarning, \"yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.\");\n    legacyRepeatWarning = true;\n    if (yoyo) {\n      options.repeatType = \"reverse\";\n    } else if (loop) {\n      options.repeatType = \"loop\";\n    } else if (flip) {\n      options.repeatType = \"mirror\";\n    }\n    options.repeat = loop || yoyo || flip || transition.repeat;\n  }\n  /**\n   * TODO: Popmotion 9 has the ability to automatically detect whether to use\n   * a keyframes or spring animation, but does so by detecting velocity and other spring options.\n   * It'd be good to introduce a similar thing here.\n   */\n  if (transition.type !== \"spring\") options.type = \"keyframes\";\n  return options;\n}\n/**\n * Get the delay for a value by checking Transition with decreasing specificity.\n */\nfunction getDelayFromTransition(transition, key) {\n  var _a;\n  var valueTransition = getValueTransition(transition, key) || {};\n  return (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : 0;\n}\nfunction hydrateKeyframes(options) {\n  if (Array.isArray(options.to) && options.to[0] === null) {\n    options.to = tslib.__spreadArray([], tslib.__read(options.to));\n    options.to[0] = options.from;\n  }\n  return options;\n}\nfunction getPopmotionAnimationOptions(transition, options, key) {\n  var _a;\n  if (Array.isArray(options.to)) {\n    (_a = transition.duration) !== null && _a !== void 0 ? _a : transition.duration = 0.8;\n  }\n  hydrateKeyframes(options);\n  /**\n   * Get a default transition if none is determined to be defined.\n   */\n  if (!isTransitionDefined(transition)) {\n    transition = tslib.__assign(tslib.__assign({}, transition), getDefaultTransition(key, options.to));\n  }\n  return tslib.__assign(tslib.__assign({}, options), convertTransitionToAnimationOptions(transition));\n}\n/**\n *\n */\nfunction getAnimation(key, value, target, transition, onComplete) {\n  var _a;\n  var valueTransition = getValueTransition(transition, key);\n  var origin = (_a = valueTransition.from) !== null && _a !== void 0 ? _a : value.get();\n  var isTargetAnimatable = isAnimatable(key, target);\n  if (origin === \"none\" && isTargetAnimatable && typeof target === \"string\") {\n    /**\n     * If we're trying to animate from \"none\", try and get an animatable version\n     * of the target. This could be improved to work both ways.\n     */\n    origin = getAnimatableNone(key, target);\n  } else if (isZero(origin) && typeof target === \"string\") {\n    origin = getZeroUnit(target);\n  } else if (!Array.isArray(target) && isZero(target) && typeof origin === \"string\") {\n    target = getZeroUnit(origin);\n  }\n  var isOriginAnimatable = isAnimatable(key, origin);\n  heyListen.warning(isOriginAnimatable === isTargetAnimatable, \"You are trying to animate \" + key + \" from \\\"\" + origin + \"\\\" to \\\"\" + target + \"\\\". \" + origin + \" is not an animatable value - to enable this animation set \" + origin + \" to a value animatable to \" + target + \" via the `style` property.\");\n  function start() {\n    var options = {\n      from: origin,\n      to: target,\n      velocity: value.getVelocity(),\n      onComplete: onComplete,\n      onUpdate: function (v) {\n        return value.set(v);\n      }\n    };\n    return valueTransition.type === \"inertia\" || valueTransition.type === \"decay\" ? popmotion.inertia(tslib.__assign(tslib.__assign({}, options), valueTransition)) : popmotion.animate(tslib.__assign(tslib.__assign({}, getPopmotionAnimationOptions(valueTransition, options, key)), {\n      onUpdate: function (v) {\n        var _a;\n        options.onUpdate(v);\n        (_a = valueTransition.onUpdate) === null || _a === void 0 ? void 0 : _a.call(valueTransition, v);\n      },\n      onComplete: function () {\n        var _a;\n        options.onComplete();\n        (_a = valueTransition.onComplete) === null || _a === void 0 ? void 0 : _a.call(valueTransition);\n      }\n    }));\n  }\n  function set() {\n    var _a;\n    value.set(target);\n    onComplete();\n    (_a = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onComplete) === null || _a === void 0 ? void 0 : _a.call(valueTransition);\n    return {\n      stop: function () {}\n    };\n  }\n  return !isOriginAnimatable || !isTargetAnimatable || valueTransition.type === false ? set : start;\n}\nfunction isZero(value) {\n  return value === 0 || typeof value === \"string\" && parseFloat(value) === 0 && value.indexOf(\" \") === -1;\n}\nfunction getZeroUnit(potentialUnitType) {\n  return typeof potentialUnitType === \"number\" ? 0 : getAnimatableNone(\"\", potentialUnitType);\n}\nfunction getValueTransition(transition, key) {\n  return transition[key] || transition[\"default\"] || transition;\n}\n/**\n * Start animation on a MotionValue. This function is an interface between\n * Framer Motion and Popmotion\n *\n * @internal\n */\nfunction startAnimation(key, value, target, transition) {\n  if (transition === void 0) {\n    transition = {};\n  }\n  return value.start(function (onComplete) {\n    var delayTimer;\n    var controls;\n    var animation = getAnimation(key, value, target, transition, onComplete);\n    var delay = getDelayFromTransition(transition, key);\n    var start = function () {\n      return controls = animation();\n    };\n    if (delay) {\n      delayTimer = setTimeout(start, secondsToMilliseconds(delay));\n    } else {\n      start();\n    }\n    return function () {\n      clearTimeout(delayTimer);\n      controls === null || controls === void 0 ? void 0 : controls.stop();\n    };\n  });\n}\n\n/**\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n */\nvar isNumericalString = function (v) {\n  return /^\\-?\\d*\\.?\\d+$/.test(v);\n};\nfunction addUniqueItem(arr, item) {\n  arr.indexOf(item) === -1 && arr.push(item);\n}\nfunction removeItem(arr, item) {\n  var index = arr.indexOf(item);\n  index > -1 && arr.splice(index, 1);\n}\nvar SubscriptionManager = /** @class */function () {\n  function SubscriptionManager() {\n    this.subscriptions = [];\n  }\n  SubscriptionManager.prototype.add = function (handler) {\n    var _this = this;\n    addUniqueItem(this.subscriptions, handler);\n    return function () {\n      return removeItem(_this.subscriptions, handler);\n    };\n  };\n  SubscriptionManager.prototype.notify = function (a, b, c) {\n    var numSubscriptions = this.subscriptions.length;\n    if (!numSubscriptions) return;\n    if (numSubscriptions === 1) {\n      /**\n       * If there's only a single handler we can just call it without invoking a loop.\n       */\n      this.subscriptions[0](a, b, c);\n    } else {\n      for (var i = 0; i < numSubscriptions; i++) {\n        /**\n         * Check whether the handler exists before firing as it's possible\n         * the subscriptions were modified during this loop running.\n         */\n        var handler = this.subscriptions[i];\n        handler && handler(a, b, c);\n      }\n    }\n  };\n  SubscriptionManager.prototype.getSize = function () {\n    return this.subscriptions.length;\n  };\n  SubscriptionManager.prototype.clear = function () {\n    this.subscriptions.length = 0;\n  };\n  return SubscriptionManager;\n}();\nvar isFloat = function (value) {\n  return !isNaN(parseFloat(value));\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\nvar MotionValue = /** @class */function () {\n  /**\n   * @param init - The initiating value\n   * @param config - Optional configuration options\n   *\n   * -  `transformer`: A function to transform incoming values with.\n   *\n   * @internal\n   */\n  function MotionValue(init) {\n    var _this = this;\n    /**\n     * Duration, in milliseconds, since last updating frame.\n     *\n     * @internal\n     */\n    this.timeDelta = 0;\n    /**\n     * Timestamp of the last time this `MotionValue` was updated.\n     *\n     * @internal\n     */\n    this.lastUpdated = 0;\n    /**\n     * Functions to notify when the `MotionValue` updates.\n     *\n     * @internal\n     */\n    this.updateSubscribers = new SubscriptionManager();\n    /**\n     * Functions to notify when the velocity updates.\n     *\n     * @internal\n     */\n    this.velocityUpdateSubscribers = new SubscriptionManager();\n    /**\n     * Functions to notify when the `MotionValue` updates and `render` is set to `true`.\n     *\n     * @internal\n     */\n    this.renderSubscribers = new SubscriptionManager();\n    /**\n     * Tracks whether this value can output a velocity. Currently this is only true\n     * if the value is numerical, but we might be able to widen the scope here and support\n     * other value types.\n     *\n     * @internal\n     */\n    this.canTrackVelocity = false;\n    this.updateAndNotify = function (v, render) {\n      if (render === void 0) {\n        render = true;\n      }\n      _this.prev = _this.current;\n      _this.current = v;\n      // Update timestamp\n      var _a = sync.getFrameData(),\n        delta = _a.delta,\n        timestamp = _a.timestamp;\n      if (_this.lastUpdated !== timestamp) {\n        _this.timeDelta = delta;\n        _this.lastUpdated = timestamp;\n        sync__default['default'].postRender(_this.scheduleVelocityCheck);\n      }\n      // Update update subscribers\n      if (_this.prev !== _this.current) {\n        _this.updateSubscribers.notify(_this.current);\n      }\n      // Update velocity subscribers\n      if (_this.velocityUpdateSubscribers.getSize()) {\n        _this.velocityUpdateSubscribers.notify(_this.getVelocity());\n      }\n      // Update render subscribers\n      if (render) {\n        _this.renderSubscribers.notify(_this.current);\n      }\n    };\n    /**\n     * Schedule a velocity check for the next frame.\n     *\n     * This is an instanced and bound function to prevent generating a new\n     * function once per frame.\n     *\n     * @internal\n     */\n    this.scheduleVelocityCheck = function () {\n      return sync__default['default'].postRender(_this.velocityCheck);\n    };\n    /**\n     * Updates `prev` with `current` if the value hasn't been updated this frame.\n     * This ensures velocity calculations return `0`.\n     *\n     * This is an instanced and bound function to prevent generating a new\n     * function once per frame.\n     *\n     * @internal\n     */\n    this.velocityCheck = function (_a) {\n      var timestamp = _a.timestamp;\n      if (timestamp !== _this.lastUpdated) {\n        _this.prev = _this.current;\n        _this.velocityUpdateSubscribers.notify(_this.getVelocity());\n      }\n    };\n    this.hasAnimated = false;\n    this.prev = this.current = init;\n    this.canTrackVelocity = isFloat(this.current);\n  }\n  /**\n   * Adds a function that will be notified when the `MotionValue` is updated.\n   *\n   * It returns a function that, when called, will cancel the subscription.\n   *\n   * When calling `onChange` inside a React component, it should be wrapped with the\n   * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n   * from the `useEffect` function to ensure you don't add duplicate subscribers..\n   *\n   * @library\n   *\n   * ```jsx\n   * function MyComponent() {\n   *   const x = useMotionValue(0)\n   *   const y = useMotionValue(0)\n   *   const opacity = useMotionValue(1)\n   *\n   *   useEffect(() => {\n   *     function updateOpacity() {\n   *       const maxXY = Math.max(x.get(), y.get())\n   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n   *       opacity.set(newOpacity)\n   *     }\n   *\n   *     const unsubscribeX = x.onChange(updateOpacity)\n   *     const unsubscribeY = y.onChange(updateOpacity)\n   *\n   *     return () => {\n   *       unsubscribeX()\n   *       unsubscribeY()\n   *     }\n   *   }, [])\n   *\n   *   return <Frame x={x} />\n   * }\n   * ```\n   *\n   * @motion\n   *\n   * ```jsx\n   * export const MyComponent = () => {\n   *   const x = useMotionValue(0)\n   *   const y = useMotionValue(0)\n   *   const opacity = useMotionValue(1)\n   *\n   *   useEffect(() => {\n   *     function updateOpacity() {\n   *       const maxXY = Math.max(x.get(), y.get())\n   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n   *       opacity.set(newOpacity)\n   *     }\n   *\n   *     const unsubscribeX = x.onChange(updateOpacity)\n   *     const unsubscribeY = y.onChange(updateOpacity)\n   *\n   *     return () => {\n   *       unsubscribeX()\n   *       unsubscribeY()\n   *     }\n   *   }, [])\n   *\n   *   return <motion.div style={{ x }} />\n   * }\n   * ```\n   *\n   * @internalremarks\n   *\n   * We could look into a `useOnChange` hook if the above lifecycle management proves confusing.\n   *\n   * ```jsx\n   * useOnChange(x, () => {})\n   * ```\n   *\n   * @param subscriber - A function that receives the latest value.\n   * @returns A function that, when called, will cancel this subscription.\n   *\n   * @public\n   */\n  MotionValue.prototype.onChange = function (subscription) {\n    return this.updateSubscribers.add(subscription);\n  };\n  MotionValue.prototype.clearListeners = function () {\n    this.updateSubscribers.clear();\n  };\n  /**\n   * Adds a function that will be notified when the `MotionValue` requests a render.\n   *\n   * @param subscriber - A function that's provided the latest value.\n   * @returns A function that, when called, will cancel this subscription.\n   *\n   * @internal\n   */\n  MotionValue.prototype.onRenderRequest = function (subscription) {\n    // Render immediately\n    subscription(this.get());\n    return this.renderSubscribers.add(subscription);\n  };\n  /**\n   * Attaches a passive effect to the `MotionValue`.\n   *\n   * @internal\n   */\n  MotionValue.prototype.attach = function (passiveEffect) {\n    this.passiveEffect = passiveEffect;\n  };\n  /**\n   * Sets the state of the `MotionValue`.\n   *\n   * @remarks\n   *\n   * ```jsx\n   * const x = useMotionValue(0)\n   * x.set(10)\n   * ```\n   *\n   * @param latest - Latest value to set.\n   * @param render - Whether to notify render subscribers. Defaults to `true`\n   *\n   * @public\n   */\n  MotionValue.prototype.set = function (v, render) {\n    if (render === void 0) {\n      render = true;\n    }\n    if (!render || !this.passiveEffect) {\n      this.updateAndNotify(v, render);\n    } else {\n      this.passiveEffect(v, this.updateAndNotify);\n    }\n  };\n  /**\n   * Returns the latest state of `MotionValue`\n   *\n   * @returns - The latest state of `MotionValue`\n   *\n   * @public\n   */\n  MotionValue.prototype.get = function () {\n    return this.current;\n  };\n  /**\n   * @public\n   */\n  MotionValue.prototype.getPrevious = function () {\n    return this.prev;\n  };\n  /**\n   * Returns the latest velocity of `MotionValue`\n   *\n   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n   *\n   * @public\n   */\n  MotionValue.prototype.getVelocity = function () {\n    // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\n    return this.canTrackVelocity ?\n    // These casts could be avoided if parseFloat would be typed better\n    popmotion.velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;\n  };\n  /**\n   * Registers a new animation to control this `MotionValue`. Only one\n   * animation can drive a `MotionValue` at one time.\n   *\n   * ```jsx\n   * value.start()\n   * ```\n   *\n   * @param animation - A function that starts the provided animation\n   *\n   * @internal\n   */\n  MotionValue.prototype.start = function (animation) {\n    var _this = this;\n    this.stop();\n    return new Promise(function (resolve) {\n      _this.hasAnimated = true;\n      _this.stopAnimation = animation(resolve);\n    }).then(function () {\n      return _this.clearAnimation();\n    });\n  };\n  /**\n   * Stop the currently active animation.\n   *\n   * @public\n   */\n  MotionValue.prototype.stop = function () {\n    if (this.stopAnimation) this.stopAnimation();\n    this.clearAnimation();\n  };\n  /**\n   * Returns `true` if this value is currently animating.\n   *\n   * @public\n   */\n  MotionValue.prototype.isAnimating = function () {\n    return !!this.stopAnimation;\n  };\n  MotionValue.prototype.clearAnimation = function () {\n    this.stopAnimation = null;\n  };\n  /**\n   * Destroy and clean up subscribers to this `MotionValue`.\n   *\n   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n   * created a `MotionValue` via the `motionValue` function.\n   *\n   * @public\n   */\n  MotionValue.prototype.destroy = function () {\n    this.updateSubscribers.clear();\n    this.renderSubscribers.clear();\n    this.stop();\n  };\n  return MotionValue;\n}();\n/**\n * @internal\n */\nfunction motionValue(init) {\n  return new MotionValue(init);\n}\n\n/**\n * Tests a provided value against a ValueType\n */\nvar testValueType = function (v) {\n  return function (type) {\n    return type.test(v);\n  };\n};\n\n/**\n * ValueType for \"auto\"\n */\nvar auto = {\n  test: function (v) {\n    return v === \"auto\";\n  },\n  parse: function (v) {\n    return v;\n  }\n};\n\n/**\n * A list of value types commonly used for dimensions\n */\nvar dimensionValueTypes = [styleValueTypes.number, styleValueTypes.px, styleValueTypes.percent, styleValueTypes.degrees, styleValueTypes.vw, styleValueTypes.vh, auto];\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */\nvar findDimensionValueType = function (v) {\n  return dimensionValueTypes.find(testValueType(v));\n};\n\n/**\n * A list of all ValueTypes\n */\nvar valueTypes = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(dimensionValueTypes)), [styleValueTypes.color, styleValueTypes.complex]);\n/**\n * Tests a value against the list of ValueTypes\n */\nvar findValueType = function (v) {\n  return valueTypes.find(testValueType(v));\n};\n\n/**\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\n * it doesn't exist.\n */\nfunction setMotionValue(visualElement, key, value) {\n  if (visualElement.hasValue(key)) {\n    visualElement.getValue(key).set(value);\n  } else {\n    visualElement.addValue(key, motionValue(value));\n  }\n}\nfunction setTarget(visualElement, definition) {\n  var resolved = resolveVariant(visualElement, definition);\n  var _a = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {},\n    _b = _a.transitionEnd,\n    transitionEnd = _b === void 0 ? {} : _b;\n  _a.transition;\n  var target = tslib.__rest(_a, [\"transitionEnd\", \"transition\"]);\n  target = tslib.__assign(tslib.__assign({}, target), transitionEnd);\n  for (var key in target) {\n    var value = resolveFinalValueInKeyframes(target[key]);\n    setMotionValue(visualElement, key, value);\n  }\n}\nfunction setVariants(visualElement, variantLabels) {\n  var reversedLabels = tslib.__spreadArray([], tslib.__read(variantLabels)).reverse();\n  reversedLabels.forEach(function (key) {\n    var _a;\n    var variant = visualElement.getVariant(key);\n    variant && setTarget(visualElement, variant);\n    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n      setVariants(child, variantLabels);\n    });\n  });\n}\nfunction setValues(visualElement, definition) {\n  if (Array.isArray(definition)) {\n    return setVariants(visualElement, definition);\n  } else if (typeof definition === \"string\") {\n    return setVariants(visualElement, [definition]);\n  } else {\n    setTarget(visualElement, definition);\n  }\n}\nfunction checkTargetForNewValues(visualElement, target, origin) {\n  var _a, _b, _c;\n  var _d;\n  var newValueKeys = Object.keys(target).filter(function (key) {\n    return !visualElement.hasValue(key);\n  });\n  var numNewValues = newValueKeys.length;\n  if (!numNewValues) return;\n  for (var i = 0; i < numNewValues; i++) {\n    var key = newValueKeys[i];\n    var targetValue = target[key];\n    var value = null;\n    /**\n     * If the target is a series of keyframes, we can use the first value\n     * in the array. If this first value is null, we'll still need to read from the DOM.\n     */\n    if (Array.isArray(targetValue)) {\n      value = targetValue[0];\n    }\n    /**\n     * If the target isn't keyframes, or the first keyframe was null, we need to\n     * first check if an origin value was explicitly defined in the transition as \"from\",\n     * if not read the value from the DOM. As an absolute fallback, take the defined target value.\n     */\n    if (value === null) {\n      value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n    }\n    /**\n     * If value is still undefined or null, ignore it. Preferably this would throw,\n     * but this was causing issues in Framer.\n     */\n    if (value === undefined || value === null) continue;\n    if (typeof value === \"string\" && isNumericalString(value)) {\n      // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n      value = parseFloat(value);\n    } else if (!findValueType(value) && styleValueTypes.complex.test(targetValue)) {\n      value = getAnimatableNone(key, targetValue);\n    }\n    visualElement.addValue(key, motionValue(value));\n    (_c = (_d = origin)[key]) !== null && _c !== void 0 ? _c : _d[key] = value;\n    visualElement.setBaseTarget(key, value);\n  }\n}\nfunction getOriginFromTransition(key, transition) {\n  if (!transition) return;\n  var valueTransition = transition[key] || transition[\"default\"] || transition;\n  return valueTransition.from;\n}\nfunction getOrigin(target, transition, visualElement) {\n  var _a, _b;\n  var origin = {};\n  for (var key in target) {\n    origin[key] = (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();\n  }\n  return origin;\n}\n\n/**\n * @internal\n */\nfunction animateVisualElement(visualElement, definition, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  visualElement.notifyAnimationStart();\n  var animation;\n  if (Array.isArray(definition)) {\n    var animations = definition.map(function (variant) {\n      return animateVariant(visualElement, variant, options);\n    });\n    animation = Promise.all(animations);\n  } else if (typeof definition === \"string\") {\n    animation = animateVariant(visualElement, definition, options);\n  } else {\n    var resolvedDefinition = typeof definition === \"function\" ? resolveVariant(visualElement, definition, options.custom) : definition;\n    animation = animateTarget(visualElement, resolvedDefinition, options);\n  }\n  return animation.then(function () {\n    return visualElement.notifyAnimationComplete(definition);\n  });\n}\nfunction animateVariant(visualElement, variant, options) {\n  var _a;\n  if (options === void 0) {\n    options = {};\n  }\n  var resolved = resolveVariant(visualElement, variant, options.custom);\n  var _b = (resolved || {}).transition,\n    transition = _b === void 0 ? visualElement.getDefaultTransition() || {} : _b;\n  if (options.transitionOverride) {\n    transition = options.transitionOverride;\n  }\n  /**\n   * If we have a variant, create a callback that runs it as an animation.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n  var getAnimation = resolved ? function () {\n    return animateTarget(visualElement, resolved, options);\n  } : function () {\n    return Promise.resolve();\n  };\n  /**\n   * If we have children, create a callback that runs all their animations.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n  var getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? function (forwardDelay) {\n    if (forwardDelay === void 0) {\n      forwardDelay = 0;\n    }\n    var _a = transition.delayChildren,\n      delayChildren = _a === void 0 ? 0 : _a,\n      staggerChildren = transition.staggerChildren,\n      staggerDirection = transition.staggerDirection;\n    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n  } : function () {\n    return Promise.resolve();\n  };\n  /**\n   * If the transition explicitly defines a \"when\" option, we need to resolve either\n   * this animation or all children animations before playing the other.\n   */\n  var when = transition.when;\n  if (when) {\n    var _c = tslib.__read(when === \"beforeChildren\" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation], 2),\n      first = _c[0],\n      last = _c[1];\n    return first().then(last);\n  } else {\n    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n  }\n}\n/**\n * @internal\n */\nfunction animateTarget(visualElement, definition, _a) {\n  var _b;\n  var _c = _a === void 0 ? {} : _a,\n    _d = _c.delay,\n    delay = _d === void 0 ? 0 : _d,\n    transitionOverride = _c.transitionOverride,\n    type = _c.type;\n  var _e = visualElement.makeTargetAnimatable(definition),\n    _f = _e.transition,\n    transition = _f === void 0 ? visualElement.getDefaultTransition() : _f,\n    transitionEnd = _e.transitionEnd,\n    target = tslib.__rest(_e, [\"transition\", \"transitionEnd\"]);\n  if (transitionOverride) transition = transitionOverride;\n  var animations = [];\n  var animationTypeState = type && ((_b = visualElement.animationState) === null || _b === void 0 ? void 0 : _b.getState()[type]);\n  for (var key in target) {\n    var value = visualElement.getValue(key);\n    var valueTarget = target[key];\n    if (!value || valueTarget === undefined || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {\n      continue;\n    }\n    var animation = startAnimation(key, value, valueTarget, tslib.__assign({\n      delay: delay\n    }, transition));\n    animations.push(animation);\n  }\n  return Promise.all(animations).then(function () {\n    transitionEnd && setTarget(visualElement, transitionEnd);\n  });\n}\nfunction animateChildren(visualElement, variant, delayChildren, staggerChildren, staggerDirection, options) {\n  if (delayChildren === void 0) {\n    delayChildren = 0;\n  }\n  if (staggerChildren === void 0) {\n    staggerChildren = 0;\n  }\n  if (staggerDirection === void 0) {\n    staggerDirection = 1;\n  }\n  var animations = [];\n  var maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n  var generateStaggerDuration = staggerDirection === 1 ? function (i) {\n    if (i === void 0) {\n      i = 0;\n    }\n    return i * staggerChildren;\n  } : function (i) {\n    if (i === void 0) {\n      i = 0;\n    }\n    return maxStaggerDuration - i * staggerChildren;\n  };\n  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach(function (child, i) {\n    animations.push(animateVariant(child, variant, tslib.__assign(tslib.__assign({}, options), {\n      delay: delayChildren + generateStaggerDuration(i)\n    })).then(function () {\n      return child.notifyAnimationComplete(variant);\n    }));\n  });\n  return Promise.all(animations);\n}\nfunction stopAnimation(visualElement) {\n  visualElement.forEachValue(function (value) {\n    return value.stop();\n  });\n}\nfunction sortByTreeOrder(a, b) {\n  return a.sortNodePosition(b);\n}\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation(_a, key) {\n  var protectedKeys = _a.protectedKeys,\n    needsAnimating = _a.needsAnimating;\n  var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n  needsAnimating[key] = false;\n  return shouldBlock;\n}\nvar variantPriorityOrder = [AnimationType.Animate, AnimationType.Hover, AnimationType.Tap, AnimationType.Drag, AnimationType.Focus, AnimationType.Exit];\nvar reversePriorityOrder = tslib.__spreadArray([], tslib.__read(variantPriorityOrder)).reverse();\nvar numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n  return function (animations) {\n    return Promise.all(animations.map(function (_a) {\n      var animation = _a.animation,\n        options = _a.options;\n      return animateVisualElement(visualElement, animation, options);\n    }));\n  };\n}\nfunction createAnimationState(visualElement) {\n  var animate = animateList(visualElement);\n  var state = createState();\n  var allAnimatedKeys = {};\n  var isInitialRender = true;\n  /**\n   * This function will be used to reduce the animation definitions for\n   * each active animation type into an object of resolved values for it.\n   */\n  var buildResolvedTypeValues = function (acc, definition) {\n    var resolved = resolveVariant(visualElement, definition);\n    if (resolved) {\n      resolved.transition;\n      var transitionEnd = resolved.transitionEnd,\n        target = tslib.__rest(resolved, [\"transition\", \"transitionEnd\"]);\n      acc = tslib.__assign(tslib.__assign(tslib.__assign({}, acc), target), transitionEnd);\n    }\n    return acc;\n  };\n  function isAnimated(key) {\n    return allAnimatedKeys[key] !== undefined;\n  }\n  /**\n   * This just allows us to inject mocked animation functions\n   * @internal\n   */\n  function setAnimateFunction(makeAnimator) {\n    animate = makeAnimator(visualElement);\n  }\n  /**\n   * When we receive new props, we need to:\n   * 1. Create a list of protected keys for each type. This is a directory of\n   *    value keys that are currently being \"handled\" by types of a higher priority\n   *    so that whenever an animation is played of a given type, these values are\n   *    protected from being animated.\n   * 2. Determine if an animation type needs animating.\n   * 3. Determine if any values have been removed from a type and figure out\n   *    what to animate those to.\n   */\n  function animateChanges(options, changedActiveType) {\n    var _a;\n    var props = visualElement.getProps();\n    var context = visualElement.getVariantContext(true) || {};\n    /**\n     * A list of animations that we'll build into as we iterate through the animation\n     * types. This will get executed at the end of the function.\n     */\n    var animations = [];\n    /**\n     * Keep track of which values have been removed. Then, as we hit lower priority\n     * animation types, we can check if they contain removed values and animate to that.\n     */\n    var removedKeys = new Set();\n    /**\n     * A dictionary of all encountered keys. This is an object to let us build into and\n     * copy it without iteration. Each time we hit an animation type we set its protected\n     * keys - the keys its not allowed to animate - to the latest version of this object.\n     */\n    var encounteredKeys = {};\n    /**\n     * If a variant has been removed at a given index, and this component is controlling\n     * variant animations, we want to ensure lower-priority variants are forced to animate.\n     */\n    var removedVariantIndex = Infinity;\n    var _loop_1 = function (i) {\n      var type = reversePriorityOrder[i];\n      var typeState = state[type];\n      var prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];\n      var propIsVariant = isVariantLabel(prop);\n      /**\n       * If this type has *just* changed isActive status, set activeDelta\n       * to that status. Otherwise set to null.\n       */\n      var activeDelta = type === changedActiveType ? typeState.isActive : null;\n      if (activeDelta === false) removedVariantIndex = i;\n      /**\n       * If this prop is an inherited variant, rather than been set directly on the\n       * component itself, we want to make sure we allow the parent to trigger animations.\n       *\n       * TODO: Can probably change this to a !isControllingVariants check\n       */\n      var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n      /**\n       *\n       */\n      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {\n        isInherited = false;\n      }\n      /**\n       * Set all encountered keys so far as the protected keys for this type. This will\n       * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n       */\n      typeState.protectedKeys = tslib.__assign({}, encounteredKeys);\n      // Check if we can skip analysing this prop early\n      if (\n      // If it isn't active and hasn't *just* been set as inactive\n      !typeState.isActive && activeDelta === null ||\n      // If we didn't and don't have any defined prop for this animation type\n      !prop && !typeState.prevProp ||\n      // Or if the prop doesn't define an animation\n      isAnimationControls(prop) || typeof prop === \"boolean\") {\n        return \"continue\";\n      }\n      /**\n       * As we go look through the values defined on this type, if we detect\n       * a changed value or a value that was removed in a higher priority, we set\n       * this to true and add this prop to the animation list.\n       */\n      var shouldAnimateType = variantsHaveChanged(typeState.prevProp, prop) ||\n      // If we're making this variant active, we want to always make it active\n      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant ||\n      // If we removed a higher-priority variant (i is in reverse order)\n      i > removedVariantIndex && propIsVariant;\n      /**\n       * As animations can be set as variant lists, variants or target objects, we\n       * coerce everything to an array if it isn't one already\n       */\n      var definitionList = Array.isArray(prop) ? prop : [prop];\n      /**\n       * Build an object of all the resolved values. We'll use this in the subsequent\n       * animateChanges calls to determine whether a value has changed.\n       */\n      var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});\n      if (activeDelta === false) resolvedValues = {};\n      /**\n       * Now we need to loop through all the keys in the prev prop and this prop,\n       * and decide:\n       * 1. If the value has changed, and needs animating\n       * 2. If it has been removed, and needs adding to the removedKeys set\n       * 3. If it has been removed in a higher priority type and needs animating\n       * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n       *    needs adding to the type's protectedKeys list.\n       */\n      var _b = typeState.prevResolvedValues,\n        prevResolvedValues = _b === void 0 ? {} : _b;\n      var allKeys = tslib.__assign(tslib.__assign({}, prevResolvedValues), resolvedValues);\n      var markToAnimate = function (key) {\n        shouldAnimateType = true;\n        removedKeys.delete(key);\n        typeState.needsAnimating[key] = true;\n      };\n      for (var key in allKeys) {\n        var next = resolvedValues[key];\n        var prev = prevResolvedValues[key];\n        // If we've already handled this we can just skip ahead\n        if (encounteredKeys.hasOwnProperty(key)) continue;\n        /**\n         * If the value has changed, we probably want to animate it.\n         */\n        if (next !== prev) {\n          /**\n           * If both values are keyframes, we need to shallow compare them to\n           * detect whether any value has changed. If it has, we animate it.\n           */\n          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n            if (!shallowCompare(next, prev)) {\n              markToAnimate(key);\n            } else {\n              /**\n               * If it hasn't changed, we want to ensure it doesn't animate by\n               * adding it to the list of protected keys.\n               */\n              typeState.protectedKeys[key] = true;\n            }\n          } else if (next !== undefined) {\n            // If next is defined and doesn't equal prev, it needs animating\n            markToAnimate(key);\n          } else {\n            // If it's undefined, it's been removed.\n            removedKeys.add(key);\n          }\n        } else if (next !== undefined && removedKeys.has(key)) {\n          /**\n           * If next hasn't changed and it isn't undefined, we want to check if it's\n           * been removed by a higher priority\n           */\n          markToAnimate(key);\n        } else {\n          /**\n           * If it hasn't changed, we add it to the list of protected values\n           * to ensure it doesn't get animated.\n           */\n          typeState.protectedKeys[key] = true;\n        }\n      }\n      /**\n       * Update the typeState so next time animateChanges is called we can compare the\n       * latest prop and resolvedValues to these.\n       */\n      typeState.prevProp = prop;\n      typeState.prevResolvedValues = resolvedValues;\n      /**\n       *\n       */\n      if (typeState.isActive) {\n        encounteredKeys = tslib.__assign(tslib.__assign({}, encounteredKeys), resolvedValues);\n      }\n      if (isInitialRender && visualElement.blockInitialAnimation) {\n        shouldAnimateType = false;\n      }\n      /**\n       * If this is an inherited prop we want to hard-block animations\n       * TODO: Test as this should probably still handle animations triggered\n       * by removed values?\n       */\n      if (shouldAnimateType && !isInherited) {\n        animations.push.apply(animations, tslib.__spreadArray([], tslib.__read(definitionList.map(function (animation) {\n          return {\n            animation: animation,\n            options: tslib.__assign({\n              type: type\n            }, options)\n          };\n        }))));\n      }\n    };\n    /**\n     * Iterate through all animation types in reverse priority order. For each, we want to\n     * detect which values it's handling and whether or not they've changed (and therefore\n     * need to be animated). If any values have been removed, we want to detect those in\n     * lower priority props and flag for animation.\n     */\n    for (var i = 0; i < numAnimationTypes; i++) {\n      _loop_1(i);\n    }\n    allAnimatedKeys = tslib.__assign({}, encounteredKeys);\n    /**\n     * If there are some removed value that haven't been dealt with,\n     * we need to create a new animation that falls back either to the value\n     * defined in the style prop, or the last read value.\n     */\n    if (removedKeys.size) {\n      var fallbackAnimation_1 = {};\n      removedKeys.forEach(function (key) {\n        var fallbackTarget = visualElement.getBaseTarget(key);\n        if (fallbackTarget !== undefined) {\n          fallbackAnimation_1[key] = fallbackTarget;\n        }\n      });\n      animations.push({\n        animation: fallbackAnimation_1\n      });\n    }\n    var shouldAnimate = Boolean(animations.length);\n    if (isInitialRender && props.initial === false && !visualElement.manuallyAnimateOnMount) {\n      shouldAnimate = false;\n    }\n    isInitialRender = false;\n    return shouldAnimate ? animate(animations) : Promise.resolve();\n  }\n  /**\n   * Change whether a certain animation type is active.\n   */\n  function setActive(type, isActive, options) {\n    var _a;\n    // If the active state hasn't changed, we can safely do nothing here\n    if (state[type].isActive === isActive) return Promise.resolve();\n    // Propagate active change to children\n    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n      var _a;\n      return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive);\n    });\n    state[type].isActive = isActive;\n    return animateChanges(options, type);\n  }\n  return {\n    isAnimated: isAnimated,\n    animateChanges: animateChanges,\n    setActive: setActive,\n    setAnimateFunction: setAnimateFunction,\n    getState: function () {\n      return state;\n    }\n  };\n}\nfunction variantsHaveChanged(prev, next) {\n  if (typeof next === \"string\") {\n    return next !== prev;\n  } else if (isVariantLabels(next)) {\n    return !shallowCompare(next, prev);\n  }\n  return false;\n}\nfunction createTypeState(isActive) {\n  if (isActive === void 0) {\n    isActive = false;\n  }\n  return {\n    isActive: isActive,\n    protectedKeys: {},\n    needsAnimating: {},\n    prevResolvedValues: {}\n  };\n}\nfunction createState() {\n  var _a;\n  return _a = {}, _a[AnimationType.Animate] = createTypeState(true), _a[AnimationType.Hover] = createTypeState(), _a[AnimationType.Tap] = createTypeState(), _a[AnimationType.Drag] = createTypeState(), _a[AnimationType.Focus] = createTypeState(), _a[AnimationType.Exit] = createTypeState(), _a;\n}\nvar animations = {\n  animation: makeRenderlessComponent(function (_a) {\n    var visualElement = _a.visualElement,\n      animate = _a.animate;\n    /**\n     * We dynamically generate the AnimationState manager as it contains a reference\n     * to the underlying animation library. We only want to load that if we load this,\n     * so people can optionally code split it out using the `m` component.\n     */\n    visualElement.animationState || (visualElement.animationState = createAnimationState(visualElement));\n    /**\n     * Subscribe any provided AnimationControls to the component's VisualElement\n     */\n    if (isAnimationControls(animate)) {\n      React.useEffect(function () {\n        return animate.subscribe(visualElement);\n      }, [animate]);\n    }\n  }),\n  exit: makeRenderlessComponent(function (props) {\n    var custom = props.custom,\n      visualElement = props.visualElement;\n    var _a = tslib.__read(usePresence(), 2),\n      isPresent = _a[0],\n      onExitComplete = _a[1];\n    var presenceContext = React.useContext(PresenceContext);\n    React.useEffect(function () {\n      var _a, _b;\n      var animation = (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Exit, !isPresent, {\n        custom: (_b = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== null && _b !== void 0 ? _b : custom\n      });\n      !isPresent && (animation === null || animation === void 0 ? void 0 : animation.then(onExitComplete));\n    }, [isPresent]);\n  })\n};\n\n/**\n * @internal\n */\nvar PanSession = /** @class */function () {\n  function PanSession(event, handlers, _a) {\n    var _this = this;\n    var _b = _a === void 0 ? {} : _a,\n      transformPagePoint = _b.transformPagePoint;\n    /**\n     * @internal\n     */\n    this.startEvent = null;\n    /**\n     * @internal\n     */\n    this.lastMoveEvent = null;\n    /**\n     * @internal\n     */\n    this.lastMoveEventInfo = null;\n    /**\n     * @internal\n     */\n    this.handlers = {};\n    this.updatePoint = function () {\n      if (!(_this.lastMoveEvent && _this.lastMoveEventInfo)) return;\n      var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\n      var isPanStarted = _this.startEvent !== null;\n      // Only start panning if the offset is larger than 3 pixels. If we make it\n      // any larger than this we'll want to reset the pointer history\n      // on the first update to avoid visual snapping to the cursoe.\n      var isDistancePastThreshold = popmotion.distance(info.offset, {\n        x: 0,\n        y: 0\n      }) >= 3;\n      if (!isPanStarted && !isDistancePastThreshold) return;\n      var point = info.point;\n      var timestamp = sync.getFrameData().timestamp;\n      _this.history.push(tslib.__assign(tslib.__assign({}, point), {\n        timestamp: timestamp\n      }));\n      var _a = _this.handlers,\n        onStart = _a.onStart,\n        onMove = _a.onMove;\n      if (!isPanStarted) {\n        onStart && onStart(_this.lastMoveEvent, info);\n        _this.startEvent = _this.lastMoveEvent;\n      }\n      onMove && onMove(_this.lastMoveEvent, info);\n    };\n    this.handlePointerMove = function (event, info) {\n      _this.lastMoveEvent = event;\n      _this.lastMoveEventInfo = transformPoint(info, _this.transformPagePoint);\n      // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n      if (isMouseEvent(event) && event.buttons === 0) {\n        _this.handlePointerUp(event, info);\n        return;\n      }\n      // Throttle mouse move event to once per frame\n      sync__default['default'].update(_this.updatePoint, true);\n    };\n    this.handlePointerUp = function (event, info) {\n      _this.end();\n      var _a = _this.handlers,\n        onEnd = _a.onEnd,\n        onSessionEnd = _a.onSessionEnd;\n      var panInfo = getPanInfo(transformPoint(info, _this.transformPagePoint), _this.history);\n      if (_this.startEvent && onEnd) {\n        onEnd(event, panInfo);\n      }\n      onSessionEnd && onSessionEnd(event, panInfo);\n    };\n    // If we have more than one touch, don't start detecting this gesture\n    if (isTouchEvent(event) && event.touches.length > 1) return;\n    this.handlers = handlers;\n    this.transformPagePoint = transformPagePoint;\n    var info = extractEventInfo(event);\n    var initialInfo = transformPoint(info, this.transformPagePoint);\n    var point = initialInfo.point;\n    var timestamp = sync.getFrameData().timestamp;\n    this.history = [tslib.__assign(tslib.__assign({}, point), {\n      timestamp: timestamp\n    })];\n    var onSessionStart = handlers.onSessionStart;\n    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n    this.removeListeners = popmotion.pipe(addPointerEvent(window, \"pointermove\", this.handlePointerMove), addPointerEvent(window, \"pointerup\", this.handlePointerUp), addPointerEvent(window, \"pointercancel\", this.handlePointerUp));\n  }\n  PanSession.prototype.updateHandlers = function (handlers) {\n    this.handlers = handlers;\n  };\n  PanSession.prototype.end = function () {\n    this.removeListeners && this.removeListeners();\n    sync.cancelSync.update(this.updatePoint);\n  };\n  return PanSession;\n}();\nfunction transformPoint(info, transformPagePoint) {\n  return transformPagePoint ? {\n    point: transformPagePoint(info.point)\n  } : info;\n}\nfunction subtractPoint(a, b) {\n  return {\n    x: a.x - b.x,\n    y: a.y - b.y\n  };\n}\nfunction getPanInfo(_a, history) {\n  var point = _a.point;\n  return {\n    point: point,\n    delta: subtractPoint(point, lastDevicePoint(history)),\n    offset: subtractPoint(point, startDevicePoint(history)),\n    velocity: getVelocity(history, 0.1)\n  };\n}\nfunction startDevicePoint(history) {\n  return history[0];\n}\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n  if (history.length < 2) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  var i = history.length - 1;\n  var timestampedPoint = null;\n  var lastPoint = lastDevicePoint(history);\n  while (i >= 0) {\n    timestampedPoint = history[i];\n    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {\n      break;\n    }\n    i--;\n  }\n  if (!timestampedPoint) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n  if (time === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  var currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n  return currentVelocity;\n}\nfunction noop(any) {\n  return any;\n}\n\n/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it's easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */\nfunction convertBoundingBoxToAxisBox(_a) {\n  var top = _a.top,\n    left = _a.left,\n    right = _a.right,\n    bottom = _a.bottom;\n  return {\n    x: {\n      min: left,\n      max: right\n    },\n    y: {\n      min: top,\n      max: bottom\n    }\n  };\n}\nfunction convertAxisBoxToBoundingBox(_a) {\n  var x = _a.x,\n    y = _a.y;\n  return {\n    top: y.min,\n    bottom: y.max,\n    left: x.min,\n    right: x.max\n  };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */\nfunction transformBoundingBox(_a, transformPoint) {\n  var top = _a.top,\n    left = _a.left,\n    bottom = _a.bottom,\n    right = _a.right;\n  if (transformPoint === void 0) {\n    transformPoint = noop;\n  }\n  var topLeft = transformPoint({\n    x: left,\n    y: top\n  });\n  var bottomRight = transformPoint({\n    x: right,\n    y: bottom\n  });\n  return {\n    top: topLeft.y,\n    left: topLeft.x,\n    bottom: bottomRight.y,\n    right: bottomRight.x\n  };\n}\n/**\n * Create an empty axis box of zero size\n */\nfunction axisBox() {\n  return {\n    x: {\n      min: 0,\n      max: 1\n    },\n    y: {\n      min: 0,\n      max: 1\n    }\n  };\n}\nfunction copyAxisBox(box) {\n  return {\n    x: tslib.__assign({}, box.x),\n    y: tslib.__assign({}, box.y)\n  };\n}\n/**\n * Create an empty box delta\n */\nvar zeroDelta = {\n  translate: 0,\n  scale: 1,\n  origin: 0,\n  originPoint: 0\n};\nfunction delta() {\n  return {\n    x: tslib.__assign({}, zeroDelta),\n    y: tslib.__assign({}, zeroDelta)\n  };\n}\n\n// Call a handler once for each axis\nfunction eachAxis(handler) {\n  return [handler(\"x\"), handler(\"y\")];\n}\nvar clampProgress = function (v) {\n  return popmotion.clamp(0, 1, v);\n};\n/**\n * Returns true if the provided value is within maxDistance of the provided target\n */\nfunction isNear(value, target, maxDistance) {\n  if (target === void 0) {\n    target = 0;\n  }\n  if (maxDistance === void 0) {\n    maxDistance = 0.01;\n  }\n  return popmotion.distance(value, target) < maxDistance;\n}\nfunction calcLength(axis) {\n  return axis.max - axis.min;\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\nfunction calcOrigin(source, target) {\n  var origin = 0.5;\n  var sourceLength = calcLength(source);\n  var targetLength = calcLength(target);\n  if (targetLength > sourceLength) {\n    origin = popmotion.progress(target.min, target.max - sourceLength, source.min);\n  } else if (sourceLength > targetLength) {\n    origin = popmotion.progress(source.min, source.max - targetLength, target.min);\n  }\n  return clampProgress(origin);\n}\n/**\n * Update the AxisDelta with a transform that projects source into target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\nfunction updateAxisDelta(delta, source, target, origin) {\n  if (origin === void 0) {\n    origin = 0.5;\n  }\n  delta.origin = origin;\n  delta.originPoint = popmotion.mix(source.min, source.max, delta.origin);\n  delta.scale = calcLength(target) / calcLength(source);\n  if (isNear(delta.scale, 1, 0.0001)) delta.scale = 1;\n  delta.translate = popmotion.mix(target.min, target.max, delta.origin) - delta.originPoint;\n  if (isNear(delta.translate)) delta.translate = 0;\n}\n/**\n * Update the BoxDelta with a transform that projects the source into the target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\nfunction updateBoxDelta(delta, source, target, origin) {\n  updateAxisDelta(delta.x, source.x, target.x, defaultOrigin(origin.originX));\n  updateAxisDelta(delta.y, source.y, target.y, defaultOrigin(origin.originY));\n}\n/**\n * Currently this only accepts numerical origins, measured as 0-1, but could\n * accept pixel values by comparing to the target axis.\n */\nfunction defaultOrigin(origin) {\n  return typeof origin === \"number\" ? origin : 0.5;\n}\nfunction calcRelativeAxis(target, relative, parent) {\n  target.min = parent.min + relative.min;\n  target.max = target.min + calcLength(relative);\n}\nfunction calcRelativeBox(projection, parentProjection) {\n  calcRelativeAxis(projection.target.x, projection.relativeTarget.x, parentProjection.target.x);\n  calcRelativeAxis(projection.target.y, projection.relativeTarget.y, parentProjection.target.y);\n}\n\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\nfunction applyConstraints(point, _a, elastic) {\n  var min = _a.min,\n    max = _a.max;\n  if (min !== undefined && point < min) {\n    // If we have a min point defined, and this is outside of that, constrain\n    point = elastic ? popmotion.mix(min, point, elastic.min) : Math.max(point, min);\n  } else if (max !== undefined && point > max) {\n    // If we have a max point defined, and this is outside of that, constrain\n    point = elastic ? popmotion.mix(max, point, elastic.max) : Math.min(point, max);\n  }\n  return point;\n}\n/**\n * Calculates a min projection point based on a pointer, pointer progress\n * within the drag target, and constraints.\n *\n * For instance if an element was 100px width, we were dragging from 0.25\n * along this axis, the pointer is at 200px, and there were no constraints,\n * we would calculate a min projection point of 175px.\n */\nfunction calcConstrainedMinPoint(point, length, progress, constraints, elastic) {\n  // Calculate a min point for this axis and apply it to the current pointer\n  var min = point - length * progress;\n  return constraints ? applyConstraints(min, constraints, elastic) : min;\n}\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */\nfunction calcRelativeAxisConstraints(axis, min, max) {\n  return {\n    min: min !== undefined ? axis.min + min : undefined,\n    max: max !== undefined ? axis.max + max - (axis.max - axis.min) : undefined\n  };\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\nfunction calcRelativeConstraints(layoutBox, _a) {\n  var top = _a.top,\n    left = _a.left,\n    bottom = _a.bottom,\n    right = _a.right;\n  return {\n    x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)\n  };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n  var _a;\n  var min = constraintsAxis.min - layoutAxis.min;\n  var max = constraintsAxis.max - layoutAxis.max;\n  // If the constraints axis is actually smaller than the layout axis then we can\n  // flip the constraints\n  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {\n    _a = tslib.__read([max, min], 2), min = _a[0], max = _a[1];\n  }\n  return {\n    min: layoutAxis.min + min,\n    max: layoutAxis.min + max\n  };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n  return {\n    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)\n  };\n}\n/**\n * Calculate the an axis position based on two axes and a progress value.\n */\nfunction calcPositionFromProgress(axis, constraints, progress) {\n  var axisLength = axis.max - axis.min;\n  var min = popmotion.mix(constraints.min, constraints.max - axisLength, progress);\n  return {\n    min: min,\n    max: min + axisLength\n  };\n}\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */\nfunction rebaseAxisConstraints(layout, constraints) {\n  var relativeConstraints = {};\n  if (constraints.min !== undefined) {\n    relativeConstraints.min = constraints.min - layout.min;\n  }\n  if (constraints.max !== undefined) {\n    relativeConstraints.max = constraints.max - layout.min;\n  }\n  return relativeConstraints;\n}\nvar defaultElastic = 0.35;\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */\nfunction resolveDragElastic(dragElastic) {\n  if (dragElastic === false) {\n    dragElastic = 0;\n  } else if (dragElastic === true) {\n    dragElastic = defaultElastic;\n  }\n  return {\n    x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n    y: resolveAxisElastic(dragElastic, \"top\", \"bottom\")\n  };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n  return {\n    min: resolvePointElastic(dragElastic, minLabel),\n    max: resolvePointElastic(dragElastic, maxLabel)\n  };\n}\nfunction resolvePointElastic(dragElastic, label) {\n  var _a;\n  return typeof dragElastic === \"number\" ? dragElastic : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;\n}\n\n/**\n * Measure and return the element bounding box.\n *\n * We convert the box into an AxisBox2D to make it easier to work with each axis\n * individually and programmatically.\n *\n * This function optionally accepts a transformPagePoint function which allows us to compensate\n * for, for instance, measuring the element within a scaled plane like a Framer devivce preview component.\n */\nfunction getBoundingBox(element, transformPagePoint) {\n  var box = element.getBoundingClientRect();\n  return convertBoundingBoxToAxisBox(transformBoundingBox(box, transformPagePoint));\n}\nvar compareByDepth = function (a, b) {\n  return a.depth - b.depth;\n};\nfunction isProjecting(visualElement) {\n  var isEnabled = visualElement.projection.isEnabled;\n  return isEnabled || visualElement.shouldResetTransform();\n}\nfunction collectProjectingAncestors(visualElement, ancestors) {\n  if (ancestors === void 0) {\n    ancestors = [];\n  }\n  var parent = visualElement.parent;\n  if (parent) collectProjectingAncestors(parent, ancestors);\n  if (isProjecting(visualElement)) ancestors.push(visualElement);\n  return ancestors;\n}\nfunction collectProjectingChildren(visualElement) {\n  var children = [];\n  var addChild = function (child) {\n    if (isProjecting(child)) children.push(child);\n    child.children.forEach(addChild);\n  };\n  visualElement.children.forEach(addChild);\n  return children.sort(compareByDepth);\n}\n/**\n * Update the layoutState by measuring the DOM layout. This\n * should be called after resetting any layout-affecting transforms.\n */\nfunction updateLayoutMeasurement(visualElement) {\n  if (visualElement.shouldResetTransform()) return;\n  var layoutState = visualElement.getLayoutState();\n  visualElement.notifyBeforeLayoutMeasure(layoutState.layout);\n  layoutState.isHydrated = true;\n  layoutState.layout = visualElement.measureViewportBox();\n  layoutState.layoutCorrected = copyAxisBox(layoutState.layout);\n  visualElement.notifyLayoutMeasure(layoutState.layout, visualElement.prevViewportBox || layoutState.layout);\n  sync__default['default'].update(function () {\n    return visualElement.rebaseProjectionTarget();\n  });\n}\n/**\n * Record the viewport box as it was before an expected mutation/re-render\n */\nfunction snapshotViewportBox(visualElement) {\n  if (visualElement.shouldResetTransform()) return;\n  visualElement.prevViewportBox = visualElement.measureViewportBox(false);\n  /**\n   * Update targetBox to match the prevViewportBox. This is just to ensure\n   * that targetBox is affected by scroll in the same way as the measured box\n   */\n  visualElement.rebaseProjectionTarget(false, visualElement.prevViewportBox);\n}\nfunction tweenAxis(target, prev, next, p) {\n  target.min = popmotion.mix(prev.min, next.min, p);\n  target.max = popmotion.mix(prev.max, next.max, p);\n}\nfunction calcRelativeOffsetAxis(parent, child) {\n  return {\n    min: child.min - parent.min,\n    max: child.max - parent.min\n  };\n}\nfunction calcRelativeOffset(parent, child) {\n  return {\n    x: calcRelativeOffsetAxis(parent.x, child.x),\n    y: calcRelativeOffsetAxis(parent.y, child.y)\n  };\n}\nfunction checkIfParentHasChanged(prev, next) {\n  var prevId = prev.getLayoutId();\n  var nextId = next.getLayoutId();\n  return prevId !== nextId || nextId === undefined && prev !== next;\n}\nfunction isDraggable(visualElement) {\n  var _a = visualElement.getProps(),\n    drag = _a.drag,\n    _dragX = _a._dragX;\n  return drag && !_dragX;\n}\n\n/**\n * Reset an axis to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction resetAxis(axis, originAxis) {\n  axis.min = originAxis.min;\n  axis.max = originAxis.max;\n}\n/**\n * Reset a box to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction resetBox(box, originBox) {\n  resetAxis(box.x, originBox.x);\n  resetAxis(box.y, originBox.y);\n}\n/**\n * Scales a point based on a factor and an originPoint\n */\nfunction scalePoint(point, scale, originPoint) {\n  var distanceFromOrigin = point - originPoint;\n  var scaled = scale * distanceFromOrigin;\n  return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n  if (boxScale !== undefined) {\n    point = scalePoint(point, boxScale, originPoint);\n  }\n  return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\nfunction applyAxisDelta(axis, translate, scale, originPoint, boxScale) {\n  if (translate === void 0) {\n    translate = 0;\n  }\n  if (scale === void 0) {\n    scale = 1;\n  }\n  axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n  axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\nfunction applyBoxDelta(box, _a) {\n  var x = _a.x,\n    y = _a.y;\n  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nfunction applyAxisTransforms(final, axis, transforms, _a) {\n  var _b = tslib.__read(_a, 3),\n    key = _b[0],\n    scaleKey = _b[1],\n    originKey = _b[2];\n  // Copy the current axis to the final axis before mutation\n  final.min = axis.min;\n  final.max = axis.max;\n  var axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;\n  var originPoint = popmotion.mix(axis.min, axis.max, axisOrigin);\n  // Apply the axis delta to the final axis\n  applyAxisDelta(final, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\nvar xKeys = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nfunction applyBoxTransforms(finalBox, box, transforms) {\n  applyAxisTransforms(finalBox.x, box.x, transforms, xKeys);\n  applyAxisTransforms(finalBox.y, box.y, transforms, yKeys);\n}\n/**\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\n */\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\n  point -= translate;\n  point = scalePoint(point, 1 / scale, originPoint);\n  if (boxScale !== undefined) {\n    point = scalePoint(point, 1 / boxScale, originPoint);\n  }\n  return point;\n}\n/**\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\n */\nfunction removeAxisDelta(axis, translate, scale, origin, boxScale) {\n  if (translate === void 0) {\n    translate = 0;\n  }\n  if (scale === void 0) {\n    scale = 1;\n  }\n  if (origin === void 0) {\n    origin = 0.5;\n  }\n  var originPoint = popmotion.mix(axis.min, axis.max, origin) - translate;\n  axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\n  axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeAxisTransforms(axis, transforms, _a) {\n  var _b = tslib.__read(_a, 3),\n    key = _b[0],\n    scaleKey = _b[1],\n    originKey = _b[2];\n  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale);\n}\n/**\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeBoxTransforms(box, transforms) {\n  removeAxisTransforms(box.x, transforms, xKeys);\n  removeAxisTransforms(box.y, transforms, yKeys);\n}\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\nfunction applyTreeDeltas(box, treeScale, treePath) {\n  var treeLength = treePath.length;\n  if (!treeLength) return;\n  // Reset the treeScale\n  treeScale.x = treeScale.y = 1;\n  var node;\n  var delta;\n  for (var i = 0; i < treeLength; i++) {\n    node = treePath[i];\n    delta = node.getLayoutState().delta;\n    // Incoporate each ancestor's scale into a culmulative treeScale for this component\n    treeScale.x *= delta.x.scale;\n    treeScale.y *= delta.y.scale;\n    // Apply each ancestor's calculated delta into this component's recorded layout box\n    applyBoxDelta(box, delta);\n    // If this is a draggable ancestor, also incorporate the node's transform to the layout box\n    if (isDraggable(node)) {\n      applyBoxTransforms(box, box, node.getLatestValues());\n    }\n  }\n}\n\n/**\n * Returns a boolean stating whether or not we converted the projection\n * to relative projection.\n */\nfunction convertToRelativeProjection(visualElement, isLayoutDrag) {\n  if (isLayoutDrag === void 0) {\n    isLayoutDrag = true;\n  }\n  var projectionParent = visualElement.getProjectionParent();\n  if (!projectionParent) return false;\n  var offset;\n  if (isLayoutDrag) {\n    offset = calcRelativeOffset(projectionParent.projection.target, visualElement.projection.target);\n    removeBoxTransforms(offset, projectionParent.getLatestValues());\n  } else {\n    offset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement.getLayoutState().layout);\n  }\n  eachAxis(function (axis) {\n    return visualElement.setProjectionTargetAxis(axis, offset[axis].min, offset[axis].max, true);\n  });\n  return true;\n}\nvar unresolvedJobs = new Set();\nfunction pushJob(stack, job, pointer) {\n  if (!stack[pointer]) stack[pointer] = [];\n  stack[pointer].push(job);\n}\nfunction batchLayout(callback) {\n  unresolvedJobs.add(callback);\n  return function () {\n    return unresolvedJobs.delete(callback);\n  };\n}\nfunction flushLayout() {\n  if (!unresolvedJobs.size) return;\n  var pointer = 0;\n  var reads = [[]];\n  var writes = [];\n  var setRead = function (job) {\n    return pushJob(reads, job, pointer);\n  };\n  var setWrite = function (job) {\n    pushJob(writes, job, pointer);\n    pointer++;\n  };\n  /**\n   * Resolve jobs into their array stacks\n   */\n  unresolvedJobs.forEach(function (callback) {\n    callback(setRead, setWrite);\n    pointer = 0;\n  });\n  unresolvedJobs.clear();\n  /**\n   * Execute jobs\n   */\n  var numStacks = writes.length;\n  for (var i = 0; i <= numStacks; i++) {\n    reads[i] && reads[i].forEach(executeJob);\n    writes[i] && writes[i].forEach(executeJob);\n  }\n}\nvar executeJob = function (job) {\n  return job();\n};\nvar elementDragControls = new WeakMap();\n/**\n *\n */\nvar lastPointerEvent;\nvar VisualElementDragControls = /** @class */function () {\n  function VisualElementDragControls(_a) {\n    var visualElement = _a.visualElement;\n    /**\n     * Track whether we're currently dragging.\n     *\n     * @internal\n     */\n    this.isDragging = false;\n    /**\n     * The current direction of drag, or `null` if both.\n     *\n     * @internal\n     */\n    this.currentDirection = null;\n    /**\n     * The permitted boundaries of travel, in pixels.\n     *\n     * @internal\n     */\n    this.constraints = false;\n    /**\n     * The per-axis resolved elastic values.\n     *\n     * @internal\n     */\n    this.elastic = axisBox();\n    /**\n     * A reference to the host component's latest props.\n     *\n     * @internal\n     */\n    this.props = {};\n    /**\n     * @internal\n     */\n    this.hasMutatedConstraints = false;\n    /**\n     * Track the initial position of the cursor relative to the dragging element\n     * when dragging starts as a value of 0-1 on each axis. We then use this to calculate\n     * an ideal bounding box for the VisualElement renderer to project into every frame.\n     *\n     * @internal\n     */\n    this.cursorProgress = {\n      x: 0.5,\n      y: 0.5\n    };\n    // When updating _dragX, or _dragY instead of the VisualElement,\n    // persist their values between drag gestures.\n    this.originPoint = {};\n    // This is a reference to the global drag gesture lock, ensuring only one component\n    // can \"capture\" the drag of one or both axes.\n    // TODO: Look into moving this into pansession?\n    this.openGlobalLock = null;\n    /**\n     * @internal\n     */\n    this.panSession = null;\n    this.visualElement = visualElement;\n    this.visualElement.enableLayoutProjection();\n    elementDragControls.set(visualElement, this);\n  }\n  /**\n   * Instantiate a PanSession for the drag gesture\n   *\n   * @public\n   */\n  VisualElementDragControls.prototype.start = function (originEvent, _a) {\n    var _this = this;\n    var _b = _a === void 0 ? {} : _a,\n      _c = _b.snapToCursor,\n      snapToCursor = _c === void 0 ? false : _c,\n      cursorProgress = _b.cursorProgress;\n    var onSessionStart = function (event) {\n      var _a;\n      // Stop any animations on both axis values immediately. This allows the user to throw and catch\n      // the component.\n      _this.stopMotion();\n      /**\n       * Save the initial point. We'll use this to calculate the pointer's position rather\n       * than the one we receive when the gesture actually starts. By then, the pointer will\n       * have already moved, and the perception will be of the pointer \"slipping\" across the element\n       */\n      var initialPoint = getViewportPointFromEvent(event).point;\n      (_a = _this.cancelLayout) === null || _a === void 0 ? void 0 : _a.call(_this);\n      _this.cancelLayout = batchLayout(function (read, write) {\n        var ancestors = collectProjectingAncestors(_this.visualElement);\n        var children = collectProjectingChildren(_this.visualElement);\n        var tree = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(ancestors)), tslib.__read(children));\n        var hasManuallySetCursorOrigin = false;\n        /**\n         * Apply a simple lock to the projection target. This ensures no animations\n         * can run on the projection box while this lock is active.\n         */\n        _this.isLayoutDrag() && _this.visualElement.lockProjectionTarget();\n        write(function () {\n          tree.forEach(function (element) {\n            return element.resetTransform();\n          });\n        });\n        read(function () {\n          updateLayoutMeasurement(_this.visualElement);\n          children.forEach(updateLayoutMeasurement);\n        });\n        write(function () {\n          tree.forEach(function (element) {\n            return element.restoreTransform();\n          });\n          if (snapToCursor) {\n            hasManuallySetCursorOrigin = _this.snapToCursor(initialPoint);\n          }\n        });\n        read(function () {\n          var isRelativeDrag = Boolean(_this.getAxisMotionValue(\"x\") && !_this.isExternalDrag());\n          if (!isRelativeDrag) {\n            _this.visualElement.rebaseProjectionTarget(true, _this.visualElement.measureViewportBox(false));\n          }\n          _this.visualElement.scheduleUpdateLayoutProjection();\n          /**\n           * When dragging starts, we want to find where the cursor is relative to the bounding box\n           * of the element. Every frame, we calculate a new bounding box using this relative position\n           * and let the visualElement renderer figure out how to reproject the element into this bounding\n           * box.\n           *\n           * By doing it this way, rather than applying an x/y transform directly to the element,\n           * we can ensure the component always visually sticks to the cursor as we'd expect, even\n           * if the DOM element itself changes layout as a result of React updates the user might\n           * make based on the drag position.\n           */\n          var projection = _this.visualElement.projection;\n          eachAxis(function (axis) {\n            if (!hasManuallySetCursorOrigin) {\n              var _a = projection.target[axis],\n                min = _a.min,\n                max = _a.max;\n              _this.cursorProgress[axis] = cursorProgress ? cursorProgress[axis] : popmotion.progress(min, max, initialPoint[axis]);\n            }\n            /**\n             * If we have external drag MotionValues, record their origin point. On pointermove\n             * we'll apply the pan gesture offset directly to this value.\n             */\n            var axisValue = _this.getAxisMotionValue(axis);\n            if (axisValue) {\n              _this.originPoint[axis] = axisValue.get();\n            }\n          });\n        });\n        write(function () {\n          sync.flushSync.update();\n          sync.flushSync.preRender();\n          sync.flushSync.render();\n          sync.flushSync.postRender();\n        });\n        read(function () {\n          return _this.resolveDragConstraints();\n        });\n      });\n    };\n    var onStart = function (event, info) {\n      var _a, _b, _c;\n      // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n      var _d = _this.props,\n        drag = _d.drag,\n        dragPropagation = _d.dragPropagation;\n      if (drag && !dragPropagation) {\n        if (_this.openGlobalLock) _this.openGlobalLock();\n        _this.openGlobalLock = getGlobalLock(drag);\n        // If we don 't have the lock, don't start dragging\n        if (!_this.openGlobalLock) return;\n      }\n      flushLayout();\n      // Set current drag status\n      _this.isDragging = true;\n      _this.currentDirection = null;\n      // Fire onDragStart event\n      (_b = (_a = _this.props).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a, event, info);\n      (_c = _this.visualElement.animationState) === null || _c === void 0 ? void 0 : _c.setActive(AnimationType.Drag, true);\n    };\n    var onMove = function (event, info) {\n      var _a, _b, _c, _d;\n      var _e = _this.props,\n        dragPropagation = _e.dragPropagation,\n        dragDirectionLock = _e.dragDirectionLock;\n      // If we didn't successfully receive the gesture lock, early return.\n      if (!dragPropagation && !_this.openGlobalLock) return;\n      var offset = info.offset;\n      // Attempt to detect drag direction if directionLock is true\n      if (dragDirectionLock && _this.currentDirection === null) {\n        _this.currentDirection = getCurrentDirection(offset);\n        // If we've successfully set a direction, notify listener\n        if (_this.currentDirection !== null) {\n          (_b = (_a = _this.props).onDirectionLock) === null || _b === void 0 ? void 0 : _b.call(_a, _this.currentDirection);\n        }\n        return;\n      }\n      // Update each point with the latest position\n      _this.updateAxis(\"x\", info.point, offset);\n      _this.updateAxis(\"y\", info.point, offset);\n      // Fire onDrag event\n      (_d = (_c = _this.props).onDrag) === null || _d === void 0 ? void 0 : _d.call(_c, event, info);\n      // Update the last pointer event\n      lastPointerEvent = event;\n    };\n    var onSessionEnd = function (event, info) {\n      return _this.stop(event, info);\n    };\n    var transformPagePoint = this.props.transformPagePoint;\n    this.panSession = new PanSession(originEvent, {\n      onSessionStart: onSessionStart,\n      onStart: onStart,\n      onMove: onMove,\n      onSessionEnd: onSessionEnd\n    }, {\n      transformPagePoint: transformPagePoint\n    });\n  };\n  VisualElementDragControls.prototype.resolveDragConstraints = function () {\n    var _this = this;\n    var _a = this.props,\n      dragConstraints = _a.dragConstraints,\n      dragElastic = _a.dragElastic;\n    var layout = this.visualElement.getLayoutState().layoutCorrected;\n    if (dragConstraints) {\n      this.constraints = isRefObject(dragConstraints) ? this.resolveRefConstraints(layout, dragConstraints) : calcRelativeConstraints(layout, dragConstraints);\n    } else {\n      this.constraints = false;\n    }\n    this.elastic = resolveDragElastic(dragElastic);\n    /**\n     * If we're outputting to external MotionValues, we want to rebase the measured constraints\n     * from viewport-relative to component-relative.\n     */\n    if (this.constraints && !this.hasMutatedConstraints) {\n      eachAxis(function (axis) {\n        if (_this.getAxisMotionValue(axis)) {\n          _this.constraints[axis] = rebaseAxisConstraints(layout[axis], _this.constraints[axis]);\n        }\n      });\n    }\n  };\n  VisualElementDragControls.prototype.resolveRefConstraints = function (layoutBox, constraints) {\n    var _a = this.props,\n      onMeasureDragConstraints = _a.onMeasureDragConstraints,\n      transformPagePoint = _a.transformPagePoint;\n    var constraintsElement = constraints.current;\n    heyListen.invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n    this.constraintsBox = getBoundingBox(constraintsElement, transformPagePoint);\n    var measuredConstraints = calcViewportConstraints(layoutBox, this.constraintsBox);\n    /**\n     * If there's an onMeasureDragConstraints listener we call it and\n     * if different constraints are returned, set constraints to that\n     */\n    if (onMeasureDragConstraints) {\n      var userConstraints = onMeasureDragConstraints(convertAxisBoxToBoundingBox(measuredConstraints));\n      this.hasMutatedConstraints = !!userConstraints;\n      if (userConstraints) {\n        measuredConstraints = convertBoundingBoxToAxisBox(userConstraints);\n      }\n    }\n    return measuredConstraints;\n  };\n  VisualElementDragControls.prototype.cancelDrag = function () {\n    var _a, _b;\n    this.visualElement.unlockProjectionTarget();\n    (_a = this.cancelLayout) === null || _a === void 0 ? void 0 : _a.call(this);\n    this.isDragging = false;\n    this.panSession && this.panSession.end();\n    this.panSession = null;\n    if (!this.props.dragPropagation && this.openGlobalLock) {\n      this.openGlobalLock();\n      this.openGlobalLock = null;\n    }\n    (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(AnimationType.Drag, false);\n  };\n  VisualElementDragControls.prototype.stop = function (event, info) {\n    var _a, _b, _c;\n    (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\n    this.panSession = null;\n    var isDragging = this.isDragging;\n    this.cancelDrag();\n    if (!isDragging) return;\n    var velocity = info.velocity;\n    this.animateDragEnd(velocity);\n    (_c = (_b = this.props).onDragEnd) === null || _c === void 0 ? void 0 : _c.call(_b, event, info);\n  };\n  VisualElementDragControls.prototype.snapToCursor = function (point) {\n    var _this = this;\n    return eachAxis(function (axis) {\n      var drag = _this.props.drag;\n      // If we're not dragging this axis, do an early return.\n      if (!shouldDrag(axis, drag, _this.currentDirection)) return;\n      var axisValue = _this.getAxisMotionValue(axis);\n      if (axisValue) {\n        var box = _this.visualElement.getLayoutState().layout;\n        var length_1 = box[axis].max - box[axis].min;\n        var center = box[axis].min + length_1 / 2;\n        var offset = point[axis] - center;\n        _this.originPoint[axis] = point[axis];\n        axisValue.set(offset);\n      } else {\n        _this.cursorProgress[axis] = 0.5;\n        return true;\n      }\n    }).includes(true);\n  };\n  /**\n   * Update the specified axis with the latest pointer information.\n   */\n  VisualElementDragControls.prototype.updateAxis = function (axis, point, offset) {\n    var drag = this.props.drag;\n    // If we're not dragging this axis, do an early return.\n    if (!shouldDrag(axis, drag, this.currentDirection)) return;\n    return this.getAxisMotionValue(axis) ? this.updateAxisMotionValue(axis, offset) : this.updateVisualElementAxis(axis, point);\n  };\n  VisualElementDragControls.prototype.updateAxisMotionValue = function (axis, offset) {\n    var axisValue = this.getAxisMotionValue(axis);\n    if (!offset || !axisValue) return;\n    var nextValue = this.originPoint[axis] + offset[axis];\n    var update = this.constraints ? applyConstraints(nextValue, this.constraints[axis], this.elastic[axis]) : nextValue;\n    axisValue.set(update);\n  };\n  VisualElementDragControls.prototype.updateVisualElementAxis = function (axis, point) {\n    var _a;\n    // Get the actual layout bounding box of the element\n    var axisLayout = this.visualElement.getLayoutState().layout[axis];\n    // Calculate its current length. In the future we might want to lerp this to animate\n    // between lengths if the layout changes as we change the DOM\n    var axisLength = axisLayout.max - axisLayout.min;\n    // Get the initial progress that the pointer sat on this axis on gesture start.\n    var axisProgress = this.cursorProgress[axis];\n    // Calculate a new min point based on the latest pointer position, constraints and elastic\n    var min = calcConstrainedMinPoint(point[axis], axisLength, axisProgress, (_a = this.constraints) === null || _a === void 0 ? void 0 : _a[axis], this.elastic[axis]);\n    // Update the axis viewport target with this new min and the length\n    this.visualElement.setProjectionTargetAxis(axis, min, min + axisLength);\n  };\n  VisualElementDragControls.prototype.setProps = function (_a) {\n    var _b = _a.drag,\n      drag = _b === void 0 ? false : _b,\n      _c = _a.dragDirectionLock,\n      dragDirectionLock = _c === void 0 ? false : _c,\n      _d = _a.dragPropagation,\n      dragPropagation = _d === void 0 ? false : _d,\n      _e = _a.dragConstraints,\n      dragConstraints = _e === void 0 ? false : _e,\n      _f = _a.dragElastic,\n      dragElastic = _f === void 0 ? defaultElastic : _f,\n      _g = _a.dragMomentum,\n      dragMomentum = _g === void 0 ? true : _g,\n      remainingProps = tslib.__rest(_a, [\"drag\", \"dragDirectionLock\", \"dragPropagation\", \"dragConstraints\", \"dragElastic\", \"dragMomentum\"]);\n    this.props = tslib.__assign({\n      drag: drag,\n      dragDirectionLock: dragDirectionLock,\n      dragPropagation: dragPropagation,\n      dragConstraints: dragConstraints,\n      dragElastic: dragElastic,\n      dragMomentum: dragMomentum\n    }, remainingProps);\n  };\n  /**\n   * Drag works differently depending on which props are provided.\n   *\n   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n   * - If the component will perform layout animations, we output the gesture to the component's\n   *      visual bounding box\n   * - Otherwise, we apply the delta to the x/y motion values.\n   */\n  VisualElementDragControls.prototype.getAxisMotionValue = function (axis) {\n    var _a = this.props,\n      layout = _a.layout,\n      layoutId = _a.layoutId;\n    var dragKey = \"_drag\" + axis.toUpperCase();\n    if (this.props[dragKey]) {\n      return this.props[dragKey];\n    } else if (!layout && layoutId === undefined) {\n      return this.visualElement.getValue(axis, 0);\n    }\n  };\n  VisualElementDragControls.prototype.isLayoutDrag = function () {\n    return !this.getAxisMotionValue(\"x\");\n  };\n  VisualElementDragControls.prototype.isExternalDrag = function () {\n    var _a = this.props,\n      _dragX = _a._dragX,\n      _dragY = _a._dragY;\n    return _dragX || _dragY;\n  };\n  VisualElementDragControls.prototype.animateDragEnd = function (velocity) {\n    var _this = this;\n    var _a = this.props,\n      drag = _a.drag,\n      dragMomentum = _a.dragMomentum,\n      dragElastic = _a.dragElastic,\n      dragTransition = _a.dragTransition;\n    /**\n     * Everything beyond the drag gesture should be performed with\n     * relative projection so children stay in sync with their parent element.\n     */\n    var isRelative = convertToRelativeProjection(this.visualElement, this.isLayoutDrag() && !this.isExternalDrag());\n    /**\n     * If we had previously resolved constraints relative to the viewport,\n     * we need to also convert those to a relative coordinate space for the animation\n     */\n    var constraints = this.constraints || {};\n    if (isRelative && Object.keys(constraints).length && this.isLayoutDrag()) {\n      var projectionParent = this.visualElement.getProjectionParent();\n      if (projectionParent) {\n        var relativeConstraints_1 = calcRelativeOffset(projectionParent.projection.targetFinal, constraints);\n        eachAxis(function (axis) {\n          var _a = relativeConstraints_1[axis],\n            min = _a.min,\n            max = _a.max;\n          constraints[axis] = {\n            min: isNaN(min) ? undefined : min,\n            max: isNaN(max) ? undefined : max\n          };\n        });\n      }\n    }\n    var momentumAnimations = eachAxis(function (axis) {\n      var _a;\n      if (!shouldDrag(axis, drag, _this.currentDirection)) {\n        return;\n      }\n      var transition = (_a = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a !== void 0 ? _a : {};\n      /**\n       * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n       * of spring animations so we should look into adding a disable spring option to `inertia`.\n       * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n       * using the value of `dragElastic`.\n       */\n      var bounceStiffness = dragElastic ? 200 : 1000000;\n      var bounceDamping = dragElastic ? 40 : 10000000;\n      var inertia = tslib.__assign(tslib.__assign({\n        type: \"inertia\",\n        velocity: dragMomentum ? velocity[axis] : 0,\n        bounceStiffness: bounceStiffness,\n        bounceDamping: bounceDamping,\n        timeConstant: 750,\n        restDelta: 1,\n        restSpeed: 10\n      }, dragTransition), transition);\n      // If we're not animating on an externally-provided `MotionValue` we can use the\n      // component's animation controls which will handle interactions with whileHover (etc),\n      // otherwise we just have to animate the `MotionValue` itself.\n      return _this.getAxisMotionValue(axis) ? _this.startAxisValueAnimation(axis, inertia) : _this.visualElement.startLayoutAnimation(axis, inertia, isRelative);\n    });\n    // Run all animations and then resolve the new drag constraints.\n    return Promise.all(momentumAnimations).then(function () {\n      var _a, _b;\n      (_b = (_a = _this.props).onDragTransitionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);\n    });\n  };\n  VisualElementDragControls.prototype.stopMotion = function () {\n    var _this = this;\n    eachAxis(function (axis) {\n      var axisValue = _this.getAxisMotionValue(axis);\n      axisValue ? axisValue.stop() : _this.visualElement.stopLayoutAnimation();\n    });\n  };\n  VisualElementDragControls.prototype.startAxisValueAnimation = function (axis, transition) {\n    var axisValue = this.getAxisMotionValue(axis);\n    if (!axisValue) return;\n    var currentValue = axisValue.get();\n    axisValue.set(currentValue);\n    axisValue.set(currentValue); // Set twice to hard-reset velocity\n    return startAnimation(axis, axisValue, 0, transition);\n  };\n  VisualElementDragControls.prototype.scalePoint = function () {\n    var _this = this;\n    var _a = this.props,\n      drag = _a.drag,\n      dragConstraints = _a.dragConstraints;\n    if (!isRefObject(dragConstraints) || !this.constraintsBox) return;\n    // Stop any current animations as there can be some visual glitching if we resize mid animation\n    this.stopMotion();\n    // Record the relative progress of the targetBox relative to the constraintsBox\n    var boxProgress = {\n      x: 0,\n      y: 0\n    };\n    eachAxis(function (axis) {\n      boxProgress[axis] = calcOrigin(_this.visualElement.projection.target[axis], _this.constraintsBox[axis]);\n    });\n    /**\n     * For each axis, calculate the current progress of the layout axis within the constraints.\n     * Then, using the latest layout and constraints measurements, reposition the new layout axis\n     * proportionally within the constraints.\n     */\n    this.updateConstraints(function () {\n      eachAxis(function (axis) {\n        if (!shouldDrag(axis, drag, null)) return;\n        // Calculate the position of the targetBox relative to the constraintsBox using the\n        // previously calculated progress\n        var _a = calcPositionFromProgress(_this.visualElement.projection.target[axis], _this.constraintsBox[axis], boxProgress[axis]),\n          min = _a.min,\n          max = _a.max;\n        _this.visualElement.setProjectionTargetAxis(axis, min, max);\n      });\n    });\n    /**\n     * If any other draggable components are queuing the same tasks synchronously\n     * this will wait until they've all been scheduled before flushing.\n     */\n    setTimeout(flushLayout, 1);\n  };\n  VisualElementDragControls.prototype.updateConstraints = function (onReady) {\n    var _this = this;\n    this.cancelLayout = batchLayout(function (read, write) {\n      var ancestors = collectProjectingAncestors(_this.visualElement);\n      write(function () {\n        return ancestors.forEach(function (element) {\n          return element.resetTransform();\n        });\n      });\n      read(function () {\n        return updateLayoutMeasurement(_this.visualElement);\n      });\n      write(function () {\n        return ancestors.forEach(function (element) {\n          return element.restoreTransform();\n        });\n      });\n      read(function () {\n        _this.resolveDragConstraints();\n      });\n      if (onReady) write(onReady);\n    });\n  };\n  VisualElementDragControls.prototype.mount = function (visualElement) {\n    var _this = this;\n    var element = visualElement.getInstance();\n    /**\n     * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n     */\n    var stopPointerListener = addPointerEvent(element, \"pointerdown\", function (event) {\n      var _a = _this.props,\n        drag = _a.drag,\n        _b = _a.dragListener,\n        dragListener = _b === void 0 ? true : _b;\n      drag && dragListener && _this.start(event);\n    });\n    /**\n     * Attach a window resize listener to scale the draggable target within its defined\n     * constraints as the window resizes.\n     */\n    var stopResizeListener = addDomEvent(window, \"resize\", function () {\n      _this.scalePoint();\n    });\n    /**\n     * Ensure drag constraints are resolved correctly relative to the dragging element\n     * whenever its layout changes.\n     */\n    var stopLayoutUpdateListener = visualElement.onLayoutUpdate(function () {\n      if (_this.isDragging) {\n        _this.resolveDragConstraints();\n      }\n    });\n    /**\n     * If the previous component with this same layoutId was dragging at the time\n     * it was unmounted, we want to continue the same gesture on this component.\n     */\n    var prevDragCursor = visualElement.prevDragCursor;\n    if (prevDragCursor) {\n      this.start(lastPointerEvent, {\n        cursorProgress: prevDragCursor\n      });\n    }\n    /**\n     * Return a function that will teardown the drag gesture\n     */\n    return function () {\n      stopPointerListener === null || stopPointerListener === void 0 ? void 0 : stopPointerListener();\n      stopResizeListener === null || stopResizeListener === void 0 ? void 0 : stopResizeListener();\n      stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();\n      _this.cancelDrag();\n    };\n  };\n  return VisualElementDragControls;\n}();\nfunction shouldDrag(direction, drag, currentDirection) {\n  return (drag === true || drag === direction) && (currentDirection === null || currentDirection === direction);\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\nfunction getCurrentDirection(offset, lockThreshold) {\n  if (lockThreshold === void 0) {\n    lockThreshold = 10;\n  }\n  var direction = null;\n  if (Math.abs(offset.y) > lockThreshold) {\n    direction = \"y\";\n  } else if (Math.abs(offset.x) > lockThreshold) {\n    direction = \"x\";\n  }\n  return direction;\n}\n\n/**\n * A hook that allows an element to be dragged.\n *\n * @internal\n */\nfunction useDrag(props) {\n  var groupDragControls = props.dragControls,\n    visualElement = props.visualElement;\n  var transformPagePoint = React.useContext(MotionConfigContext).transformPagePoint;\n  var dragControls = useConstant(function () {\n    return new VisualElementDragControls({\n      visualElement: visualElement\n    });\n  });\n  dragControls.setProps(tslib.__assign(tslib.__assign({}, props), {\n    transformPagePoint: transformPagePoint\n  }));\n  // If we've been provided a DragControls for manual control over the drag gesture,\n  // subscribe this component to it on mount.\n  React.useEffect(function () {\n    return groupDragControls && groupDragControls.subscribe(dragControls);\n  }, [dragControls]);\n  // Mount the drag controls with the visualElement\n  React.useEffect(function () {\n    return dragControls.mount(visualElement);\n  }, []);\n}\n\n/**\n *\n * @param handlers -\n * @param ref -\n *\n * @internalremarks\n * Currently this sets new pan gesture functions every render. The memo route has been explored\n * in the past but ultimately we're still creating new functions every render. An optimisation\n * to explore is creating the pan gestures and loading them into a `ref`.\n *\n * @internal\n */\nfunction usePanGesture(_a) {\n  var onPan = _a.onPan,\n    onPanStart = _a.onPanStart,\n    onPanEnd = _a.onPanEnd,\n    onPanSessionStart = _a.onPanSessionStart,\n    visualElement = _a.visualElement;\n  var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\n  var panSession = React.useRef(null);\n  var transformPagePoint = React.useContext(MotionConfigContext).transformPagePoint;\n  var handlers = {\n    onSessionStart: onPanSessionStart,\n    onStart: onPanStart,\n    onMove: onPan,\n    onEnd: function (event, info) {\n      panSession.current = null;\n      onPanEnd && onPanEnd(event, info);\n    }\n  };\n  React.useEffect(function () {\n    if (panSession.current !== null) {\n      panSession.current.updateHandlers(handlers);\n    }\n  });\n  function onPointerDown(event) {\n    panSession.current = new PanSession(event, handlers, {\n      transformPagePoint: transformPagePoint\n    });\n  }\n  usePointerEvent(visualElement, \"pointerdown\", hasPanEvents && onPointerDown);\n  useUnmountEffect(function () {\n    return panSession.current && panSession.current.end();\n  });\n}\nvar drag = {\n  pan: makeRenderlessComponent(usePanGesture),\n  drag: makeRenderlessComponent(useDrag)\n};\n\n/**\n * @public\n */\nvar Presence;\n(function (Presence) {\n  Presence[Presence[\"Entering\"] = 0] = \"Entering\";\n  Presence[Presence[\"Present\"] = 1] = \"Present\";\n  Presence[Presence[\"Exiting\"] = 2] = \"Exiting\";\n})(Presence || (Presence = {}));\n/**\n * @public\n */\nexports.VisibilityAction = void 0;\n(function (VisibilityAction) {\n  VisibilityAction[VisibilityAction[\"Hide\"] = 0] = \"Hide\";\n  VisibilityAction[VisibilityAction[\"Show\"] = 1] = \"Show\";\n})(exports.VisibilityAction || (exports.VisibilityAction = {}));\nfunction isCSSVariable(value) {\n  return typeof value === \"string\" && value.startsWith(\"var(--\");\n}\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction parseCSSVariable(current) {\n  var match = cssVariableRegex.exec(current);\n  if (!match) return [,];\n  var _a = tslib.__read(match, 3),\n    token = _a[1],\n    fallback = _a[2];\n  return [token, fallback];\n}\nvar maxDepth = 4;\nfunction getVariableValue(current, element, depth) {\n  if (depth === void 0) {\n    depth = 1;\n  }\n  heyListen.invariant(depth <= maxDepth, \"Max CSS variable fallback depth detected in property \\\"\" + current + \"\\\". This may indicate a circular fallback dependency.\");\n  var _a = tslib.__read(parseCSSVariable(current), 2),\n    token = _a[0],\n    fallback = _a[1];\n  // No CSS variable detected\n  if (!token) return;\n  // Attempt to read this CSS variable off the element\n  var resolved = window.getComputedStyle(element).getPropertyValue(token);\n  if (resolved) {\n    return resolved.trim();\n  } else if (isCSSVariable(fallback)) {\n    // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n    return getVariableValue(fallback, element, depth + 1);\n  } else {\n    return fallback;\n  }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\nfunction resolveCSSVariables(visualElement, _a, transitionEnd) {\n  var _b;\n  var target = tslib.__rest(_a, []);\n  var element = visualElement.getInstance();\n  if (!(element instanceof HTMLElement)) return {\n    target: target,\n    transitionEnd: transitionEnd\n  };\n  // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n  // only if they change but I think this reads clearer and this isn't a performance-critical path.\n  if (transitionEnd) {\n    transitionEnd = tslib.__assign({}, transitionEnd);\n  }\n  // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n  visualElement.forEachValue(function (value) {\n    var current = value.get();\n    if (!isCSSVariable(current)) return;\n    var resolved = getVariableValue(current, element);\n    if (resolved) value.set(resolved);\n  });\n  // Cycle through every target property and resolve CSS variables. Currently\n  // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n  for (var key in target) {\n    var current = target[key];\n    if (!isCSSVariable(current)) continue;\n    var resolved = getVariableValue(current, element);\n    if (!resolved) continue;\n    // Clone target if it hasn't already been\n    target[key] = resolved;\n    // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n    // CSS variable. This will ensure that after the animation the component will reflect\n    // changes in the value of the CSS variable.\n    if (transitionEnd) (_b = transitionEnd[key]) !== null && _b !== void 0 ? _b : transitionEnd[key] = current;\n  }\n  return {\n    target: target,\n    transitionEnd: transitionEnd\n  };\n}\nfunction pixelsToPercent(pixels, axis) {\n  return pixels / (axis.max - axis.min) * 100;\n}\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\n */\nfunction correctBorderRadius(latest, _layoutState, _a) {\n  var target = _a.target;\n  /**\n   * If latest is a string, if it's a percentage we can return immediately as it's\n   * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\n   */\n  if (typeof latest === \"string\") {\n    if (styleValueTypes.px.test(latest)) {\n      latest = parseFloat(latest);\n    } else {\n      return latest;\n    }\n  }\n  /**\n   * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\n   * pixel value as a percentage of each axis\n   */\n  var x = pixelsToPercent(latest, target.x);\n  var y = pixelsToPercent(latest, target.y);\n  return x + \"% \" + y + \"%\";\n}\nvar varToken = \"_$css\";\nfunction correctBoxShadow(latest, _a) {\n  var delta = _a.delta,\n    treeScale = _a.treeScale;\n  var original = latest;\n  /**\n   * We need to first strip and store CSS variables from the string.\n   */\n  var containsCSSVariables = latest.includes(\"var(\");\n  var cssVariables = [];\n  if (containsCSSVariables) {\n    latest = latest.replace(cssVariableRegex, function (match) {\n      cssVariables.push(match);\n      return varToken;\n    });\n  }\n  var shadow = styleValueTypes.complex.parse(latest);\n  // TODO: Doesn't support multiple shadows\n  if (shadow.length > 5) return original;\n  var template = styleValueTypes.complex.createTransformer(latest);\n  var offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n  // Calculate the overall context scale\n  var xScale = delta.x.scale * treeScale.x;\n  var yScale = delta.y.scale * treeScale.y;\n  shadow[0 + offset] /= xScale;\n  shadow[1 + offset] /= yScale;\n  /**\n   * Ideally we'd correct x and y scales individually, but because blur and\n   * spread apply to both we have to take a scale average and apply that instead.\n   * We could potentially improve the outcome of this by incorporating the ratio between\n   * the two scales.\n   */\n  var averageScale = popmotion.mix(xScale, yScale, 0.5);\n  // Blur\n  if (typeof shadow[2 + offset] === \"number\") shadow[2 + offset] /= averageScale;\n  // Spread\n  if (typeof shadow[3 + offset] === \"number\") shadow[3 + offset] /= averageScale;\n  var output = template(shadow);\n  if (containsCSSVariables) {\n    var i_1 = 0;\n    output = output.replace(varToken, function () {\n      var cssVariable = cssVariables[i_1];\n      i_1++;\n      return cssVariable;\n    });\n  }\n  return output;\n}\nvar borderCorrectionDefinition = {\n  process: correctBorderRadius\n};\nvar defaultScaleCorrectors = {\n  borderRadius: tslib.__assign(tslib.__assign({}, borderCorrectionDefinition), {\n    applyTo: [\"borderTopLeftRadius\", \"borderTopRightRadius\", \"borderBottomLeftRadius\", \"borderBottomRightRadius\"]\n  }),\n  borderTopLeftRadius: borderCorrectionDefinition,\n  borderTopRightRadius: borderCorrectionDefinition,\n  borderBottomLeftRadius: borderCorrectionDefinition,\n  borderBottomRightRadius: borderCorrectionDefinition,\n  boxShadow: {\n    process: correctBoxShadow\n  }\n};\nvar progressTarget = 1000;\nvar Animate = /** @class */function (_super) {\n  tslib.__extends(Animate, _super);\n  function Animate() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * A mutable object that tracks the target viewport box\n     * for the current animation frame.\n     */\n    _this.frameTarget = axisBox();\n    /**\n     * The current animation target, we use this to check whether to start\n     * a new animation or continue the existing one.\n     */\n    _this.currentAnimationTarget = axisBox();\n    /**\n     * Track whether we're animating this axis.\n     */\n    _this.isAnimating = {\n      x: false,\n      y: false\n    };\n    _this.stopAxisAnimation = {\n      x: undefined,\n      y: undefined\n    };\n    _this.isAnimatingTree = false;\n    _this.animate = function (target, origin, _a) {\n      if (_a === void 0) {\n        _a = {};\n      }\n      var originBox = _a.originBox,\n        targetBox = _a.targetBox,\n        visibilityAction = _a.visibilityAction,\n        shouldStackAnimate = _a.shouldStackAnimate,\n        onComplete = _a.onComplete,\n        prevParent = _a.prevParent,\n        config = tslib.__rest(_a, [\"originBox\", \"targetBox\", \"visibilityAction\", \"shouldStackAnimate\", \"onComplete\", \"prevParent\"]);\n      var _b = _this.props,\n        visualElement = _b.visualElement,\n        layout = _b.layout;\n      /**\n       * Early return if we've been instructed not to animate this render.\n       */\n      if (shouldStackAnimate === false) {\n        _this.isAnimatingTree = false;\n        return _this.safeToRemove();\n      }\n      /**\n       * Prioritise tree animations\n       */\n      if (_this.isAnimatingTree && shouldStackAnimate !== true) {\n        return;\n      } else if (shouldStackAnimate) {\n        _this.isAnimatingTree = true;\n      }\n      /**\n       * Allow the measured origin (prev bounding box) and target (actual layout) to be\n       * overridden by the provided config.\n       */\n      origin = originBox || origin;\n      target = targetBox || target;\n      /**\n       * If this element has a projecting parent, there's an opportunity to animate\n       * it relatively to that parent rather than relatively to the viewport. This\n       * allows us to add orchestrated animations.\n       */\n      var isRelative = false;\n      var projectionParent = visualElement.getProjectionParent();\n      if (projectionParent) {\n        var prevParentViewportBox = projectionParent.prevViewportBox;\n        var parentLayout = projectionParent.getLayoutState().layout;\n        /**\n         * If we're being provided a previous parent VisualElement by AnimateSharedLayout\n         */\n        if (prevParent) {\n          /**\n           * If we've been provided an explicit target box it means we're animating back\n           * to this previous parent. So we can make a relative box by comparing to the previous\n           * parent's layout\n           */\n          if (targetBox) {\n            parentLayout = prevParent.getLayoutState().layout;\n          }\n          /**\n           * Likewise if we've been provided an explicit origin box it means we're\n           * animating out from a different element. So we should figure out where that was\n           * on screen relative to the new parent element.\n           */\n          if (originBox && !checkIfParentHasChanged(prevParent, projectionParent) && prevParent.prevViewportBox) {\n            prevParentViewportBox = prevParent.prevViewportBox;\n          }\n        }\n        if (prevParentViewportBox && isProvidedCorrectDataForRelativeSharedLayout(prevParent, originBox, targetBox)) {\n          isRelative = true;\n          origin = calcRelativeOffset(prevParentViewportBox, origin);\n          target = calcRelativeOffset(parentLayout, target);\n        }\n      }\n      var boxHasMoved = hasMoved(origin, target);\n      var animations = eachAxis(function (axis) {\n        var _a, _b;\n        /**\n         * If layout is set to \"position\", we can resize the origin box based on the target\n         * box and only animate its position.\n         */\n        if (layout === \"position\") {\n          var targetLength = target[axis].max - target[axis].min;\n          origin[axis].max = origin[axis].min + targetLength;\n        }\n        if (visualElement.projection.isTargetLocked) {\n          return;\n        } else if (visibilityAction !== undefined) {\n          visualElement.setVisibility(visibilityAction === exports.VisibilityAction.Show);\n        } else if (boxHasMoved) {\n          // If the box has moved, animate between it's current visual state and its\n          // final state\n          return _this.animateAxis(axis, target[axis], origin[axis], tslib.__assign(tslib.__assign({}, config), {\n            isRelative: isRelative\n          }));\n        } else {\n          (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a);\n          // If the box has remained in the same place, immediately set the axis target\n          // to the final desired state\n          return visualElement.setProjectionTargetAxis(axis, target[axis].min, target[axis].max, isRelative);\n        }\n      });\n      // Force a render to ensure there's no flash of uncorrected bounding box.\n      visualElement.syncRender();\n      /**\n       * If this visualElement isn't present (ie it's been removed from the tree by the user but\n       * kept in by the tree by AnimatePresence) then call safeToRemove when all axis animations\n       * have successfully finished.\n       */\n      return Promise.all(animations).then(function () {\n        _this.isAnimatingTree = false;\n        onComplete && onComplete();\n        visualElement.notifyLayoutAnimationComplete();\n      });\n    };\n    return _this;\n  }\n  Animate.prototype.componentDidMount = function () {\n    var _this = this;\n    var visualElement = this.props.visualElement;\n    visualElement.animateMotionValue = startAnimation;\n    visualElement.enableLayoutProjection();\n    this.unsubLayoutReady = visualElement.onLayoutUpdate(this.animate);\n    visualElement.layoutSafeToRemove = function () {\n      return _this.safeToRemove();\n    };\n    addScaleCorrection(defaultScaleCorrectors);\n  };\n  Animate.prototype.componentWillUnmount = function () {\n    var _this = this;\n    this.unsubLayoutReady();\n    eachAxis(function (axis) {\n      var _a, _b;\n      return (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a);\n    });\n  };\n  /**\n   * TODO: This manually performs animations on the visualElement's layout progress\n   * values. It'd be preferable to amend the startLayoutAxisAnimation\n   * API to accept more custom animations like this.\n   */\n  Animate.prototype.animateAxis = function (axis, target, origin, _a) {\n    var _this = this;\n    var _b, _c;\n    var _d = _a === void 0 ? {} : _a,\n      transition = _d.transition,\n      isRelative = _d.isRelative;\n    /**\n     * If we're not animating to a new target, don't run this animation\n     */\n    if (this.isAnimating[axis] && axisIsEqual(target, this.currentAnimationTarget[axis])) {\n      return;\n    }\n    (_c = (_b = this.stopAxisAnimation)[axis]) === null || _c === void 0 ? void 0 : _c.call(_b);\n    this.isAnimating[axis] = true;\n    var visualElement = this.props.visualElement;\n    var frameTarget = this.frameTarget[axis];\n    var layoutProgress = visualElement.getProjectionAnimationProgress()[axis];\n    /**\n     * Set layout progress back to 0. We set it twice to hard-reset any velocity that might\n     * be re-incoporated into a subsequent spring animation.\n     */\n    layoutProgress.clearListeners();\n    layoutProgress.set(0);\n    layoutProgress.set(0);\n    /**\n     * Create an animation function to run once per frame. This will tween the visual bounding box from\n     * origin to target using the latest progress value.\n     */\n    var frame = function () {\n      // Convert the latest layoutProgress, which is a value from 0-1000, into a 0-1 progress\n      var p = layoutProgress.get() / progressTarget;\n      // Tween the axis and update the visualElement with the latest values\n      tweenAxis(frameTarget, origin, target, p);\n      visualElement.setProjectionTargetAxis(axis, frameTarget.min, frameTarget.max, isRelative);\n    };\n    // Synchronously run a frame to ensure there's no flash of the uncorrected bounding box.\n    frame();\n    // Create a function to stop animation on this specific axis\n    var unsubscribeProgress = layoutProgress.onChange(frame);\n    this.stopAxisAnimation[axis] = function () {\n      _this.isAnimating[axis] = false;\n      layoutProgress.stop();\n      unsubscribeProgress();\n    };\n    this.currentAnimationTarget[axis] = target;\n    var layoutTransition = transition || visualElement.getDefaultTransition() || defaultLayoutTransition;\n    // Start the animation on this axis\n    var animation = startAnimation(axis === \"x\" ? \"layoutX\" : \"layoutY\", layoutProgress, progressTarget, layoutTransition && getValueTransition(layoutTransition, \"layout\")).then(this.stopAxisAnimation[axis]);\n    return animation;\n  };\n  Animate.prototype.safeToRemove = function () {\n    var _a, _b;\n    (_b = (_a = this.props).safeToRemove) === null || _b === void 0 ? void 0 : _b.call(_a);\n  };\n  Animate.prototype.render = function () {\n    return null;\n  };\n  return Animate;\n}(React__namespace.Component);\nfunction AnimateLayoutContextProvider(props) {\n  var _a = tslib.__read(usePresence(), 2),\n    safeToRemove = _a[1];\n  return React__namespace.createElement(Animate, tslib.__assign({}, props, {\n    safeToRemove: safeToRemove\n  }));\n}\nfunction hasMoved(a, b) {\n  return !isZeroBox(a) && !isZeroBox(b) && (!axisIsEqual(a.x, b.x) || !axisIsEqual(a.y, b.y));\n}\nvar zeroAxis = {\n  min: 0,\n  max: 0\n};\nfunction isZeroBox(a) {\n  return axisIsEqual(a.x, zeroAxis) && axisIsEqual(a.y, zeroAxis);\n}\nfunction axisIsEqual(a, b) {\n  return a.min === b.min && a.max === b.max;\n}\nvar defaultLayoutTransition = {\n  duration: 0.45,\n  ease: [0.4, 0, 0.1, 1]\n};\nfunction isProvidedCorrectDataForRelativeSharedLayout(prevParent, originBox, targetBox) {\n  return prevParent || !prevParent && !(originBox || targetBox);\n}\n\n/**\n * Default handlers for batching VisualElements\n */\nvar defaultHandler = {\n  layoutReady: function (child) {\n    return child.notifyLayoutReady();\n  }\n};\n/**\n * Create a batcher to process VisualElements\n */\nfunction createBatcher() {\n  var queue = new Set();\n  return {\n    add: function (child) {\n      return queue.add(child);\n    },\n    flush: function (_a) {\n      var _b = _a === void 0 ? defaultHandler : _a,\n        layoutReady = _b.layoutReady,\n        parent = _b.parent;\n      batchLayout(function (read, write) {\n        var order = Array.from(queue).sort(compareByDepth);\n        var ancestors = parent ? collectProjectingAncestors(parent) : [];\n        write(function () {\n          var allElements = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(ancestors)), tslib.__read(order));\n          allElements.forEach(function (element) {\n            return element.resetTransform();\n          });\n        });\n        read(function () {\n          order.forEach(updateLayoutMeasurement);\n        });\n        write(function () {\n          ancestors.forEach(function (element) {\n            return element.restoreTransform();\n          });\n          order.forEach(layoutReady);\n        });\n        read(function () {\n          /**\n           * After all children have started animating, ensure any Entering components are set to Present.\n           * If we add deferred animations (set up all animations and then start them in two loops) this\n           * could be moved to the start loop. But it needs to happen after all the animations configs\n           * are generated in AnimateSharedLayout as this relies on presence data\n           */\n          order.forEach(function (child) {\n            if (child.isPresent) child.presence = Presence.Present;\n          });\n        });\n        write(function () {\n          /**\n           * Starting these animations will have queued jobs on the frame loop. In some situations,\n           * like when removing an element, these will be processed too late after the DOM is manipulated,\n           * leaving a flash of incorrectly-projected content. By manually flushing these jobs\n           * we ensure there's no flash.\n           */\n          sync.flushSync.preRender();\n          sync.flushSync.render();\n        });\n        read(function () {\n          /**\n           * Schedule a callback at the end of the following frame to assign the latest projection\n           * box to the prevViewportBox snapshot. Once global batching is in place this could be run\n           * synchronously. But for now it ensures that if any nested `AnimateSharedLayout` top-level\n           * child attempts to calculate its previous relative position against a prevViewportBox\n           * it will be against its latest projection box instead, as the snapshot is useless beyond this\n           * render.\n           */\n          sync__default['default'].postRender(function () {\n            return order.forEach(assignProjectionToSnapshot);\n          });\n          queue.clear();\n        });\n      });\n      // TODO: Need to find a layout-synchronous way of flushing this\n      flushLayout();\n    }\n  };\n}\nfunction assignProjectionToSnapshot(child) {\n  child.prevViewportBox = child.projection.target;\n}\nvar SharedLayoutContext = React.createContext(createBatcher());\n/**\n * @internal\n */\nvar FramerTreeLayoutContext = React.createContext(createBatcher());\nfunction isSharedLayout(context) {\n  return !!context.forceUpdate;\n}\n\n/**\n * This component is responsible for scheduling the measuring of the motion component\n */\nvar Measure = /** @class */function (_super) {\n  tslib.__extends(Measure, _super);\n  function Measure() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * If this is a child of a SyncContext, register the VisualElement with it on mount.\n   */\n  Measure.prototype.componentDidMount = function () {\n    var _a = this.props,\n      syncLayout = _a.syncLayout,\n      framerSyncLayout = _a.framerSyncLayout,\n      visualElement = _a.visualElement;\n    isSharedLayout(syncLayout) && syncLayout.register(visualElement);\n    isSharedLayout(framerSyncLayout) && framerSyncLayout.register(visualElement);\n    visualElement.onUnmount(function () {\n      if (isSharedLayout(syncLayout)) {\n        syncLayout.remove(visualElement);\n      }\n      if (isSharedLayout(framerSyncLayout)) {\n        framerSyncLayout.remove(visualElement);\n      }\n    });\n  };\n  /**\n   * If this is a child of a SyncContext, notify it that it needs to re-render. It will then\n   * handle the snapshotting.\n   *\n   * If it is stand-alone component, add it to the batcher.\n   */\n  Measure.prototype.getSnapshotBeforeUpdate = function () {\n    var _a = this.props,\n      syncLayout = _a.syncLayout,\n      visualElement = _a.visualElement;\n    if (isSharedLayout(syncLayout)) {\n      syncLayout.syncUpdate();\n    } else {\n      snapshotViewportBox(visualElement);\n      syncLayout.add(visualElement);\n    }\n    return null;\n  };\n  Measure.prototype.componentDidUpdate = function () {\n    var syncLayout = this.props.syncLayout;\n    if (!isSharedLayout(syncLayout)) syncLayout.flush();\n  };\n  Measure.prototype.render = function () {\n    return null;\n  };\n  return Measure;\n}(React__default['default'].Component);\nfunction MeasureContextProvider(props) {\n  var syncLayout = React.useContext(SharedLayoutContext);\n  var framerSyncLayout = React.useContext(FramerTreeLayoutContext);\n  return React__default['default'].createElement(Measure, tslib.__assign({}, props, {\n    syncLayout: syncLayout,\n    framerSyncLayout: framerSyncLayout\n  }));\n}\nvar layoutAnimations = {\n  measureLayout: MeasureContextProvider,\n  layoutAnimation: AnimateLayoutContextProvider\n};\nvar createProjectionState = function () {\n  return {\n    isEnabled: false,\n    isHydrated: false,\n    isTargetLocked: false,\n    target: axisBox(),\n    targetFinal: axisBox()\n  };\n};\nfunction createLayoutState() {\n  return {\n    isHydrated: false,\n    layout: axisBox(),\n    layoutCorrected: axisBox(),\n    treeScale: {\n      x: 1,\n      y: 1\n    },\n    delta: delta(),\n    deltaFinal: delta(),\n    deltaTransform: \"\"\n  };\n}\nvar zeroLayout = createLayoutState();\n\n/**\n * Build a transform style that takes a calculated delta between the element's current\n * space on screen and projects it into the desired space.\n */\nfunction buildLayoutProjectionTransform(_a, treeScale, latestTransform) {\n  var x = _a.x,\n    y = _a.y;\n  /**\n   * The translations we use to calculate are always relative to the viewport coordinate space.\n   * But when we apply scales, we also scale the coordinate space of an element and its children.\n   * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n   * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n   */\n  var xTranslate = x.translate / treeScale.x;\n  var yTranslate = y.translate / treeScale.y;\n  var transform = \"translate3d(\" + xTranslate + \"px, \" + yTranslate + \"px, 0) \";\n  if (latestTransform) {\n    var rotate = latestTransform.rotate,\n      rotateX = latestTransform.rotateX,\n      rotateY = latestTransform.rotateY;\n    if (rotate) transform += \"rotate(\" + rotate + \") \";\n    if (rotateX) transform += \"rotateX(\" + rotateX + \") \";\n    if (rotateY) transform += \"rotateY(\" + rotateY + \") \";\n  }\n  transform += \"scale(\" + x.scale + \", \" + y.scale + \")\";\n  return !latestTransform && transform === identityProjection ? \"\" : transform;\n}\n/**\n * Take the calculated delta origin and apply it as a transform string.\n */\nfunction buildLayoutProjectionTransformOrigin(_a) {\n  var deltaFinal = _a.deltaFinal;\n  return deltaFinal.x.origin * 100 + \"% \" + deltaFinal.y.origin * 100 + \"% 0\";\n}\nvar identityProjection = buildLayoutProjectionTransform(zeroLayout.delta, zeroLayout.treeScale, {\n  x: 1,\n  y: 1\n});\nvar names = [\"LayoutMeasure\", \"BeforeLayoutMeasure\", \"LayoutUpdate\", \"ViewportBoxUpdate\", \"Update\", \"Render\", \"AnimationComplete\", \"LayoutAnimationComplete\", \"AnimationStart\", \"SetAxisTarget\", \"Unmount\"];\nfunction createLifecycles() {\n  var managers = names.map(function () {\n    return new SubscriptionManager();\n  });\n  var propSubscriptions = {};\n  var lifecycles = {\n    clearAllListeners: function () {\n      return managers.forEach(function (manager) {\n        return manager.clear();\n      });\n    },\n    updatePropListeners: function (props) {\n      return names.forEach(function (name) {\n        var _a;\n        (_a = propSubscriptions[name]) === null || _a === void 0 ? void 0 : _a.call(propSubscriptions);\n        var on = \"on\" + name;\n        var propListener = props[on];\n        if (propListener) {\n          propSubscriptions[name] = lifecycles[on](propListener);\n        }\n      });\n    }\n  };\n  managers.forEach(function (manager, i) {\n    lifecycles[\"on\" + names[i]] = function (handler) {\n      return manager.add(handler);\n    };\n    lifecycles[\"notify\" + names[i]] = function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      return manager.notify.apply(manager, tslib.__spreadArray([], tslib.__read(args)));\n    };\n  });\n  return lifecycles;\n}\nfunction updateMotionValuesFromProps(element, next, prev) {\n  var _a;\n  for (var key in next) {\n    var nextValue = next[key];\n    var prevValue = prev[key];\n    if (isMotionValue(nextValue)) {\n      /**\n       * If this is a motion value found in props or style, we want to add it\n       * to our visual element's motion value map.\n       */\n      element.addValue(key, nextValue);\n    } else if (isMotionValue(prevValue)) {\n      /**\n       * If we're swapping to a new motion value, create a new motion value\n       * from that\n       */\n      element.addValue(key, motionValue(nextValue));\n    } else if (prevValue !== nextValue) {\n      /**\n       * If this is a flat value that has changed, update the motion value\n       * or create one if it doesn't exist. We only want to do this if we're\n       * not handling the value with our animation state.\n       */\n      if (element.hasValue(key)) {\n        var existingValue = element.getValue(key);\n        // TODO: Only update values that aren't being animated or even looked at\n        !existingValue.hasAnimated && existingValue.set(nextValue);\n      } else {\n        element.addValue(key, motionValue((_a = element.getStaticValue(key)) !== null && _a !== void 0 ? _a : nextValue));\n      }\n    }\n  }\n  // Handle removed values\n  for (var key in prev) {\n    if (next[key] === undefined) element.removeValue(key);\n  }\n  return next;\n}\nfunction updateLayoutDeltas(_a, _b, treePath, transformOrigin) {\n  var delta = _a.delta,\n    layout = _a.layout,\n    layoutCorrected = _a.layoutCorrected,\n    treeScale = _a.treeScale;\n  var target = _b.target;\n  /**\n   * Reset the corrected box with the latest values from box, as we're then going\n   * to perform mutative operations on it.\n   */\n  resetBox(layoutCorrected, layout);\n  /**\n   * Apply all the parent deltas to this box to produce the corrected box. This\n   * is the layout box, as it will appear on screen as a result of the transforms of its parents.\n   */\n  applyTreeDeltas(layoutCorrected, treeScale, treePath);\n  /**\n   * Update the delta between the corrected box and the target box before user-set transforms were applied.\n   * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\n   * for our layout reprojection, but still allow them to be scaled correctly by the user.\n   * It might be that to simplify this we may want to accept that user-set scale is also corrected\n   * and we wouldn't have to keep and calc both deltas, OR we could support a user setting\n   * to allow people to choose whether these styles are corrected based on just the\n   * layout reprojection or the final bounding box.\n   */\n  updateBoxDelta(delta, layoutCorrected, target, transformOrigin);\n}\nvar FlatTree = /** @class */function () {\n  function FlatTree() {\n    this.children = [];\n    this.isDirty = false;\n  }\n  FlatTree.prototype.add = function (child) {\n    addUniqueItem(this.children, child);\n    this.isDirty = true;\n  };\n  FlatTree.prototype.remove = function (child) {\n    removeItem(this.children, child);\n    this.isDirty = true;\n  };\n  FlatTree.prototype.forEach = function (callback) {\n    this.isDirty && this.children.sort(compareByDepth);\n    this.isDirty = false;\n    this.children.forEach(callback);\n  };\n  return FlatTree;\n}();\nfunction setCurrentViewportBox(visualElement) {\n  var projectionParent = visualElement.getProjectionParent();\n  if (!projectionParent) {\n    visualElement.rebaseProjectionTarget();\n    return;\n  }\n  var relativeOffset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement.getLayoutState().layout);\n  eachAxis(function (axis) {\n    visualElement.setProjectionTargetAxis(axis, relativeOffset[axis].min, relativeOffset[axis].max, true);\n  });\n}\nvar visualElement = function (_a) {\n  var _b = _a.treeType,\n    treeType = _b === void 0 ? \"\" : _b,\n    build = _a.build,\n    getBaseTarget = _a.getBaseTarget,\n    makeTargetAnimatable = _a.makeTargetAnimatable,\n    measureViewportBox = _a.measureViewportBox,\n    renderInstance = _a.render,\n    readValueFromInstance = _a.readValueFromInstance,\n    resetTransform = _a.resetTransform,\n    restoreTransform = _a.restoreTransform,\n    removeValueFromRenderState = _a.removeValueFromRenderState,\n    sortNodePosition = _a.sortNodePosition,\n    scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps;\n  return function (_a, options) {\n    var parent = _a.parent,\n      props = _a.props,\n      presenceId = _a.presenceId,\n      blockInitialAnimation = _a.blockInitialAnimation,\n      visualState = _a.visualState;\n    if (options === void 0) {\n      options = {};\n    }\n    var latestValues = visualState.latestValues,\n      renderState = visualState.renderState;\n    /**\n     * The instance of the render-specific node that will be hydrated by the\n     * exposed React ref. So for example, this visual element can host a\n     * HTMLElement, plain object, or Three.js object. The functions provided\n     * in VisualElementConfig allow us to interface with this instance.\n     */\n    var instance;\n    /**\n     * Manages the subscriptions for a visual element's lifecycle, for instance\n     * onRender and onViewportBoxUpdate.\n     */\n    var lifecycles = createLifecycles();\n    /**\n     *\n     */\n    var projection = createProjectionState();\n    /**\n     * A reference to the nearest projecting parent. This is either\n     * undefined if we haven't looked for the nearest projecting parent,\n     * false if there is no parent performing layout projection, or a reference\n     * to the projecting parent.\n     */\n    var projectionParent;\n    /**\n     * This is a reference to the visual state of the \"lead\" visual element.\n     * Usually, this will be this visual element. But if it shares a layoutId\n     * with other visual elements, only one of them will be designated lead by\n     * AnimateSharedLayout. All the other visual elements will take on the visual\n     * appearance of the lead while they crossfade to it.\n     */\n    var leadProjection = projection;\n    var leadLatestValues = latestValues;\n    var unsubscribeFromLeadVisualElement;\n    /**\n     * The latest layout measurements and calculated projections. This\n     * is seperate from the target projection data in visualState as\n     * many visual elements might point to the same piece of visualState as\n     * a target, whereas they might each have different layouts and thus\n     * projection calculations needed to project into the same viewport box.\n     */\n    var layoutState = createLayoutState();\n    /**\n     *\n     */\n    var crossfader;\n    /**\n     * Keep track of whether the viewport box has been updated since the\n     * last time the layout projection was re-calculated.\n     */\n    var hasViewportBoxUpdated = false;\n    /**\n     * A map of all motion values attached to this visual element. Motion\n     * values are source of truth for any given animated value. A motion\n     * value might be provided externally by the component via props.\n     */\n    var values = new Map();\n    /**\n     * A map of every subscription that binds the provided or generated\n     * motion values onChange listeners to this visual element.\n     */\n    var valueSubscriptions = new Map();\n    /**\n     * A reference to the previously-provided motion values as returned\n     * from scrapeMotionValuesFromProps. We use the keys in here to determine\n     * if any motion values need to be removed after props are updated.\n     */\n    var prevMotionValues = {};\n    /**\n     * x/y motion values that track the progress of initiated layout\n     * animations.\n     *\n     * TODO: Target for removal\n     */\n    var projectionTargetProgress;\n    /**\n     * When values are removed from all animation props we need to search\n     * for a fallback value to animate to. These values are tracked in baseTarget.\n     */\n    var baseTarget = tslib.__assign({}, latestValues);\n    // Internal methods ========================\n    /**\n     * On mount, this will be hydrated with a callback to disconnect\n     * this visual element from its parent on unmount.\n     */\n    var removeFromVariantTree;\n    /**\n     *\n     */\n    function render() {\n      if (!instance) return;\n      if (element.isProjectionReady()) {\n        /**\n         * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\n         * This is the final box that we will then project into by calculating a transform delta and\n         * applying it to the corrected box.\n         */\n        applyBoxTransforms(leadProjection.targetFinal, leadProjection.target, leadLatestValues);\n        /**\n         * Update the delta between the corrected box and the final target box, after\n         * user-set transforms are applied to it. This will be used by the renderer to\n         * create a transform style that will reproject the element from its actual layout\n         * into the desired bounding box.\n         */\n        updateBoxDelta(layoutState.deltaFinal, layoutState.layoutCorrected, leadProjection.targetFinal, latestValues);\n      }\n      triggerBuild();\n      renderInstance(instance, renderState);\n    }\n    function triggerBuild() {\n      var valuesToRender = latestValues;\n      if (crossfader && crossfader.isActive()) {\n        var crossfadedValues = crossfader.getCrossfadeState(element);\n        if (crossfadedValues) valuesToRender = crossfadedValues;\n      }\n      build(element, renderState, valuesToRender, leadProjection, layoutState, options, props);\n    }\n    function update() {\n      lifecycles.notifyUpdate(latestValues);\n    }\n    function updateLayoutProjection() {\n      if (!element.isProjectionReady()) return;\n      var delta = layoutState.delta,\n        treeScale = layoutState.treeScale;\n      var prevTreeScaleX = treeScale.x;\n      var prevTreeScaleY = treeScale.y;\n      var prevDeltaTransform = layoutState.deltaTransform;\n      updateLayoutDeltas(layoutState, leadProjection, element.path, latestValues);\n      hasViewportBoxUpdated && element.notifyViewportBoxUpdate(leadProjection.target, delta);\n      hasViewportBoxUpdated = false;\n      var deltaTransform = buildLayoutProjectionTransform(delta, treeScale);\n      if (deltaTransform !== prevDeltaTransform ||\n      // Also compare calculated treeScale, for values that rely on this only for scale correction\n      prevTreeScaleX !== treeScale.x || prevTreeScaleY !== treeScale.y) {\n        element.scheduleRender();\n      }\n      layoutState.deltaTransform = deltaTransform;\n    }\n    function updateTreeLayoutProjection() {\n      element.layoutTree.forEach(fireUpdateLayoutProjection);\n    }\n    /**\n     *\n     */\n    function bindToMotionValue(key, value) {\n      var removeOnChange = value.onChange(function (latestValue) {\n        latestValues[key] = latestValue;\n        props.onUpdate && sync__default['default'].update(update, false, true);\n      });\n      var removeOnRenderRequest = value.onRenderRequest(element.scheduleRender);\n      valueSubscriptions.set(key, function () {\n        removeOnChange();\n        removeOnRenderRequest();\n      });\n    }\n    /**\n     * Any motion values that are provided to the element when created\n     * aren't yet bound to the element, as this would technically be impure.\n     * However, we iterate through the motion values and set them to the\n     * initial values for this component.\n     *\n     * TODO: This is impure and we should look at changing this to run on mount.\n     * Doing so will break some tests but this isn't neccessarily a breaking change,\n     * more a reflection of the test.\n     */\n    var initialMotionValues = scrapeMotionValuesFromProps(props);\n    for (var key in initialMotionValues) {\n      var value = initialMotionValues[key];\n      if (latestValues[key] !== undefined && isMotionValue(value)) {\n        value.set(latestValues[key], false);\n      }\n    }\n    /**\n     * Determine what role this visual element should take in the variant tree.\n     */\n    var isControllingVariants = checkIfControllingVariants(props);\n    var isVariantNode = checkIfVariantNode(props);\n    var element = tslib.__assign(tslib.__assign({\n      treeType: treeType,\n      /**\n       * This is a mirror of the internal instance prop, which keeps\n       * VisualElement type-compatible with React's RefObject.\n       */\n      current: null,\n      /**\n       * The depth of this visual element within the visual element tree.\n       */\n      depth: parent ? parent.depth + 1 : 0,\n      parent: parent,\n      children: new Set(),\n      /**\n       * An ancestor path back to the root visual element. This is used\n       * by layout projection to quickly recurse back up the tree.\n       */\n      path: parent ? tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(parent.path)), [parent]) : [],\n      layoutTree: parent ? parent.layoutTree : new FlatTree(),\n      /**\n       *\n       */\n      presenceId: presenceId,\n      projection: projection,\n      /**\n       * If this component is part of the variant tree, it should track\n       * any children that are also part of the tree. This is essentially\n       * a shadow tree to simplify logic around how to stagger over children.\n       */\n      variantChildren: isVariantNode ? new Set() : undefined,\n      /**\n       * Whether this instance is visible. This can be changed imperatively\n       * by AnimateSharedLayout, is analogous to CSS's visibility in that\n       * hidden elements should take up layout, and needs enacting by the configured\n       * render function.\n       */\n      isVisible: undefined,\n      /**\n       * Normally, if a component is controlled by a parent's variants, it can\n       * rely on that ancestor to trigger animations further down the tree.\n       * However, if a component is created after its parent is mounted, the parent\n       * won't trigger that mount animation so the child needs to.\n       *\n       * TODO: This might be better replaced with a method isParentMounted\n       */\n      manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()),\n      /**\n       * This can be set by AnimatePresence to force components that mount\n       * at the same time as it to mount as if they have initial={false} set.\n       */\n      blockInitialAnimation: blockInitialAnimation,\n      /**\n       * Determine whether this component has mounted yet. This is mostly used\n       * by variant children to determine whether they need to trigger their\n       * own animations on mount.\n       */\n      isMounted: function () {\n        return Boolean(instance);\n      },\n      mount: function (newInstance) {\n        instance = element.current = newInstance;\n        element.pointTo(element);\n        if (isVariantNode && parent && !isControllingVariants) {\n          removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);\n        }\n        parent === null || parent === void 0 ? void 0 : parent.children.add(element);\n      },\n      /**\n       *\n       */\n      unmount: function () {\n        sync.cancelSync.update(update);\n        sync.cancelSync.render(render);\n        sync.cancelSync.preRender(element.updateLayoutProjection);\n        valueSubscriptions.forEach(function (remove) {\n          return remove();\n        });\n        element.stopLayoutAnimation();\n        element.layoutTree.remove(element);\n        removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();\n        parent === null || parent === void 0 ? void 0 : parent.children.delete(element);\n        unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\n        lifecycles.clearAllListeners();\n      },\n      /**\n       * Add a child visual element to our set of children.\n       */\n      addVariantChild: function (child) {\n        var _a;\n        var closestVariantNode = element.getClosestVariantNode();\n        if (closestVariantNode) {\n          (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);\n          return function () {\n            return closestVariantNode.variantChildren.delete(child);\n          };\n        }\n      },\n      sortNodePosition: function (other) {\n        /**\n         * If these nodes aren't even of the same type we can't compare their depth.\n         */\n        if (!sortNodePosition || treeType !== other.treeType) return 0;\n        return sortNodePosition(element.getInstance(), other.getInstance());\n      },\n      /**\n       * Returns the closest variant node in the tree starting from\n       * this visual element.\n       */\n      getClosestVariantNode: function () {\n        return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();\n      },\n      /**\n       * A method that schedules an update to layout projections throughout\n       * the tree. We inherit from the parent so there's only ever one\n       * job scheduled on the next frame - that of the root visual element.\n       */\n      scheduleUpdateLayoutProjection: parent ? parent.scheduleUpdateLayoutProjection : function () {\n        return sync__default['default'].preRender(element.updateTreeLayoutProjection, false, true);\n      },\n      /**\n       * Expose the latest layoutId prop.\n       */\n      getLayoutId: function () {\n        return props.layoutId;\n      },\n      /**\n       * Returns the current instance.\n       */\n      getInstance: function () {\n        return instance;\n      },\n      /**\n       * Get/set the latest static values.\n       */\n      getStaticValue: function (key) {\n        return latestValues[key];\n      },\n      setStaticValue: function (key, value) {\n        return latestValues[key] = value;\n      },\n      /**\n       * Returns the latest motion value state. Currently only used to take\n       * a snapshot of the visual element - perhaps this can return the whole\n       * visual state\n       */\n      getLatestValues: function () {\n        return latestValues;\n      },\n      /**\n       * Set the visiblity of the visual element. If it's changed, schedule\n       * a render to reflect these changes.\n       */\n      setVisibility: function (visibility) {\n        if (element.isVisible === visibility) return;\n        element.isVisible = visibility;\n        element.scheduleRender();\n      },\n      /**\n       * Make a target animatable by Popmotion. For instance, if we're\n       * trying to animate width from 100px to 100vw we need to measure 100vw\n       * in pixels to determine what we really need to animate to. This is also\n       * pluggable to support Framer's custom value types like Color,\n       * and CSS variables.\n       */\n      makeTargetAnimatable: function (target, canMutate) {\n        if (canMutate === void 0) {\n          canMutate = true;\n        }\n        return makeTargetAnimatable(element, target, props, canMutate);\n      },\n      // Motion values ========================\n      /**\n       * Add a motion value and bind it to this visual element.\n       */\n      addValue: function (key, value) {\n        // Remove existing value if it exists\n        if (element.hasValue(key)) element.removeValue(key);\n        values.set(key, value);\n        latestValues[key] = value.get();\n        bindToMotionValue(key, value);\n      },\n      /**\n       * Remove a motion value and unbind any active subscriptions.\n       */\n      removeValue: function (key) {\n        var _a;\n        values.delete(key);\n        (_a = valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();\n        valueSubscriptions.delete(key);\n        delete latestValues[key];\n        removeValueFromRenderState(key, renderState);\n      },\n      /**\n       * Check whether we have a motion value for this key\n       */\n      hasValue: function (key) {\n        return values.has(key);\n      },\n      /**\n       * Get a motion value for this key. If called with a default\n       * value, we'll create one if none exists.\n       */\n      getValue: function (key, defaultValue) {\n        var value = values.get(key);\n        if (value === undefined && defaultValue !== undefined) {\n          value = motionValue(defaultValue);\n          element.addValue(key, value);\n        }\n        return value;\n      },\n      /**\n       * Iterate over our motion values.\n       */\n      forEachValue: function (callback) {\n        return values.forEach(callback);\n      },\n      /**\n       * If we're trying to animate to a previously unencountered value,\n       * we need to check for it in our state and as a last resort read it\n       * directly from the instance (which might have performance implications).\n       */\n      readValue: function (key) {\n        var _a;\n        return (_a = latestValues[key]) !== null && _a !== void 0 ? _a : readValueFromInstance(instance, key, options);\n      },\n      /**\n       * Set the base target to later animate back to. This is currently\n       * only hydrated on creation and when we first read a value.\n       */\n      setBaseTarget: function (key, value) {\n        baseTarget[key] = value;\n      },\n      /**\n       * Find the base target for a value thats been removed from all animation\n       * props.\n       */\n      getBaseTarget: function (key) {\n        if (getBaseTarget) {\n          var target = getBaseTarget(props, key);\n          if (target !== undefined && !isMotionValue(target)) return target;\n        }\n        return baseTarget[key];\n      }\n    }, lifecycles), {\n      /**\n       * Build the renderer state based on the latest visual state.\n       */\n      build: function () {\n        triggerBuild();\n        return renderState;\n      },\n      /**\n       * Schedule a render on the next animation frame.\n       */\n      scheduleRender: function () {\n        sync__default['default'].render(render, false, true);\n      },\n      /**\n       * Synchronously fire render. It's prefered that we batch renders but\n       * in many circumstances, like layout measurement, we need to run this\n       * synchronously. However in those instances other measures should be taken\n       * to batch reads/writes.\n       */\n      syncRender: render,\n      /**\n       * Update the provided props. Ensure any newly-added motion values are\n       * added to our map, old ones removed, and listeners updated.\n       */\n      setProps: function (newProps) {\n        props = newProps;\n        lifecycles.updatePropListeners(newProps);\n        prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps(props), prevMotionValues);\n      },\n      getProps: function () {\n        return props;\n      },\n      // Variants ==============================\n      /**\n       * Returns the variant definition with a given name.\n       */\n      getVariant: function (name) {\n        var _a;\n        return (_a = props.variants) === null || _a === void 0 ? void 0 : _a[name];\n      },\n      /**\n       * Returns the defined default transition on this component.\n       */\n      getDefaultTransition: function () {\n        return props.transition;\n      },\n      /**\n       * Used by child variant nodes to get the closest ancestor variant props.\n       */\n      getVariantContext: function (startAtParent) {\n        if (startAtParent === void 0) {\n          startAtParent = false;\n        }\n        if (startAtParent) return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();\n        if (!isControllingVariants) {\n          var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};\n          if (props.initial !== undefined) {\n            context_1.initial = props.initial;\n          }\n          return context_1;\n        }\n        var context = {};\n        for (var i = 0; i < numVariantProps; i++) {\n          var name_1 = variantProps[i];\n          var prop = props[name_1];\n          if (isVariantLabel(prop) || prop === false) {\n            context[name_1] = prop;\n          }\n        }\n        return context;\n      },\n      // Layout projection ==============================\n      /**\n       * Enable layout projection for this visual element. Won't actually\n       * occur until we also have hydrated layout measurements.\n       */\n      enableLayoutProjection: function () {\n        projection.isEnabled = true;\n        element.layoutTree.add(element);\n      },\n      /**\n       * Lock the projection target, for instance when dragging, so\n       * nothing else can try and animate it.\n       */\n      lockProjectionTarget: function () {\n        projection.isTargetLocked = true;\n      },\n      unlockProjectionTarget: function () {\n        element.stopLayoutAnimation();\n        projection.isTargetLocked = false;\n      },\n      getLayoutState: function () {\n        return layoutState;\n      },\n      setCrossfader: function (newCrossfader) {\n        crossfader = newCrossfader;\n      },\n      isProjectionReady: function () {\n        return projection.isEnabled && projection.isHydrated && layoutState.isHydrated;\n      },\n      /**\n       * Start a layout animation on a given axis.\n       */\n      startLayoutAnimation: function (axis, transition, isRelative) {\n        if (isRelative === void 0) {\n          isRelative = false;\n        }\n        var progress = element.getProjectionAnimationProgress()[axis];\n        var _a = isRelative ? projection.relativeTarget[axis] : projection.target[axis],\n          min = _a.min,\n          max = _a.max;\n        var length = max - min;\n        progress.clearListeners();\n        progress.set(min);\n        progress.set(min); // Set twice to hard-reset velocity\n        progress.onChange(function (v) {\n          element.setProjectionTargetAxis(axis, v, v + length, isRelative);\n        });\n        return element.animateMotionValue(axis, progress, 0, transition);\n      },\n      /**\n       * Stop layout animations.\n       */\n      stopLayoutAnimation: function () {\n        eachAxis(function (axis) {\n          return element.getProjectionAnimationProgress()[axis].stop();\n        });\n      },\n      /**\n       * Measure the current viewport box with or without transforms.\n       * Only measures axis-aligned boxes, rotate and skew must be manually\n       * removed with a re-render to work.\n       */\n      measureViewportBox: function (withTransform) {\n        if (withTransform === void 0) {\n          withTransform = true;\n        }\n        var viewportBox = measureViewportBox(instance, options);\n        if (!withTransform) removeBoxTransforms(viewportBox, latestValues);\n        return viewportBox;\n      },\n      /**\n       * Get the motion values tracking the layout animations on each\n       * axis. Lazy init if not already created.\n       */\n      getProjectionAnimationProgress: function () {\n        projectionTargetProgress || (projectionTargetProgress = {\n          x: motionValue(0),\n          y: motionValue(0)\n        });\n        return projectionTargetProgress;\n      },\n      /**\n       * Update the projection of a single axis. Schedule an update to\n       * the tree layout projection.\n       */\n      setProjectionTargetAxis: function (axis, min, max, isRelative) {\n        if (isRelative === void 0) {\n          isRelative = false;\n        }\n        var target;\n        if (isRelative) {\n          if (!projection.relativeTarget) {\n            projection.relativeTarget = axisBox();\n          }\n          target = projection.relativeTarget[axis];\n        } else {\n          projection.relativeTarget = undefined;\n          target = projection.target[axis];\n        }\n        projection.isHydrated = true;\n        target.min = min;\n        target.max = max;\n        // Flag that we want to fire the onViewportBoxUpdate event handler\n        hasViewportBoxUpdated = true;\n        lifecycles.notifySetAxisTarget();\n      },\n      /**\n       * Rebase the projection target on top of the provided viewport box\n       * or the measured layout. This ensures that non-animating elements\n       * don't fall out of sync differences in measurements vs projections\n       * after a page scroll or other relayout.\n       */\n      rebaseProjectionTarget: function (force, box) {\n        if (box === void 0) {\n          box = layoutState.layout;\n        }\n        var _a = element.getProjectionAnimationProgress(),\n          x = _a.x,\n          y = _a.y;\n        var shouldRebase = !projection.relativeTarget && !projection.isTargetLocked && !x.isAnimating() && !y.isAnimating();\n        if (force || shouldRebase) {\n          eachAxis(function (axis) {\n            var _a = box[axis],\n              min = _a.min,\n              max = _a.max;\n            element.setProjectionTargetAxis(axis, min, max);\n          });\n        }\n      },\n      /**\n       * Notify the visual element that its layout is up-to-date.\n       * Currently Animate.tsx uses this to check whether a layout animation\n       * needs to be performed.\n       */\n      notifyLayoutReady: function (config) {\n        setCurrentViewportBox(element);\n        element.notifyLayoutUpdate(layoutState.layout, element.prevViewportBox || layoutState.layout, config);\n      },\n      /**\n       * Temporarily reset the transform of the instance.\n       */\n      resetTransform: function () {\n        return resetTransform(element, instance, props);\n      },\n      restoreTransform: function () {\n        return restoreTransform(instance, renderState);\n      },\n      updateLayoutProjection: updateLayoutProjection,\n      updateTreeLayoutProjection: function () {\n        element.layoutTree.forEach(fireResolveRelativeTargetBox);\n        /**\n         * Schedule the projection updates at the end of the current preRender\n         * step. This will ensure that all layout trees will first resolve\n         * relative projection boxes into viewport boxes, and *then*\n         * update projections.\n         */\n        sync__default['default'].preRender(updateTreeLayoutProjection, false, true);\n        // sync.postRender(() => element.scheduleUpdateLayoutProjection())\n      },\n\n      getProjectionParent: function () {\n        if (projectionParent === undefined) {\n          var foundParent = false;\n          // Search backwards through the tree path\n          for (var i = element.path.length - 1; i >= 0; i--) {\n            var ancestor = element.path[i];\n            if (ancestor.projection.isEnabled) {\n              foundParent = ancestor;\n              break;\n            }\n          }\n          projectionParent = foundParent;\n        }\n        return projectionParent;\n      },\n      resolveRelativeTargetBox: function () {\n        var relativeParent = element.getProjectionParent();\n        if (!projection.relativeTarget || !relativeParent) return;\n        calcRelativeBox(projection, relativeParent.projection);\n        if (isDraggable(relativeParent)) {\n          var target = projection.target;\n          applyBoxTransforms(target, target, relativeParent.getLatestValues());\n        }\n      },\n      shouldResetTransform: function () {\n        return Boolean(props._layoutResetTransform);\n      },\n      /**\n       *\n       */\n      pointTo: function (newLead) {\n        leadProjection = newLead.projection;\n        leadLatestValues = newLead.getLatestValues();\n        /**\n         * Subscribe to lead component's layout animations\n         */\n        unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\n        unsubscribeFromLeadVisualElement = popmotion.pipe(newLead.onSetAxisTarget(element.scheduleUpdateLayoutProjection), newLead.onLayoutAnimationComplete(function () {\n          var _a;\n          if (element.isPresent) {\n            element.presence = Presence.Present;\n          } else {\n            (_a = element.layoutSafeToRemove) === null || _a === void 0 ? void 0 : _a.call(element);\n          }\n        }));\n      },\n      // TODO: Clean this up\n      isPresent: true,\n      presence: Presence.Entering\n    });\n    return element;\n  };\n};\nfunction fireResolveRelativeTargetBox(child) {\n  child.resolveRelativeTargetBox();\n}\nfunction fireUpdateLayoutProjection(child) {\n  child.updateLayoutProjection();\n}\nvar variantProps = tslib.__spreadArray([\"initial\"], tslib.__read(variantPriorityOrder));\nvar numVariantProps = variantProps.length;\nvar positionalKeys = new Set([\"width\", \"height\", \"top\", \"left\", \"right\", \"bottom\", \"x\", \"y\"]);\nvar isPositionalKey = function (key) {\n  return positionalKeys.has(key);\n};\nvar hasPositionalKey = function (target) {\n  return Object.keys(target).some(isPositionalKey);\n};\nvar setAndResetVelocity = function (value, to) {\n  // Looks odd but setting it twice doesn't render, it'll just\n  // set both prev and current to the latest value\n  value.set(to, false);\n  value.set(to);\n};\nvar isNumOrPxType = function (v) {\n  return v === styleValueTypes.number || v === styleValueTypes.px;\n};\nvar BoundingBoxDimension;\n(function (BoundingBoxDimension) {\n  BoundingBoxDimension[\"width\"] = \"width\";\n  BoundingBoxDimension[\"height\"] = \"height\";\n  BoundingBoxDimension[\"left\"] = \"left\";\n  BoundingBoxDimension[\"right\"] = \"right\";\n  BoundingBoxDimension[\"top\"] = \"top\";\n  BoundingBoxDimension[\"bottom\"] = \"bottom\";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\nvar getPosFromMatrix = function (matrix, pos) {\n  return parseFloat(matrix.split(\", \")[pos]);\n};\nvar getTranslateFromMatrix = function (pos2, pos3) {\n  return function (_bbox, _a) {\n    var transform = _a.transform;\n    if (transform === \"none\" || !transform) return 0;\n    var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n    if (matrix3d) {\n      return getPosFromMatrix(matrix3d[1], pos3);\n    } else {\n      var matrix = transform.match(/^matrix\\((.+)\\)$/);\n      if (matrix) {\n        return getPosFromMatrix(matrix[1], pos2);\n      } else {\n        return 0;\n      }\n    }\n  };\n};\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\nvar nonTranslationalTransformKeys = transformProps.filter(function (key) {\n  return !transformKeys.has(key);\n});\nfunction removeNonTranslationalTransform(visualElement) {\n  var removedTransforms = [];\n  nonTranslationalTransformKeys.forEach(function (key) {\n    var value = visualElement.getValue(key);\n    if (value !== undefined) {\n      removedTransforms.push([key, value.get()]);\n      value.set(key.startsWith(\"scale\") ? 1 : 0);\n    }\n  });\n  // Apply changes to element before measurement\n  if (removedTransforms.length) visualElement.syncRender();\n  return removedTransforms;\n}\nvar positionalValues = {\n  // Dimensions\n  width: function (_a) {\n    var x = _a.x;\n    return x.max - x.min;\n  },\n  height: function (_a) {\n    var y = _a.y;\n    return y.max - y.min;\n  },\n  top: function (_bbox, _a) {\n    var top = _a.top;\n    return parseFloat(top);\n  },\n  left: function (_bbox, _a) {\n    var left = _a.left;\n    return parseFloat(left);\n  },\n  bottom: function (_a, _b) {\n    var y = _a.y;\n    var top = _b.top;\n    return parseFloat(top) + (y.max - y.min);\n  },\n  right: function (_a, _b) {\n    var x = _a.x;\n    var left = _b.left;\n    return parseFloat(left) + (x.max - x.min);\n  },\n  // Transform\n  x: getTranslateFromMatrix(4, 13),\n  y: getTranslateFromMatrix(5, 14)\n};\nvar convertChangedValueTypes = function (target, visualElement, changedKeys) {\n  var originBbox = visualElement.measureViewportBox();\n  var element = visualElement.getInstance();\n  var elementComputedStyle = getComputedStyle(element);\n  var display = elementComputedStyle.display,\n    top = elementComputedStyle.top,\n    left = elementComputedStyle.left,\n    bottom = elementComputedStyle.bottom,\n    right = elementComputedStyle.right,\n    transform = elementComputedStyle.transform;\n  var originComputedStyle = {\n    top: top,\n    left: left,\n    bottom: bottom,\n    right: right,\n    transform: transform\n  };\n  // If the element is currently set to display: \"none\", make it visible before\n  // measuring the target bounding box\n  if (display === \"none\") {\n    visualElement.setStaticValue(\"display\", target.display || \"block\");\n  }\n  // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n  visualElement.syncRender();\n  var targetBbox = visualElement.measureViewportBox();\n  changedKeys.forEach(function (key) {\n    // Restore styles to their **calculated computed style**, not their actual\n    // originally set style. This allows us to animate between equivalent pixel units.\n    var value = visualElement.getValue(key);\n    setAndResetVelocity(value, positionalValues[key](originBbox, originComputedStyle));\n    target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n  });\n  return target;\n};\nvar checkAndConvertChangedValueTypes = function (visualElement, target, origin, transitionEnd) {\n  if (origin === void 0) {\n    origin = {};\n  }\n  if (transitionEnd === void 0) {\n    transitionEnd = {};\n  }\n  target = tslib.__assign({}, target);\n  transitionEnd = tslib.__assign({}, transitionEnd);\n  var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\n  // We want to remove any transform values that could affect the element's bounding box before\n  // it's measured. We'll reapply these later.\n  var removedTransformValues = [];\n  var hasAttemptedToRemoveTransformValues = false;\n  var changedValueTypeKeys = [];\n  targetPositionalKeys.forEach(function (key) {\n    var value = visualElement.getValue(key);\n    if (!visualElement.hasValue(key)) return;\n    var from = origin[key];\n    var to = target[key];\n    var fromType = findDimensionValueType(from);\n    var toType;\n    // TODO: The current implementation of this basically throws an error\n    // if you try and do value conversion via keyframes. There's probably\n    // a way of doing this but the performance implications would need greater scrutiny,\n    // as it'd be doing multiple resize-remeasure operations.\n    if (isKeyframesTarget(to)) {\n      var numKeyframes = to.length;\n      for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {\n        if (!toType) {\n          toType = findDimensionValueType(to[i]);\n          heyListen.invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), \"Keyframes must be of the same dimension as the current value\");\n        } else {\n          heyListen.invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n        }\n      }\n    } else {\n      toType = findDimensionValueType(to);\n    }\n    if (fromType !== toType) {\n      // If they're both just number or px, convert them both to numbers rather than\n      // relying on resize/remeasure to convert (which is wasteful in this situation)\n      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n        var current = value.get();\n        if (typeof current === \"string\") {\n          value.set(parseFloat(current));\n        }\n        if (typeof to === \"string\") {\n          target[key] = parseFloat(to);\n        } else if (Array.isArray(to) && toType === styleValueTypes.px) {\n          target[key] = to.map(parseFloat);\n        }\n      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {\n        // If one or the other value is 0, it's safe to coerce it to the\n        // type of the other without measurement\n        if (from === 0) {\n          value.set(toType.transform(from));\n        } else {\n          target[key] = fromType.transform(to);\n        }\n      } else {\n        // If we're going to do value conversion via DOM measurements, we first\n        // need to remove non-positional transform values that could affect the bbox measurements.\n        if (!hasAttemptedToRemoveTransformValues) {\n          removedTransformValues = removeNonTranslationalTransform(visualElement);\n          hasAttemptedToRemoveTransformValues = true;\n        }\n        changedValueTypeKeys.push(key);\n        transitionEnd[key] = transitionEnd[key] !== undefined ? transitionEnd[key] : target[key];\n        setAndResetVelocity(value, to);\n      }\n    }\n  });\n  if (changedValueTypeKeys.length) {\n    var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\n    // If we removed transform values, reapply them before the next render\n    if (removedTransformValues.length) {\n      removedTransformValues.forEach(function (_a) {\n        var _b = tslib.__read(_a, 2),\n          key = _b[0],\n          value = _b[1];\n        visualElement.getValue(key).set(value);\n      });\n    }\n    // Reapply original values\n    visualElement.syncRender();\n    return {\n      target: convertedTarget,\n      transitionEnd: transitionEnd\n    };\n  } else {\n    return {\n      target: target,\n      transitionEnd: transitionEnd\n    };\n  }\n};\n/**\n * Convert value types for x/y/width/height/top/left/bottom/right\n *\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\n *\n * @internal\n */\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : {\n    target: target,\n    transitionEnd: transitionEnd\n  };\n}\n\n/**\n * Parse a DOM variant to make it animatable. This involves resolving CSS variables\n * and ensuring animations like \"20%\" => \"calc(50vw)\" are performed in pixels.\n */\nvar parseDomVariant = function (visualElement, target, origin, transitionEnd) {\n  var resolved = resolveCSSVariables(visualElement, target, transitionEnd);\n  target = resolved.target;\n  transitionEnd = resolved.transitionEnd;\n  return unitConversion(visualElement, target, origin, transitionEnd);\n};\nfunction getComputedStyle$1(element) {\n  return window.getComputedStyle(element);\n}\nvar htmlConfig = {\n  treeType: \"dom\",\n  readValueFromInstance: function (domElement, key) {\n    if (isTransformProp(key)) {\n      var defaultType = getDefaultValueType(key);\n      return defaultType ? defaultType.default || 0 : 0;\n    } else {\n      var computedStyle = getComputedStyle$1(domElement);\n      return (isCSSVariable$1(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;\n    }\n  },\n  sortNodePosition: function (a, b) {\n    /**\n     * compareDocumentPosition returns a bitmask, by using the bitwise &\n     * we're returning true if 2 in that bitmask is set to true. 2 is set\n     * to true if b preceeds a.\n     */\n    return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n  },\n  getBaseTarget: function (props, key) {\n    var _a;\n    return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\n  },\n  measureViewportBox: function (element, _a) {\n    var transformPagePoint = _a.transformPagePoint;\n    return getBoundingBox(element, transformPagePoint);\n  },\n  /**\n   * Reset the transform on the current Element. This is called as part\n   * of a batched process across the entire layout tree. To remove this write\n   * cycle it'd be interesting to see if it's possible to \"undo\" all the current\n   * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\n   * works\n   */\n  resetTransform: function (element, domElement, props) {\n    var transformTemplate = props.transformTemplate;\n    domElement.style.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\";\n    // Ensure that whatever happens next, we restore our transform on the next frame\n    element.scheduleRender();\n  },\n  restoreTransform: function (instance, mutableState) {\n    instance.style.transform = mutableState.style.transform;\n  },\n  removeValueFromRenderState: function (key, _a) {\n    var vars = _a.vars,\n      style = _a.style;\n    delete vars[key];\n    delete style[key];\n  },\n  /**\n   * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`\n   * can be animated by Motion.\n   */\n  makeTargetAnimatable: function (element, _a, _b, isMounted) {\n    var transformValues = _b.transformValues;\n    if (isMounted === void 0) {\n      isMounted = true;\n    }\n    var transition = _a.transition,\n      transitionEnd = _a.transitionEnd,\n      target = tslib.__rest(_a, [\"transition\", \"transitionEnd\"]);\n    var origin = getOrigin(target, transition || {}, element);\n    /**\n     * If Framer has provided a function to convert `Color` etc value types, convert them\n     */\n    if (transformValues) {\n      if (transitionEnd) transitionEnd = transformValues(transitionEnd);\n      if (target) target = transformValues(target);\n      if (origin) origin = transformValues(origin);\n    }\n    if (isMounted) {\n      checkTargetForNewValues(element, target, origin);\n      var parsed = parseDomVariant(element, target, origin, transitionEnd);\n      transitionEnd = parsed.transitionEnd;\n      target = parsed.target;\n    }\n    return tslib.__assign({\n      transition: transition,\n      transitionEnd: transitionEnd\n    }, target);\n  },\n  scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,\n  build: function (element, renderState, latestValues, projection, layoutState, options, props) {\n    if (element.isVisible !== undefined) {\n      renderState.style.visibility = element.isVisible ? \"visible\" : \"hidden\";\n    }\n    var isProjectionTranform = projection.isEnabled && layoutState.isHydrated;\n    buildHTMLStyles(renderState, latestValues, projection, layoutState, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : undefined, isProjectionTranform ? buildLayoutProjectionTransformOrigin : undefined);\n  },\n  render: renderHTML\n};\nvar htmlVisualElement = visualElement(htmlConfig);\nvar svgVisualElement = visualElement(tslib.__assign(tslib.__assign({}, htmlConfig), {\n  getBaseTarget: function (props, key) {\n    return props[key];\n  },\n  readValueFromInstance: function (domElement, key) {\n    var _a;\n    if (isTransformProp(key)) {\n      return ((_a = getDefaultValueType(key)) === null || _a === void 0 ? void 0 : _a.default) || 0;\n    }\n    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n    return domElement.getAttribute(key);\n  },\n  scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n  build: function (_element, renderState, latestValues, projection, layoutState, options, props) {\n    var isProjectionTranform = projection.isEnabled && layoutState.isHydrated;\n    buildSVGAttrs(renderState, latestValues, projection, layoutState, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : undefined, isProjectionTranform ? buildLayoutProjectionTransformOrigin : undefined);\n  },\n  render: renderSVG\n}));\nvar createDomVisualElement = function (Component, options) {\n  return isSVGComponent(Component) ? svgVisualElement(options, {\n    enableHardwareAcceleration: false\n  }) : htmlVisualElement(options, {\n    enableHardwareAcceleration: true\n  });\n};\nvar featureBundle = tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({}, animations), gestureAnimations), drag), layoutAnimations);\n/**\n * HTML & SVG components, optimised for use with gestures and animation. These can be used as\n * drop-in replacements for any HTML & SVG component, all CSS & SVG properties are supported.\n *\n * @public\n */\nvar motion = /*@__PURE__*/createMotionProxy(function (Component, config) {\n  return createDomMotionConfig(Component, config, featureBundle, createDomVisualElement);\n});\n/**\n * Create a DOM `motion` component with the provided string. This is primarily intended\n * as a full alternative to `motion` for consumers who have to support environments that don't\n * support `Proxy`.\n *\n * ```javascript\n * import { createDomMotionComponent } from \"framer-motion\"\n *\n * const motion = {\n *   div: createDomMotionComponent('div')\n * }\n * ```\n *\n * @public\n */\nfunction createDomMotionComponent(key) {\n  return createMotionComponent(createDomMotionConfig(key, {\n    forwardMotionProps: false\n  }, featureBundle, createDomVisualElement));\n}\n\n/**\n * @public\n */\nvar m = createMotionProxy(createDomMotionConfig);\nfunction useForceUpdate() {\n  var unloadingRef = React.useRef(false);\n  var _a = tslib.__read(React.useState(0), 2),\n    forcedRenderCount = _a[0],\n    setForcedRenderCount = _a[1];\n  useUnmountEffect(function () {\n    return unloadingRef.current = true;\n  });\n  return React.useCallback(function () {\n    !unloadingRef.current && setForcedRenderCount(forcedRenderCount + 1);\n  }, [forcedRenderCount]);\n}\nvar presenceId = 0;\nfunction getPresenceId() {\n  var id = presenceId;\n  presenceId++;\n  return id;\n}\nvar PresenceChild = function (_a) {\n  var children = _a.children,\n    initial = _a.initial,\n    isPresent = _a.isPresent,\n    onExitComplete = _a.onExitComplete,\n    custom = _a.custom,\n    presenceAffectsLayout = _a.presenceAffectsLayout;\n  var presenceChildren = useConstant(newChildrenMap);\n  var id = useConstant(getPresenceId);\n  var context = React.useMemo(function () {\n    return {\n      id: id,\n      initial: initial,\n      isPresent: isPresent,\n      custom: custom,\n      onExitComplete: function (childId) {\n        presenceChildren.set(childId, true);\n        var allComplete = true;\n        presenceChildren.forEach(function (isComplete) {\n          if (!isComplete) allComplete = false;\n        });\n        allComplete && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n      },\n      register: function (childId) {\n        presenceChildren.set(childId, false);\n        return function () {\n          return presenceChildren.delete(childId);\n        };\n      }\n    };\n  },\n  /**\n   * If the presence of a child affects the layout of the components around it,\n   * we want to make a new context value to ensure they get re-rendered\n   * so they can detect that layout change.\n   */\n  presenceAffectsLayout ? undefined : [isPresent]);\n  React.useMemo(function () {\n    presenceChildren.forEach(function (_, key) {\n      return presenceChildren.set(key, false);\n    });\n  }, [isPresent]);\n  /**\n   * If there's no `motion` components to fire exit animations, we want to remove this\n   * component immediately.\n   */\n  React__namespace.useEffect(function () {\n    !isPresent && !presenceChildren.size && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n  }, [isPresent]);\n  return React__namespace.createElement(PresenceContext.Provider, {\n    value: context\n  }, children);\n};\nfunction newChildrenMap() {\n  return new Map();\n}\nfunction getChildKey(child) {\n  return child.key || \"\";\n}\nfunction updateChildLookup(children, allChildren) {\n  var seenChildren = process.env.NODE_ENV !== \"production\" ? new Set() : null;\n  children.forEach(function (child) {\n    var key = getChildKey(child);\n    if (process.env.NODE_ENV !== \"production\" && seenChildren) {\n      if (seenChildren.has(key)) {\n        console.warn(\"Children of AnimatePresence require unique keys. \\\"\" + key + \"\\\" is a duplicate.\");\n      }\n      seenChildren.add(key);\n    }\n    allChildren.set(key, child);\n  });\n}\nfunction onlyElements(children) {\n  var filtered = [];\n  // We use forEach here instead of map as map mutates the component key by preprending `.$`\n  React.Children.forEach(children, function (child) {\n    if (React.isValidElement(child)) filtered.push(child);\n  });\n  return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * @library\n *\n * Any `Frame` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { Frame, AnimatePresence } from 'framer'\n *\n * // As items are added and removed from `items`\n * export function Items({ items }) {\n *   return (\n *     <AnimatePresence>\n *       {items.map(item => (\n *         <Frame\n *           key={item.id}\n *           initial={{ opacity: 0 }}\n *           animate={{ opacity: 1 }}\n *           exit={{ opacity: 0 }}\n *         />\n *       ))}\n *     </AnimatePresence>\n *   )\n * }\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * @motion\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nvar AnimatePresence = function (_a) {\n  var children = _a.children,\n    custom = _a.custom,\n    _b = _a.initial,\n    initial = _b === void 0 ? true : _b,\n    onExitComplete = _a.onExitComplete,\n    exitBeforeEnter = _a.exitBeforeEnter,\n    _c = _a.presenceAffectsLayout,\n    presenceAffectsLayout = _c === void 0 ? true : _c;\n  // We want to force a re-render once all exiting animations have finished. We\n  // either use a local forceRender function, or one from a parent context if it exists.\n  var forceRender = useForceUpdate();\n  var layoutContext = React.useContext(SharedLayoutContext);\n  if (isSharedLayout(layoutContext)) {\n    forceRender = layoutContext.forceUpdate;\n  }\n  var isInitialRender = React.useRef(true);\n  // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n  var filteredChildren = onlyElements(children);\n  // Keep a living record of the children we're actually rendering so we\n  // can diff to figure out which are entering and exiting\n  var presentChildren = React.useRef(filteredChildren);\n  // A lookup table to quickly reference components by key\n  var allChildren = React.useRef(new Map()).current;\n  // A living record of all currently exiting components.\n  var exiting = React.useRef(new Set()).current;\n  updateChildLookup(filteredChildren, allChildren);\n  // If this is the initial component render, just deal with logic surrounding whether\n  // we play onMount animations or not.\n  if (isInitialRender.current) {\n    isInitialRender.current = false;\n    return React__namespace.createElement(React__namespace.Fragment, null, filteredChildren.map(function (child) {\n      return React__namespace.createElement(PresenceChild, {\n        key: getChildKey(child),\n        isPresent: true,\n        initial: initial ? undefined : false,\n        presenceAffectsLayout: presenceAffectsLayout\n      }, child);\n    }));\n  }\n  // If this is a subsequent render, deal with entering and exiting children\n  var childrenToRender = tslib.__spreadArray([], tslib.__read(filteredChildren));\n  // Diff the keys of the currently-present and target children to update our\n  // exiting list.\n  var presentKeys = presentChildren.current.map(getChildKey);\n  var targetKeys = filteredChildren.map(getChildKey);\n  // Diff the present children with our target children and mark those that are exiting\n  var numPresent = presentKeys.length;\n  for (var i = 0; i < numPresent; i++) {\n    var key = presentKeys[i];\n    if (targetKeys.indexOf(key) === -1) {\n      exiting.add(key);\n    } else {\n      // In case this key has re-entered, remove from the exiting list\n      exiting.delete(key);\n    }\n  }\n  // If we currently have exiting children, and we're deferring rendering incoming children\n  // until after all current children have exiting, empty the childrenToRender array\n  if (exitBeforeEnter && exiting.size) {\n    childrenToRender = [];\n  }\n  // Loop through all currently exiting components and clone them to overwrite `animate`\n  // with any `exit` prop they might have defined.\n  exiting.forEach(function (key) {\n    // If this component is actually entering again, early return\n    if (targetKeys.indexOf(key) !== -1) return;\n    var child = allChildren.get(key);\n    if (!child) return;\n    var insertionIndex = presentKeys.indexOf(key);\n    var onExit = function () {\n      allChildren.delete(key);\n      exiting.delete(key);\n      // Remove this child from the present children\n      var removeIndex = presentChildren.current.findIndex(function (presentChild) {\n        return presentChild.key === key;\n      });\n      presentChildren.current.splice(removeIndex, 1);\n      // Defer re-rendering until all exiting children have indeed left\n      if (!exiting.size) {\n        presentChildren.current = filteredChildren;\n        forceRender();\n        onExitComplete && onExitComplete();\n      }\n    };\n    childrenToRender.splice(insertionIndex, 0, React__namespace.createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: false,\n      onExitComplete: onExit,\n      custom: custom,\n      presenceAffectsLayout: presenceAffectsLayout\n    }, child));\n  });\n  // Add `MotionContext` even to children that don't need it to ensure we're rendering\n  // the same tree between renders\n  childrenToRender = childrenToRender.map(function (child) {\n    var key = child.key;\n    return exiting.has(key) ? child : React__namespace.createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: true,\n      presenceAffectsLayout: presenceAffectsLayout\n    }, child);\n  });\n  presentChildren.current = childrenToRender;\n  if (process.env.NODE_ENV !== \"production\" && exitBeforeEnter && childrenToRender.length > 1) {\n    console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n  }\n  return React__namespace.createElement(React__namespace.Fragment, null, exiting.size ? childrenToRender : childrenToRender.map(function (child) {\n    return React.cloneElement(child);\n  }));\n};\n\n/**\n * Animate a single value or a `MotionValue`.\n *\n * The first argument is either a `MotionValue` to animate, or an initial animation value.\n *\n * The second is either a value to animate to, or an array of keyframes to animate through.\n *\n * The third argument can be either tween or spring options, and optional lifecycle methods: `onUpdate`, `onPlay`, `onComplete`, `onRepeat` and `onStop`.\n *\n * Returns `AnimationPlaybackControls`, currently just a `stop` method.\n *\n * ```javascript\n * const x = useMotionValue(0)\n *\n * useEffect(() => {\n *   const controls = animate(x, 100, {\n *     type: \"spring\",\n *     stiffness: 2000,\n *     onComplete: v => {}\n *   })\n *\n *   return controls.stop\n * })\n * ```\n *\n * @public\n */\nfunction animate(from, to, transition) {\n  if (transition === void 0) {\n    transition = {};\n  }\n  var value = isMotionValue(from) ? from : motionValue(from);\n  startAnimation(\"\", value, to, transition);\n  return {\n    stop: function () {\n      return value.stop();\n    }\n  };\n}\nfunction createCrossfader() {\n  /**\n   * The current state of the crossfade as a value between 0 and 1\n   */\n  var progress = motionValue(1);\n  var options = {\n    lead: undefined,\n    follow: undefined,\n    crossfadeOpacity: false,\n    preserveFollowOpacity: false\n  };\n  var prevOptions = tslib.__assign({}, options);\n  var leadState = {};\n  var followState = {};\n  /**\n   *\n   */\n  var isActive = false;\n  /**\n   *\n   */\n  var finalCrossfadeFrame = null;\n  /**\n   * Framestamp of the last frame we updated values at.\n   */\n  var prevUpdate = 0;\n  function startCrossfadeAnimation(target, transition) {\n    var lead = options.lead,\n      follow = options.follow;\n    isActive = true;\n    finalCrossfadeFrame = null;\n    var hasUpdated = false;\n    var onUpdate = function () {\n      hasUpdated = true;\n      lead && lead.scheduleRender();\n      follow && follow.scheduleRender();\n    };\n    var onComplete = function () {\n      isActive = false;\n      /**\n       * If the crossfade animation is no longer active, flag a frame\n       * that we're still allowed to crossfade\n       */\n      finalCrossfadeFrame = sync.getFrameData().timestamp;\n    };\n    transition = transition && getValueTransition(transition, \"crossfade\");\n    return animate(progress, target, tslib.__assign(tslib.__assign({}, transition), {\n      onUpdate: onUpdate,\n      onComplete: function () {\n        if (!hasUpdated) {\n          progress.set(target);\n          /**\n           * If we never ran an update, for instance if this was an instant transition, fire a\n           * simulated final frame to ensure the crossfade gets applied correctly.\n           */\n          sync__default['default'].read(onComplete);\n        } else {\n          onComplete();\n        }\n        onUpdate();\n      }\n    }));\n  }\n  function updateCrossfade() {\n    var _a, _b;\n    /**\n     * We only want to compute the crossfade once per frame, so we\n     * compare the previous update framestamp with the current frame\n     * and early return if they're the same.\n     */\n    var timestamp = sync.getFrameData().timestamp;\n    var lead = options.lead,\n      follow = options.follow;\n    if (timestamp === prevUpdate || !lead) return;\n    prevUpdate = timestamp;\n    /**\n     * Merge each component's latest values into our crossfaded state\n     * before crossfading.\n     */\n    var latestLeadValues = lead.getLatestValues();\n    Object.assign(leadState, latestLeadValues);\n    var latestFollowValues = follow ? follow.getLatestValues() : options.prevValues;\n    Object.assign(followState, latestFollowValues);\n    var p = progress.get();\n    /**\n     * Crossfade the opacity between the two components. This will result\n     * in a different opacity for each component.\n     */\n    var leadTargetOpacity = (_a = latestLeadValues.opacity) !== null && _a !== void 0 ? _a : 1;\n    var followTargetOpacity = (_b = latestFollowValues === null || latestFollowValues === void 0 ? void 0 : latestFollowValues.opacity) !== null && _b !== void 0 ? _b : 1;\n    if (options.crossfadeOpacity && follow) {\n      leadState.opacity = popmotion.mix(\n      /**\n       * If the follow child has been completely hidden we animate\n       * this opacity from its previous opacity, but otherwise from completely transparent.\n       */\n      follow.isVisible !== false ? 0 : followTargetOpacity, leadTargetOpacity, easeCrossfadeIn(p));\n      followState.opacity = options.preserveFollowOpacity ? followTargetOpacity : popmotion.mix(followTargetOpacity, 0, easeCrossfadeOut(p));\n    } else if (!follow) {\n      leadState.opacity = popmotion.mix(followTargetOpacity, leadTargetOpacity, p);\n    }\n    mixValues(leadState, followState, latestLeadValues, latestFollowValues || {}, Boolean(follow), p);\n  }\n  return {\n    isActive: function () {\n      return leadState && (isActive || sync.getFrameData().timestamp === finalCrossfadeFrame);\n    },\n    fromLead: function (transition) {\n      return startCrossfadeAnimation(0, transition);\n    },\n    toLead: function (transition) {\n      var initialProgress = 0;\n      if (!options.prevValues && !options.follow) {\n        /**\n         * If we're not coming from anywhere, start at the end of the animation.\n         */\n        initialProgress = 1;\n      } else if (prevOptions.lead === options.follow && prevOptions.follow === options.lead) {\n        /**\n         * If we're swapping follow/lead we can reverse the progress\n         */\n        initialProgress = 1 - progress.get();\n      }\n      progress.set(initialProgress);\n      return startCrossfadeAnimation(1, transition);\n    },\n    reset: function () {\n      return progress.set(1);\n    },\n    stop: function () {\n      return progress.stop();\n    },\n    getCrossfadeState: function (element) {\n      updateCrossfade();\n      if (element === options.lead) {\n        return leadState;\n      } else if (element === options.follow) {\n        return followState;\n      }\n    },\n    setOptions: function (newOptions) {\n      prevOptions = options;\n      options = newOptions;\n      leadState = {};\n      followState = {};\n    },\n    getLatestValues: function () {\n      return leadState;\n    }\n  };\n}\nvar easeCrossfadeIn = compress(0, 0.5, popmotion.circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, popmotion.linear);\nfunction compress(min, max, easing) {\n  return function (p) {\n    // Could replace ifs with clamp\n    if (p < min) return 0;\n    if (p > max) return 1;\n    return easing(popmotion.progress(min, max, p));\n  };\n}\nvar borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nvar numBorders = borders.length;\nfunction mixValues(leadState, followState, latestLeadValues, latestFollowValues, hasFollowElement, p) {\n  /**\n   * Mix border radius\n   */\n  for (var i = 0; i < numBorders; i++) {\n    var borderLabel = \"border\" + borders[i] + \"Radius\";\n    var followRadius = getRadius(latestFollowValues, borderLabel);\n    var leadRadius = getRadius(latestLeadValues, borderLabel);\n    if (followRadius === undefined && leadRadius === undefined) continue;\n    followRadius || (followRadius = 0);\n    leadRadius || (leadRadius = 0);\n    /**\n     * Currently we're only crossfading between numerical border radius.\n     * It would be possible to crossfade between percentages for a little\n     * extra bundle size.\n     */\n    if (typeof followRadius === \"number\" && typeof leadRadius === \"number\") {\n      var radius = Math.max(popmotion.mix(followRadius, leadRadius, p), 0);\n      leadState[borderLabel] = followState[borderLabel] = radius;\n    }\n  }\n  /**\n   * Mix rotation\n   */\n  if (latestFollowValues.rotate || latestLeadValues.rotate) {\n    var rotate = popmotion.mix(latestFollowValues.rotate || 0, latestLeadValues.rotate || 0, p);\n    leadState.rotate = followState.rotate = rotate;\n  }\n  /**\n   * We only want to mix the background color if there's a follow element\n   * that we're not crossfading opacity between. For instance with switch\n   * AnimateSharedLayout animations, this helps the illusion of a continuous\n   * element being animated but also cuts down on the number of paints triggered\n   * for elements where opacity is doing that work for us.\n   */\n  if (!hasFollowElement && latestLeadValues.backgroundColor && latestFollowValues.backgroundColor) {\n    /**\n     * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n     * We could probably create a mixer that runs at the start of the animation but\n     * the idea behind the crossfader is that it runs dynamically between two potentially\n     * changing targets (ie opacity or borderRadius may be animating independently via variants)\n     */\n    leadState.backgroundColor = followState.backgroundColor = popmotion.mixColor(latestFollowValues.backgroundColor, latestLeadValues.backgroundColor)(p);\n  }\n}\nfunction getRadius(values, radiusName) {\n  var _a;\n  return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n}\nfunction layoutStack() {\n  var stack = new Set();\n  var state = {\n    leadIsExiting: false\n  };\n  var prevState = tslib.__assign({}, state);\n  var prevValues;\n  var prevViewportBox;\n  var prevDragCursor;\n  var crossfader = createCrossfader();\n  var needsCrossfadeAnimation = false;\n  function getFollowViewportBox() {\n    return state.follow ? state.follow.prevViewportBox : prevViewportBox;\n  }\n  function getFollowLayout() {\n    var _a;\n    return (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getLayoutState().layout;\n  }\n  return {\n    add: function (element) {\n      element.setCrossfader(crossfader);\n      stack.add(element);\n      /**\n       * Hydrate new element with previous drag position if we have one\n       */\n      if (prevDragCursor) element.prevDragCursor = prevDragCursor;\n      if (!state.lead) state.lead = element;\n    },\n    remove: function (element) {\n      stack.delete(element);\n    },\n    getLead: function () {\n      return state.lead;\n    },\n    updateSnapshot: function () {\n      if (!state.lead) return;\n      prevValues = crossfader.isActive() ? crossfader.getLatestValues() : state.lead.getLatestValues();\n      prevViewportBox = state.lead.prevViewportBox;\n      var dragControls = elementDragControls.get(state.lead);\n      if (dragControls && dragControls.isDragging) {\n        prevDragCursor = dragControls.cursorProgress;\n      }\n    },\n    clearSnapshot: function () {\n      prevDragCursor = prevViewportBox = undefined;\n    },\n    updateLeadAndFollow: function () {\n      var _a;\n      prevState = tslib.__assign({}, state);\n      var lead;\n      var follow;\n      var order = Array.from(stack);\n      for (var i = order.length; i--; i >= 0) {\n        var element = order[i];\n        if (lead) follow !== null && follow !== void 0 ? follow : follow = element;\n        lead !== null && lead !== void 0 ? lead : lead = element;\n        if (lead && follow) break;\n      }\n      state.lead = lead;\n      state.follow = follow;\n      state.leadIsExiting = ((_a = state.lead) === null || _a === void 0 ? void 0 : _a.presence) === Presence.Exiting;\n      crossfader.setOptions({\n        lead: lead,\n        follow: follow,\n        prevValues: prevValues,\n        crossfadeOpacity: (follow === null || follow === void 0 ? void 0 : follow.isPresenceRoot) || (lead === null || lead === void 0 ? void 0 : lead.isPresenceRoot)\n      });\n      if (\n      // Don't crossfade if we've just animated back from lead and switched the\n      // old follow to the new lead.\n      state.lead !== prevState.follow && (prevState.lead !== state.lead || prevState.leadIsExiting !== state.leadIsExiting)) {\n        needsCrossfadeAnimation = true;\n      }\n    },\n    animate: function (child, shouldCrossfade) {\n      var _a;\n      if (shouldCrossfade === void 0) {\n        shouldCrossfade = false;\n      }\n      if (child === state.lead) {\n        if (shouldCrossfade) {\n          /**\n           * Point a lead to itself in case it was previously pointing\n           * to a different visual element\n           */\n          child.pointTo(state.lead);\n        } else {\n          child.setVisibility(true);\n        }\n        var config = {};\n        var prevParent = (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getProjectionParent();\n        if (prevParent) {\n          /**\n           * We'll use this to determine if the element or its layoutId has been reparented.\n           */\n          config.prevParent = prevParent;\n        }\n        if (child.presence === Presence.Entering) {\n          config.originBox = getFollowViewportBox();\n        } else if (child.presence === Presence.Exiting) {\n          config.targetBox = getFollowLayout();\n        }\n        if (needsCrossfadeAnimation) {\n          needsCrossfadeAnimation = false;\n          var transition = child.getDefaultTransition();\n          child.presence === Presence.Entering ? crossfader.toLead(transition) : crossfader.fromLead(transition);\n        }\n        child.notifyLayoutReady(config);\n      } else {\n        if (shouldCrossfade) {\n          state.lead && child.pointTo(state.lead);\n        } else {\n          child.setVisibility(false);\n        }\n      }\n    }\n  };\n}\nfunction resetRotate(child) {\n  // If there's no detected rotation values, we can early return without a forced render.\n  var hasRotate = false;\n  // Keep a record of all the values we've reset\n  var resetValues = {};\n  // Check the rotate value of all axes and reset to 0\n  for (var i = 0; i < transformAxes.length; i++) {\n    var axis = transformAxes[i];\n    var key = \"rotate\" + axis;\n    // If this rotation doesn't exist as a motion value, then we don't\n    // need to reset it\n    if (!child.hasValue(key) || child.getStaticValue(key) === 0) continue;\n    hasRotate = true;\n    // Record the rotation and then temporarily set it to 0\n    resetValues[key] = child.getStaticValue(key);\n    child.setStaticValue(key, 0);\n  }\n  // If there's no rotation values, we don't need to do any more.\n  if (!hasRotate) return;\n  // Force a render of this element to apply the transform with all rotations\n  // set to 0.\n  child.syncRender();\n  // Put back all the values we reset\n  for (var key in resetValues) {\n    child.setStaticValue(key, resetValues[key]);\n  }\n  // Schedule a render for the next frame. This ensures we won't visually\n  // see the element with the reset rotate value applied.\n  child.scheduleRender();\n}\n\n/**\n * @public\n */\nvar AnimateSharedLayout = /** @class */function (_super) {\n  tslib.__extends(AnimateSharedLayout, _super);\n  function AnimateSharedLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * A list of all the children in the shared layout\n     */\n    _this.children = new Set();\n    /**\n     * As animate components with a defined `layoutId` are added/removed to the tree,\n     * we store them in order. When one is added, it will animate out from the\n     * previous one, and when it's removed, it'll animate to the previous one.\n     */\n    _this.stacks = new Map();\n    /**\n     * Track whether the component has mounted. If it hasn't, the presence of added children\n     * are set to Present, whereas if it has they're considered Entering\n     */\n    _this.hasMounted = false;\n    /**\n     * Track whether we already have an update scheduled. If we don't, we'll run snapshots\n     * and schedule one.\n     */\n    _this.updateScheduled = false;\n    /**\n     * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\n     */\n    _this.renderScheduled = false;\n    /**\n     * The methods provided to all children in the shared layout tree.\n     */\n    _this.syncContext = tslib.__assign(tslib.__assign({}, createBatcher()), {\n      syncUpdate: function (force) {\n        return _this.scheduleUpdate(force);\n      },\n      forceUpdate: function () {\n        // By copying syncContext to itself, when this component re-renders it'll also re-render\n        // all children subscribed to the SharedLayout context.\n        _this.syncContext = tslib.__assign({}, _this.syncContext);\n        _this.scheduleUpdate(true);\n      },\n      register: function (child) {\n        return _this.addChild(child);\n      },\n      remove: function (child) {\n        return _this.removeChild(child);\n      }\n    });\n    return _this;\n  }\n  AnimateSharedLayout.prototype.componentDidMount = function () {\n    this.hasMounted = true;\n  };\n  AnimateSharedLayout.prototype.componentDidUpdate = function () {\n    this.startLayoutAnimation();\n  };\n  AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\n    this.renderScheduled = true;\n    return true;\n  };\n  AnimateSharedLayout.prototype.startLayoutAnimation = function () {\n    var _this = this;\n    /**\n     * Reset update and render scheduled status\n     */\n    this.renderScheduled = this.updateScheduled = false;\n    var type = this.props.type;\n    /**\n     * Update presence metadata based on the latest AnimatePresence status.\n     * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\n     */\n    this.children.forEach(function (child) {\n      if (!child.isPresent) {\n        child.presence = Presence.Exiting;\n      } else if (child.presence !== Presence.Entering) {\n        child.presence = child.presence === Presence.Exiting ? Presence.Entering : Presence.Present;\n      }\n    });\n    this.updateStacks();\n    /**\n     * Create a handler which we can use to flush the children animations\n     */\n    var handler = {\n      layoutReady: function (child) {\n        if (child.getLayoutId() !== undefined) {\n          var stack = _this.getStack(child);\n          stack.animate(child, type === \"crossfade\");\n        } else {\n          child.notifyLayoutReady();\n        }\n      },\n      parent: this.context.visualElement\n    };\n    /**\n     * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\n     * This requires some co-ordination across components to stop layout thrashing\n     * and ensure measurements are taken at the correct time.\n     *\n     * Here we use that same mechanism of schedule/flush.\n     */\n    this.children.forEach(function (child) {\n      return _this.syncContext.add(child);\n    });\n    this.syncContext.flush(handler);\n    /**\n     * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\n     */\n    this.stacks.forEach(function (stack) {\n      return stack.clearSnapshot();\n    });\n  };\n  AnimateSharedLayout.prototype.updateStacks = function () {\n    this.stacks.forEach(function (stack) {\n      return stack.updateLeadAndFollow();\n    });\n  };\n  AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\n    if (force === void 0) {\n      force = false;\n    }\n    if (!(force || !this.updateScheduled)) return;\n    /**\n     * Flag we've scheduled an update\n     */\n    this.updateScheduled = true;\n    /**\n     * Write: Reset transforms so bounding boxes can be accurately measured.\n     */\n    this.children.forEach(function (child) {\n      resetRotate(child);\n      if (child.shouldResetTransform()) child.resetTransform();\n    });\n    /**\n     * Read: Snapshot children\n     */\n    this.children.forEach(snapshotViewportBox);\n    /**\n     * Every child keeps a local snapshot, but we also want to record\n     * snapshots of the visible children as, if they're are being removed\n     * in this render, we can still access them.\n     *\n     * TODO: What would be better here is doing a single loop where we\n     * only snapshotViewportBoxes of undefined layoutIds and then one for each stack\n     */\n    this.stacks.forEach(function (stack) {\n      return stack.updateSnapshot();\n    });\n    /**\n     * Force a rerender by setting state if we aren't already going to render.\n     */\n    if (force || !this.renderScheduled) {\n      this.renderScheduled = true;\n      this.forceUpdate();\n    }\n  };\n  AnimateSharedLayout.prototype.addChild = function (child) {\n    this.children.add(child);\n    this.addToStack(child);\n    child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n  };\n  AnimateSharedLayout.prototype.removeChild = function (child) {\n    this.scheduleUpdate();\n    this.children.delete(child);\n    this.removeFromStack(child);\n  };\n  AnimateSharedLayout.prototype.addToStack = function (child) {\n    var stack = this.getStack(child);\n    stack === null || stack === void 0 ? void 0 : stack.add(child);\n  };\n  AnimateSharedLayout.prototype.removeFromStack = function (child) {\n    var stack = this.getStack(child);\n    stack === null || stack === void 0 ? void 0 : stack.remove(child);\n  };\n  /**\n   * Return a stack of animate children based on the provided layoutId.\n   * Will create a stack if none currently exists with that layoutId.\n   */\n  AnimateSharedLayout.prototype.getStack = function (child) {\n    var id = child.getLayoutId();\n    if (id === undefined) return;\n    // Create stack if it doesn't already exist\n    !this.stacks.has(id) && this.stacks.set(id, layoutStack());\n    return this.stacks.get(id);\n  };\n  AnimateSharedLayout.prototype.render = function () {\n    return React__namespace.createElement(SharedLayoutContext.Provider, {\n      value: this.syncContext\n    }, this.props.children);\n  };\n  AnimateSharedLayout.contextType = MotionContext;\n  return AnimateSharedLayout;\n}(React__namespace.Component);\n\n/**\n * `MotionConfig` is used to set configuration options for all children `motion` components.\n *\n * ```jsx\n * import { motion, MotionConfig } from \"framer-motion\"\n *\n * export function App() {\n *   return (\n *     <MotionConfig transition={{ type: \"spring\" }}>\n *       <motion.div animate={{ x: 100 }} />\n *     </MotionConfig>\n *   )\n * }\n * ```\n *\n * @public\n */\nfunction MotionConfig(_a) {\n  var children = _a.children,\n    config = tslib.__rest(_a, [\"children\"]);\n  /**\n   * Inherit props from any parent MotionConfig components\n   */\n  config = tslib.__assign(tslib.__assign({}, React.useContext(MotionConfigContext)), config);\n  /**\n   * Don't allow isStatic to change between renders as it affects how many hooks\n   * motion components fire.\n   */\n  config.isStatic = useConstant(function () {\n    return config.isStatic;\n  });\n  /**\n   * Creating a new config context object will re-render every `motion` component\n   * every time it renders. So we only want to create a new one sparingly.\n   */\n  var transitionDependency = typeof config.transition === \"object\" ? config.transition.toString() : \"\";\n  var context = React.useMemo(function () {\n    return config;\n  }, [transitionDependency, config.transformPagePoint]);\n  return React__namespace.createElement(MotionConfigContext.Provider, {\n    value: context\n  }, children);\n}\n\n/**\n * Used in conjunction with the `m` component to reduce bundle size.\n *\n * `m` is a version of the `motion` component that only loads functionality\n * critical for the initial render.\n *\n * `LazyMotion` can then be used to either synchronously or asynchronously\n * load animation and gesture support.\n *\n * ```jsx\n * // Synchronous loading\n * import { LazyMotion, m, domAnimations } from \"framer-motion\"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={domAnimations}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n *\n * // Asynchronous loading\n * import { LazyMotion, m } from \"framer-motion\"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={() => import('./path/to/domAnimations')}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n * ```\n *\n * @public\n */\nfunction LazyMotion(_a) {\n  var children = _a.children,\n    features = _a.features,\n    _b = _a.strict,\n    strict = _b === void 0 ? false : _b;\n  var _c = tslib.__read(React.useState(!isLazyBundle(features)), 2),\n    setIsLoaded = _c[1];\n  var loadedRenderer = React.useRef(undefined);\n  /**\n   * If this is a synchronous load, load features immediately\n   */\n  if (!isLazyBundle(features)) {\n    var renderer = features.renderer,\n      loadedFeatures = tslib.__rest(features, [\"renderer\"]);\n    loadedRenderer.current = renderer;\n    loadFeatures(loadedFeatures);\n  }\n  React.useEffect(function () {\n    if (isLazyBundle(features)) {\n      features().then(function (_a) {\n        var renderer = _a.renderer,\n          loadedFeatures = tslib.__rest(_a, [\"renderer\"]);\n        loadFeatures(loadedFeatures);\n        loadedRenderer.current = renderer;\n        setIsLoaded(true);\n      });\n    }\n  }, []);\n  return React__namespace.createElement(LazyContext.Provider, {\n    value: {\n      renderer: loadedRenderer.current,\n      strict: strict\n    }\n  }, children);\n}\nfunction isLazyBundle(features) {\n  return typeof features === \"function\";\n}\n\n/**\n * @public\n */\nvar domAnimation = tslib.__assign(tslib.__assign({\n  renderer: createDomVisualElement\n}, animations), gestureAnimations);\n\n/**\n * @public\n */\nvar domMax = tslib.__assign(tslib.__assign(tslib.__assign({}, domAnimation), drag), layoutAnimations);\n\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * @library\n *\n * ```jsx\n * export function MyComponent() {\n *   const scale = useMotionValue(1)\n *\n *   return <Frame scale={scale} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\nfunction useMotionValue(initial) {\n  var value = useConstant(function () {\n    return motionValue(initial);\n  });\n  /**\n   * If this motion value is being used in static mode, like on\n   * the Framer canvas, force components to rerender when the motion\n   * value is updated.\n   */\n  var isStatic = React.useContext(MotionConfigContext).isStatic;\n  if (isStatic) {\n    var _a = tslib.__read(React.useState(initial), 2),\n      setLatest_1 = _a[1];\n    React.useEffect(function () {\n      return value.onChange(setLatest_1);\n    }, []);\n  }\n  return value;\n}\nfunction useOnChange(value, callback) {\n  React.useEffect(function () {\n    if (isMotionValue(value)) return value.onChange(callback);\n  }, [callback]);\n}\nfunction useMultiOnChange(values, handler) {\n  React.useEffect(function () {\n    var subscriptions = values.map(function (value) {\n      return value.onChange(handler);\n    });\n    return function () {\n      return subscriptions.forEach(function (unsubscribe) {\n        return unsubscribe();\n      });\n    };\n  });\n}\nfunction useCombineMotionValues(values, combineValues) {\n  /**\n   * Initialise the returned motion value. This remains the same between renders.\n   */\n  var value = useMotionValue(combineValues());\n  /**\n   * Create a function that will update the template motion value with the latest values.\n   * This is pre-bound so whenever a motion value updates it can schedule its\n   * execution in Framesync. If it's already been scheduled it won't be fired twice\n   * in a single frame.\n   */\n  var updateValue = function () {\n    return value.set(combineValues());\n  };\n  /**\n   * Synchronously update the motion value with the latest values during the render.\n   * This ensures that within a React render, the styles applied to the DOM are up-to-date.\n   */\n  updateValue();\n  /**\n   * Subscribe to all motion values found within the template. Whenever any of them change,\n   * schedule an update.\n   */\n  useMultiOnChange(values, function () {\n    return sync__default['default'].update(updateValue, false, true);\n  });\n  return value;\n}\n\n/**\n * Combine multiple motion values into a new one using a string template literal.\n *\n * ```jsx\n * import {\n *   motion,\n *   useSpring,\n *   useMotionValue,\n *   useMotionTemplate\n * } from \"framer-motion\"\n *\n * function Component() {\n *   const shadowX = useSpring(0)\n *   const shadowY = useMotionValue(0)\n *   const shadow = useMotionTemplate`drop-shadow(${shadowX}px ${shadowY}px 20px rgba(0,0,0,0.3))`\n *\n *   return <motion.div style={{ filter: shadow }} />\n * }\n * ```\n *\n * @public\n */\nfunction useMotionTemplate(fragments) {\n  var values = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    values[_i - 1] = arguments[_i];\n  }\n  /**\n   * Create a function that will build a string from the latest motion values.\n   */\n  var numFragments = fragments.length;\n  function buildValue() {\n    var output = \"\";\n    for (var i = 0; i < numFragments; i++) {\n      output += fragments[i];\n      var value = values[i];\n      if (value) output += values[i].get();\n    }\n    return output;\n  }\n  return useCombineMotionValues(values, buildValue);\n}\nvar isCustomValueType = function (v) {\n  return typeof v === \"object\" && v.mix;\n};\nvar getMixer = function (v) {\n  return isCustomValueType(v) ? v.mix : undefined;\n};\nfunction transform() {\n  var args = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n  var useImmediate = !Array.isArray(args[0]);\n  var argOffset = useImmediate ? 0 : -1;\n  var inputValue = args[0 + argOffset];\n  var inputRange = args[1 + argOffset];\n  var outputRange = args[2 + argOffset];\n  var options = args[3 + argOffset];\n  var interpolator = popmotion.interpolate(inputRange, outputRange, tslib.__assign({\n    mixer: getMixer(outputRange[0])\n  }, options));\n  return useImmediate ? interpolator(inputValue) : interpolator;\n}\nfunction useTransform(input, inputRangeOrTransformer, outputRange, options) {\n  var transformer = typeof inputRangeOrTransformer === \"function\" ? inputRangeOrTransformer : transform(inputRangeOrTransformer, outputRange, options);\n  return Array.isArray(input) ? useListTransform(input, transformer) : useListTransform([input], function (_a) {\n    var _b = tslib.__read(_a, 1),\n      latest = _b[0];\n    return transformer(latest);\n  });\n}\nfunction useListTransform(values, transformer) {\n  var latest = useConstant(function () {\n    return [];\n  });\n  return useCombineMotionValues(values, function () {\n    latest.length = 0;\n    var numValues = values.length;\n    for (var i = 0; i < numValues; i++) {\n      latest[i] = values[i].get();\n    }\n    return transformer(latest);\n  });\n}\n\n/**\n * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.\n *\n * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber\n * to another `MotionValue`.\n *\n * @remarks\n *\n * ```jsx\n * const x = useSpring(0, { stiffness: 300 })\n * const y = useSpring(x, { damping: 10 })\n * ```\n *\n * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.\n * @param springConfig - Configuration options for the spring.\n * @returns `MotionValue`\n *\n * @public\n */\nfunction useSpring(source, config) {\n  if (config === void 0) {\n    config = {};\n  }\n  var isStatic = React.useContext(MotionConfigContext).isStatic;\n  var activeSpringAnimation = React.useRef(null);\n  var value = useMotionValue(isMotionValue(source) ? source.get() : source);\n  React.useMemo(function () {\n    return value.attach(function (v, set) {\n      /**\n       * A more hollistic approach to this might be to use isStatic to fix VisualElement animations\n       * at that level, but this will work for now\n       */\n      if (isStatic) return set(v);\n      if (activeSpringAnimation.current) {\n        activeSpringAnimation.current.stop();\n      }\n      activeSpringAnimation.current = popmotion.animate(tslib.__assign(tslib.__assign({\n        from: value.get(),\n        to: v,\n        velocity: value.getVelocity()\n      }, config), {\n        onUpdate: set\n      }));\n      return value.get();\n    });\n  }, Object.values(config));\n  useOnChange(source, function (v) {\n    return value.set(parseFloat(v));\n  });\n  return value;\n}\n\n/**\n * Creates a `MotionValue` that updates when the velocity of the provided `MotionValue` changes.\n *\n * ```javascript\n * const x = useMotionValue(0)\n * const xVelocity = useVelocity(x)\n * const xAcceleration = useVelocity(xVelocity)\n * ```\n *\n * @public\n */\nfunction useVelocity(value) {\n  var velocity = useMotionValue(value.getVelocity());\n  React.useEffect(function () {\n    return value.velocityUpdateSubscribers.add(function (newVelocity) {\n      velocity.set(newVelocity);\n    });\n  }, [value]);\n  return velocity;\n}\nfunction createScrollMotionValues() {\n  return {\n    scrollX: motionValue(0),\n    scrollY: motionValue(0),\n    scrollXProgress: motionValue(0),\n    scrollYProgress: motionValue(0)\n  };\n}\nfunction setProgress(offset, maxOffset, value) {\n  value.set(!offset || !maxOffset ? 0 : offset / maxOffset);\n}\nfunction createScrollUpdater(values, getOffsets) {\n  var update = function () {\n    var _a = getOffsets(),\n      xOffset = _a.xOffset,\n      yOffset = _a.yOffset,\n      xMaxOffset = _a.xMaxOffset,\n      yMaxOffset = _a.yMaxOffset;\n    // Set absolute positions\n    values.scrollX.set(xOffset);\n    values.scrollY.set(yOffset);\n    // Set 0-1 progress\n    setProgress(xOffset, xMaxOffset, values.scrollXProgress);\n    setProgress(yOffset, yMaxOffset, values.scrollYProgress);\n  };\n  update();\n  return update;\n}\nvar getElementScrollOffsets = function (element) {\n  return function () {\n    return {\n      xOffset: element.scrollLeft,\n      yOffset: element.scrollTop,\n      xMaxOffset: element.scrollWidth - element.offsetWidth,\n      yMaxOffset: element.scrollHeight - element.offsetHeight\n    };\n  };\n};\n/**\n * Returns MotionValues that update when the provided element scrolls:\n *\n * - `scrollX`  Horizontal scroll distance in pixels.\n * - `scrollY`  Vertical scroll distance in pixels.\n * - `scrollXProgress`  Horizontal scroll progress between `0` and `1`.\n * - `scrollYProgress`  Vertical scroll progress between `0` and `1`.\n *\n * This element must be set to `overflow: scroll` on either or both axes to report scroll offset.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import {\n *   Frame,\n *   useElementScroll,\n *   useTransform\n * } from \"framer\"\n *\n * export function MyComponent() {\n *   const ref = React.useRef()\n *   const { scrollYProgress } = useElementScroll(ref)\n *\n *   return (\n *     <Frame ref={ref}>\n *       <Frame scaleX={scrollYProgress} />\n *     </Frame>\n *   )\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const ref = useRef()\n *   const { scrollYProgress } = useElementScroll(ref)\n *\n *   return (\n *     <div ref={ref}>\n *       <motion.div style={{ scaleX: scrollYProgress }} />\n *     </div>\n *   )\n * }\n * ```\n *\n * @public\n */\nfunction useElementScroll(ref) {\n  var values = useConstant(createScrollMotionValues);\n  useIsomorphicLayoutEffect(function () {\n    var element = ref.current;\n    heyListen.invariant(!!element, \"ref provided to useScroll must be passed into a HTML element.\");\n    if (!element) return;\n    var updateScrollValues = createScrollUpdater(values, getElementScrollOffsets(element));\n    var scrollListener = addDomEvent(element, \"scroll\", updateScrollValues, {\n      passive: true\n    });\n    var resizeListener = addDomEvent(element, \"resize\", updateScrollValues);\n    return function () {\n      scrollListener && scrollListener();\n      resizeListener && resizeListener();\n    };\n  }, []);\n  return values;\n}\nvar viewportScrollValues;\nfunction getViewportScrollOffsets() {\n  return {\n    xOffset: window.pageXOffset,\n    yOffset: window.pageYOffset,\n    xMaxOffset: document.body.clientWidth - window.innerWidth,\n    yMaxOffset: document.body.clientHeight - window.innerHeight\n  };\n}\nvar hasListeners = false;\nfunction addEventListeners() {\n  hasListeners = true;\n  if (typeof window === \"undefined\") return;\n  var updateScrollValues = createScrollUpdater(viewportScrollValues, getViewportScrollOffsets);\n  addDomEvent(window, \"scroll\", updateScrollValues, {\n    passive: true\n  });\n  addDomEvent(window, \"resize\", updateScrollValues);\n}\n/**\n * Returns MotionValues that update when the viewport scrolls:\n *\n * - `scrollX`  Horizontal scroll distance in pixels.\n * - `scrollY`  Vertical scroll distance in pixels.\n * - `scrollXProgress`  Horizontal scroll progress between `0` and `1`.\n * - `scrollYProgress`  Vertical scroll progress between `0` and `1`.\n *\n * **Warning:** Setting `body` or `html` to `height: 100%` or similar will break the `Progress`\n * values as this breaks the browser's capability to accurately measure the page length.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import {\n *   Frame,\n *   useViewportScroll,\n *   useTransform\n * } from \"framer\"\n *\n * export function MyComponent() {\n *   const { scrollYProgress } = useViewportScroll()\n *   return <Frame scaleX={scrollYProgress} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const { scrollYProgress } = useViewportScroll()\n *   return <motion.div style={{ scaleX: scrollYProgress }} />\n * }\n * ```\n *\n * @public\n */\nfunction useViewportScroll() {\n  /**\n   * Lazy-initialise the viewport scroll values\n   */\n  if (!viewportScrollValues) {\n    viewportScrollValues = createScrollMotionValues();\n  }\n  useIsomorphicLayoutEffect(function () {\n    !hasListeners && addEventListeners();\n  }, []);\n  return viewportScrollValues;\n}\n\n// Does this device prefer reduced motion? Returns `null` server-side.\nvar prefersReducedMotion;\nfunction initPrefersReducedMotion() {\n  prefersReducedMotion = motionValue(null);\n  if (typeof window === \"undefined\") return;\n  if (window.matchMedia) {\n    var motionMediaQuery_1 = window.matchMedia(\"(prefers-reduced-motion)\");\n    var setReducedMotionPreferences = function () {\n      return prefersReducedMotion.set(motionMediaQuery_1.matches);\n    };\n    motionMediaQuery_1.addListener(setReducedMotionPreferences);\n    setReducedMotionPreferences();\n  } else {\n    prefersReducedMotion.set(false);\n  }\n}\n/**\n * A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.\n *\n * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing\n * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.\n *\n * It will actively respond to changes and re-render your components with the latest setting.\n *\n * ```jsx\n * export function Sidebar({ isOpen }) {\n *   const shouldReduceMotion = useReducedMotion()\n *   const closedX = shouldReduceMotion ? 0 : \"-100%\"\n *\n *   return (\n *     <motion.div animate={{\n *       opacity: isOpen ? 1 : 0,\n *       x: isOpen ? 0 : closedX\n *     }} />\n *   )\n * }\n * ```\n *\n * @return boolean\n *\n * @public\n */\nfunction useReducedMotion() {\n  /**\n   * Lazy initialisation of prefersReducedMotion\n   */\n  !prefersReducedMotion && initPrefersReducedMotion();\n  var _a = tslib.__read(React.useState(prefersReducedMotion.get()), 2),\n    shouldReduceMotion = _a[0],\n    setShouldReduceMotion = _a[1];\n  useOnChange(prefersReducedMotion, setShouldReduceMotion);\n  return shouldReduceMotion;\n}\n\n/**\n * @public\n */\nfunction animationControls() {\n  /**\n   * Track whether the host component has mounted.\n   */\n  var hasMounted = false;\n  /**\n   * Pending animations that are started before a component is mounted.\n   * TODO: Remove this as animations should only run in effects\n   */\n  var pendingAnimations = [];\n  /**\n   * A collection of linked component animation controls.\n   */\n  var subscribers = new Set();\n  var controls = {\n    subscribe: function (visualElement) {\n      subscribers.add(visualElement);\n      return function () {\n        return void subscribers.delete(visualElement);\n      };\n    },\n    start: function (definition, transitionOverride) {\n      /**\n       * TODO: We only perform this hasMounted check because in Framer we used to\n       * encourage the ability to start an animation within the render phase. This\n       * isn't behaviour concurrent-safe so when we make Framer concurrent-safe\n       * we can ditch this.\n       */\n      if (hasMounted) {\n        var animations_1 = [];\n        subscribers.forEach(function (visualElement) {\n          animations_1.push(animateVisualElement(visualElement, definition, {\n            transitionOverride: transitionOverride\n          }));\n        });\n        return Promise.all(animations_1);\n      } else {\n        return new Promise(function (resolve) {\n          pendingAnimations.push({\n            animation: [definition, transitionOverride],\n            resolve: resolve\n          });\n        });\n      }\n    },\n    set: function (definition) {\n      heyListen.invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n      return subscribers.forEach(function (visualElement) {\n        setValues(visualElement, definition);\n      });\n    },\n    stop: function () {\n      subscribers.forEach(function (visualElement) {\n        stopAnimation(visualElement);\n      });\n    },\n    mount: function () {\n      hasMounted = true;\n      pendingAnimations.forEach(function (_a) {\n        var animation = _a.animation,\n          resolve = _a.resolve;\n        controls.start.apply(controls, tslib.__spreadArray([], tslib.__read(animation))).then(resolve);\n      });\n      return function () {\n        hasMounted = false;\n        controls.stop();\n      };\n    }\n  };\n  return controls;\n}\n\n/**\n * Creates `AnimationControls`, which can be used to manually start, stop\n * and sequence animations on one or more components.\n *\n * The returned `AnimationControls` should be passed to the `animate` property\n * of the components you want to animate.\n *\n * These components can then be animated with the `start` method.\n *\n * @library\n *\n * ```jsx\n * import * as React from 'react'\n * import { Frame, useAnimation } from 'framer'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <Frame animate={controls} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * import * as React from 'react'\n * import { motion, useAnimation } from 'framer-motion'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <motion.div animate={controls} />\n * }\n * ```\n *\n * @returns Animation controller with `start` and `stop` methods\n *\n * @public\n */\nfunction useAnimation() {\n  var controls = useConstant(animationControls);\n  React.useEffect(controls.mount, []);\n  return controls;\n}\n\n/**\n * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import { Frame, useCycle } from \"framer\"\n *\n * export function MyComponent() {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <Frame\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @motion\n *\n * An index value can be passed to the returned `cycle` function to cycle to a specific index.\n *\n * ```jsx\n * import * as React from \"react\"\n * import { motion, useCycle } from \"framer-motion\"\n *\n * export const MyComponent = () => {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <motion.div\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @param items - items to cycle through\n * @returns [currentState, cycleState]\n *\n * @public\n */\nfunction useCycle() {\n  var items = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    items[_i] = arguments[_i];\n  }\n  var index = React.useRef(0);\n  var _a = tslib.__read(React.useState(items[index.current]), 2),\n    item = _a[0],\n    setItem = _a[1];\n  return [item, function (next) {\n    index.current = typeof next !== \"number\" ? popmotion.wrap(0, items.length, index.current + 1) : next;\n    setItem(items[index.current]);\n  }];\n}\n\n/**\n * Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.\n *\n * @library\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <Frame onTapStart={startDrag} />\n *     <Frame drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @motion\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\nvar DragControls = /** @class */function () {\n  function DragControls() {\n    this.componentControls = new Set();\n  }\n  /**\n   * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.\n   *\n   * @internal\n   */\n  DragControls.prototype.subscribe = function (controls) {\n    var _this = this;\n    this.componentControls.add(controls);\n    return function () {\n      return _this.componentControls.delete(controls);\n    };\n  };\n  /**\n   * Start a drag gesture on every `motion` component that has this set of drag controls\n   * passed into it via the `dragControls` prop.\n   *\n   * ```jsx\n   * dragControls.start(e, {\n   *   snapToCursor: true\n   * })\n   * ```\n   *\n   * @param event - PointerEvent\n   * @param options - Options\n   *\n   * @public\n   */\n  DragControls.prototype.start = function (event, options) {\n    this.componentControls.forEach(function (controls) {\n      controls.start(event.nativeEvent || event, options);\n    });\n  };\n  DragControls.prototype.updateConstraints = function (flush) {\n    if (flush === void 0) {\n      flush = true;\n    }\n    this.componentControls.forEach(function (controls) {\n      controls.updateConstraints();\n    });\n    flush && flushLayout();\n  };\n  return DragControls;\n}();\nvar createDragControls = function () {\n  return new DragControls();\n};\n/**\n * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop\n * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we\n * might want to initiate that dragging from a different component than the draggable one.\n *\n * By creating a `dragControls` using the `useDragControls` hook, we can pass this into\n * the draggable component's `dragControls` prop. It exposes a `start` method\n * that can start dragging from pointer events on other components.\n *\n * @library\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <Frame onTapStart={startDrag} />\n *     <Frame drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @motion\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\nfunction useDragControls() {\n  return useConstant(createDragControls);\n}\nvar createObject = function () {\n  return {};\n};\nvar stateVisualElement = visualElement({\n  build: function () {},\n  measureViewportBox: axisBox,\n  resetTransform: function () {},\n  restoreTransform: function () {},\n  removeValueFromRenderState: function () {},\n  render: function () {},\n  scrapeMotionValuesFromProps: createObject,\n  readValueFromInstance: function (_state, key, options) {\n    return options.initialState[key] || 0;\n  },\n  makeTargetAnimatable: function (element, _a) {\n    var transition = _a.transition,\n      transitionEnd = _a.transitionEnd,\n      target = tslib.__rest(_a, [\"transition\", \"transitionEnd\"]);\n    var origin = getOrigin(target, transition || {}, element);\n    checkTargetForNewValues(element, target, origin);\n    return tslib.__assign({\n      transition: transition,\n      transitionEnd: transitionEnd\n    }, target);\n  }\n});\nvar useVisualState = makeUseVisualState({\n  scrapeMotionValuesFromProps: createObject,\n  createRenderState: createObject\n});\n/**\n * This is not an officially supported API and may be removed\n * on any version.\n * @internal\n */\nfunction useAnimatedState(initialState) {\n  var _a = tslib.__read(React.useState(initialState), 2),\n    animationState = _a[0],\n    setAnimationState = _a[1];\n  var visualState = useVisualState({}, false);\n  var element = useConstant(function () {\n    return stateVisualElement({\n      props: {},\n      visualState: visualState\n    }, {\n      initialState: initialState\n    });\n  });\n  React.useEffect(function () {\n    element.mount({});\n    return element.unmount();\n  }, []);\n  React.useEffect(function () {\n    element.setProps({\n      onUpdate: function (v) {\n        return setAnimationState(tslib.__assign({}, v));\n      }\n    });\n  });\n  var startAnimation = useConstant(function () {\n    return function (animationDefinition) {\n      return animateVisualElement(element, animationDefinition);\n    };\n  });\n  return [animationState, startAnimation];\n}\n\n// Keep things reasonable and avoid scale: Infinity. In practise we might need\n// to add another value, opacity, that could interpolate scaleX/Y [0,0.01] => [0,1]\n// to simply hide content at unreasonable scales.\nvar maxScale = 100000;\nvar invertScale = function (scale) {\n  return scale > 0.001 ? 1 / scale : maxScale;\n};\nvar hasWarned = false;\n/**\n * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse\n * of their respective parent scales.\n *\n * This is useful for undoing the distortion of content when scaling a parent component.\n *\n * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.\n * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output\n * of those instead.\n *\n * @motion\n *\n * ```jsx\n * const MyComponent = () => {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <motion.div style={{ scaleX, scaleY }} />\n * }\n * ```\n *\n * @library\n *\n * ```jsx\n * function MyComponent() {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <Frame scaleX={scaleX} scaleY={scaleY} />\n * }\n * ```\n *\n * @deprecated\n * @internal\n */\nfunction useInvertedScale(scale) {\n  var parentScaleX = useMotionValue(1);\n  var parentScaleY = useMotionValue(1);\n  var visualElement = useVisualElementContext();\n  heyListen.invariant(!!(scale || visualElement), \"If no scale values are provided, useInvertedScale must be used within a child of another motion component.\");\n  heyListen.warning(hasWarned, \"useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.\");\n  hasWarned = true;\n  if (scale) {\n    parentScaleX = scale.scaleX || parentScaleX;\n    parentScaleY = scale.scaleY || parentScaleY;\n  } else if (visualElement) {\n    parentScaleX = visualElement.getValue(\"scaleX\", 1);\n    parentScaleY = visualElement.getValue(\"scaleY\", 1);\n  }\n  var scaleX = useTransform(parentScaleX, invertScale);\n  var scaleY = useTransform(parentScaleY, invertScale);\n  return {\n    scaleX: scaleX,\n    scaleY: scaleY\n  };\n}\nexports.AnimatePresence = AnimatePresence;\nexports.AnimateSharedLayout = AnimateSharedLayout;\nexports.DragControls = DragControls;\nexports.FlatTree = FlatTree;\nexports.FramerTreeLayoutContext = FramerTreeLayoutContext;\nexports.LayoutGroupContext = LayoutGroupContext;\nexports.LazyMotion = LazyMotion;\nexports.MotionConfig = MotionConfig;\nexports.MotionConfigContext = MotionConfigContext;\nexports.MotionValue = MotionValue;\nexports.PresenceContext = PresenceContext;\nexports.SharedLayoutContext = SharedLayoutContext;\nexports.addScaleCorrection = addScaleCorrection;\nexports.animate = animate;\nexports.animateVisualElement = animateVisualElement;\nexports.animationControls = animationControls;\nexports.batchLayout = batchLayout;\nexports.createBatcher = createBatcher;\nexports.createCrossfader = createCrossfader;\nexports.createDomMotionComponent = createDomMotionComponent;\nexports.createMotionComponent = createMotionComponent;\nexports.domAnimation = domAnimation;\nexports.domMax = domMax;\nexports.flushLayout = flushLayout;\nexports.isValidMotionProp = isValidMotionProp;\nexports.m = m;\nexports.motion = motion;\nexports.motionValue = motionValue;\nexports.resolveMotionValue = resolveMotionValue;\nexports.snapshotViewportBox = snapshotViewportBox;\nexports.transform = transform;\nexports.useAnimation = useAnimation;\nexports.useCycle = useCycle;\nexports.useDeprecatedAnimatedState = useAnimatedState;\nexports.useDeprecatedInvertedScale = useInvertedScale;\nexports.useDomEvent = useDomEvent;\nexports.useDragControls = useDragControls;\nexports.useElementScroll = useElementScroll;\nexports.useIsPresent = useIsPresent;\nexports.useMotionTemplate = useMotionTemplate;\nexports.useMotionValue = useMotionValue;\nexports.usePresence = usePresence;\nexports.useReducedMotion = useReducedMotion;\nexports.useSpring = useSpring;\nexports.useTransform = useTransform;\nexports.useVelocity = useVelocity;\nexports.useViewportScroll = useViewportScroll;\nexports.visualElement = visualElement;","map":{"version":3,"names":["Object","defineProperty","exports","value","tslib","require","React","heyListen","styleValueTypes","popmotion","sync","_interopDefaultLegacy","e","_interopNamespace","__esModule","n","create","keys","forEach","k","d","getOwnPropertyDescriptor","get","enumerable","freeze","React__namespace","React__default","sync__default","createDefinition","propNames","isEnabled","props","some","name","featureDefinitions","measureLayout","animation","exit","drag","focus","hover","tap","pan","layoutAnimation","loadFeatures","features","key","Component","LazyContext","createContext","strict","featureNames","numFeatures","length","useFeatures","visualElement","preloadedFeatures","lazyContext","useContext","process","env","NODE_ENV","invariant","i","name_1","_a","push","createElement","__assign","MotionConfigContext","transformPagePoint","p","isStatic","MotionContext","useVisualElementContext","PresenceContext","useConstant","init","ref","useRef","current","usePresence","context","isPresent","onExitComplete","register","id","useUniqueId","useEffect","safeToRemove","useIsPresent","counter","incrementId","LayoutGroupContext","isBrowser","window","useIsomorphicLayoutEffect","useLayoutEffect","useLayoutId","layoutId","layoutGroupId","undefined","useVisualElement","visualState","createVisualElement","config","parent","presenceContext","visualElementRef","renderer","presenceId","blockInitialAnimation","initial","setProps","isPresenceRoot","syncRender","animationState","animateChanges","notifyUnmount","isRefObject","prototype","hasOwnProperty","call","useMotionRef","externalRef","useCallback","instance","mount","unmount","isVariantLabels","v","Array","isArray","isVariantLabel","getCurrent","forEachValue","getVelocity$1","velocity","getVelocity","resolveVariantFromProps","definition","custom","currentValues","currentVelocity","variants","resolveVariant","getProps","checkIfControllingVariants","animate","start","whileHover","whileDrag","whileTap","whileFocus","checkIfVariantNode","Boolean","getCurrentTreeVariants","inherit","useCreateMotionContext","useMemo","variantLabelsAsDependency","prop","join","createMotionComponent","useRender","useVisualState","MotionComponent","Fragment","Provider","forwardRef","createMotionProxy","createConfig","customMotionComponentConfig","componentCache","Map","Proxy","_target","has","set","lowercaseSVGElements","isSVGComponent","includes","indexOf","test","valueScaleCorrection","addScaleCorrection","correctors","transformAxes","order","transformProps","operationKey","axesKey","sortTransformProps","a","b","transformPropSet","Set","isTransformProp","transformOriginProps","isTransformOriginProp","isForcedMotionValue","layout","isMotionValue","translateAlias","x","y","z","transformPerspective","buildTransform","_b","transformIsDefault","transformTemplate","transform","transformKeys","_c","enableHardwareAcceleration","_d","allowTransformNone","transformString","sort","transformHasZ","numTransformKeys","trim","buildTransformOrigin","originX","originY","originZ","isCSSVariable$1","startsWith","getValueAsType","type","int","number","Math","round","numberValueTypes","borderWidth","px","borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth","borderRadius","radius","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","width","maxWidth","height","maxHeight","size","top","right","bottom","left","padding","paddingTop","paddingRight","paddingBottom","paddingLeft","margin","marginTop","marginRight","marginBottom","marginLeft","rotate","degrees","rotateX","rotateY","rotateZ","scale","scaleX","scaleY","scaleZ","skew","skewX","skewY","distance","translateX","translateY","translateZ","perspective","opacity","alpha","progressPercentage","zIndex","fillOpacity","strokeOpacity","numOctaves","buildHTMLStyles","state","latestValues","projection","layoutState","options","buildProjectionTransform","buildProjectionTransformOrigin","style","vars","transformOrigin","hasTransform","hasTransformOrigin","transformIsNone","valueType","valueAsType","default","isHydrated","correctedValue","applyTo","num","deltaFinal","treeScale","createHtmlRenderState","copyRawValuesOnly","target","source","useInitialMotionValues","useStyle","styleProp","assign","transformValues","useHTMLProps","htmlProps","draggable","userSelect","WebkitUserSelect","WebkitTouchCallout","touchAction","validMotionProps","isValidMotionProp","shouldForward","emotionIsPropValid_1","filterProps","isDom","forwardMotionProps","filteredProps","calcOrigin$1","origin","offset","calcSVGTransformOrigin","dimensions","pxOriginX","pxOriginY","progressToPixels","progress","dashKeys","array","camelKeys","buildSVGPath","attrs","totalLength","spacing","useDashCase","pathLength","pathSpacing","buildSVGAttrs","attrX","attrY","pathOffset","latest","__rest","totalPathLength","createSvgRenderState","useSVGProps","visualProps","rawStyles","createUseRender","useVisualProps","elementProps","CAMEL_CASE_PATTERN","REPLACE_TEMPLATE","camelToDash","str","replace","toLowerCase","renderHTML","element","setProperty","camelCaseAttributes","renderSVG","renderState","setAttribute","scrapeMotionValuesFromProps$1","newValues","scrapeMotionValuesFromProps","targetKey","toUpperCase","isAnimationControls","isKeyframesTarget","isCustomValue","mix","toValue","resolveFinalValueInKeyframes","resolveMotionValue","unwrappedValue","makeState","createRenderState","onMount","makeLatestValues","makeUseVisualState","scrapeMotionValues","values","motionValues","isControllingVariants","isVariantNode","variantToSet","list","resolved","transitionEnd","transition","svgMotionConfig","getBBox","getBoundingClientRect","isPath","getTotalLength","tagName","htmlMotionConfig","createDomMotionConfig","baseConfig","AnimationType","addDomEvent","eventName","handler","addEventListener","removeEventListener","useDomEvent","useFocusGesture","onFocus","setActive","Focus","onBlur","isMouseEvent","event","PointerEvent","pointerType","MouseEvent","isTouchEvent","hasTouches","touches","filterPrimaryPointer","eventHandler","isPrimaryPointer","button","defaultPagePoint","pageX","pageY","pointFromTouch","pointType","primaryTouch","changedTouches","point","pointFromMouse","extractEventInfo","getViewportPointFromEvent","wrapHandler","shouldFilterPrimaryPointer","listener","supportsPointerEvents","onpointerdown","supportsTouchEvents","ontouchstart","supportsMouseEvents","onmousedown","mouseEventNames","pointerdown","pointermove","pointerup","pointercancel","pointerover","pointerout","pointerenter","pointerleave","touchEventNames","getPointerEventName","addPointerEvent","usePointerEvent","createLock","lock","openLock","globalHorizontalLock","globalVerticalLock","getGlobalLock","openHorizontal_1","openVertical_1","isDragActive","openGestureLock","createHoverEvent","isActive","callback","info","Hover","useHoverGesture","onHoverStart","onHoverEnd","isNodeOrChild","child","parentElement","useUnmountEffect","useTapGesture","onTap","onTapStart","onTapCancel","hasPressListeners","isPressing","cancelPointerEndListeners","removePointerEndListener","checkPointerEnd","Tap","onPointerUp","getInstance","onPointerCancel","onPointerDown","pipe","makeRenderlessComponent","hook","gestureAnimations","shallowCompare","next","prev","prevLength","secondsToMilliseconds","seconds","easingLookup","linear","easeIn","easeInOut","easeOut","circIn","circInOut","circOut","backIn","backInOut","backOut","anticipate","bounceIn","bounceInOut","bounceOut","easingDefinitionToFunction","__read","x1","y1","x2","y2","cubicBezier","isEasingArray","ease","isAnimatable","complex","underDampedSpring","stiffness","damping","restDelta","restSpeed","criticallyDampedSpring","to","sqrt","linearTween","duration","keyframes","defaultTransitions","backgroundColor","color","getDefaultTransition","valueKey","transitionFactory","defaultValueTypes","outlineColor","fill","stroke","borderColor","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor","filter","WebkitFilter","getDefaultValueType","getAnimatableNone","defaultValueType","isTransitionDefined","when","delay","delayChildren","staggerChildren","staggerDirection","repeat","repeatType","repeatDelay","from","legacyRepeatWarning","convertTransitionToAnimationOptions","times","yoyo","flip","loop","map","warning","getDelayFromTransition","valueTransition","getValueTransition","hydrateKeyframes","__spreadArray","getPopmotionAnimationOptions","getAnimation","onComplete","isTargetAnimatable","isZero","getZeroUnit","isOriginAnimatable","onUpdate","inertia","stop","parseFloat","potentialUnitType","startAnimation","delayTimer","controls","setTimeout","clearTimeout","isNumericalString","addUniqueItem","arr","item","removeItem","index","splice","SubscriptionManager","subscriptions","add","_this","notify","c","numSubscriptions","getSize","clear","isFloat","isNaN","MotionValue","timeDelta","lastUpdated","updateSubscribers","velocityUpdateSubscribers","renderSubscribers","canTrackVelocity","updateAndNotify","render","getFrameData","delta","timestamp","postRender","scheduleVelocityCheck","velocityCheck","hasAnimated","onChange","subscription","clearListeners","onRenderRequest","attach","passiveEffect","getPrevious","velocityPerSecond","Promise","resolve","stopAnimation","then","clearAnimation","isAnimating","destroy","motionValue","testValueType","auto","parse","dimensionValueTypes","percent","vw","vh","findDimensionValueType","find","valueTypes","findValueType","setMotionValue","hasValue","getValue","addValue","setTarget","makeTargetAnimatable","setVariants","variantLabels","reversedLabels","reverse","variant","getVariant","variantChildren","setValues","checkTargetForNewValues","newValueKeys","numNewValues","targetValue","readValue","setBaseTarget","getOriginFromTransition","getOrigin","animateVisualElement","notifyAnimationStart","animations","animateVariant","all","resolvedDefinition","animateTarget","notifyAnimationComplete","transitionOverride","getChildAnimations","forwardDelay","animateChildren","first","last","_e","_f","animationTypeState","getState","valueTarget","shouldBlockAnimation","maxStaggerDuration","generateStaggerDuration","sortByTreeOrder","sortNodePosition","protectedKeys","needsAnimating","shouldBlock","variantPriorityOrder","Animate","Drag","Exit","reversePriorityOrder","numAnimationTypes","animateList","createAnimationState","createState","allAnimatedKeys","isInitialRender","buildResolvedTypeValues","acc","isAnimated","setAnimateFunction","makeAnimator","changedActiveType","getVariantContext","removedKeys","encounteredKeys","removedVariantIndex","Infinity","_loop_1","typeState","propIsVariant","activeDelta","isInherited","manuallyAnimateOnMount","prevProp","shouldAnimateType","variantsHaveChanged","definitionList","resolvedValues","reduce","prevResolvedValues","allKeys","markToAnimate","delete","apply","fallbackAnimation_1","fallbackTarget","getBaseTarget","shouldAnimate","createTypeState","subscribe","PanSession","handlers","startEvent","lastMoveEvent","lastMoveEventInfo","updatePoint","getPanInfo","history","isPanStarted","isDistancePastThreshold","onStart","onMove","handlePointerMove","transformPoint","buttons","handlePointerUp","update","end","onEnd","onSessionEnd","panInfo","initialInfo","onSessionStart","removeListeners","updateHandlers","cancelSync","subtractPoint","lastDevicePoint","startDevicePoint","timestampedPoint","lastPoint","time","noop","any","convertBoundingBoxToAxisBox","min","max","convertAxisBoxToBoundingBox","transformBoundingBox","topLeft","bottomRight","axisBox","copyAxisBox","box","zeroDelta","translate","originPoint","eachAxis","clampProgress","clamp","isNear","maxDistance","calcLength","axis","calcOrigin","sourceLength","targetLength","updateAxisDelta","updateBoxDelta","defaultOrigin","calcRelativeAxis","relative","calcRelativeBox","parentProjection","relativeTarget","applyConstraints","elastic","calcConstrainedMinPoint","constraints","calcRelativeAxisConstraints","calcRelativeConstraints","layoutBox","calcViewportAxisConstraints","layoutAxis","constraintsAxis","calcViewportConstraints","constraintsBox","calcPositionFromProgress","axisLength","rebaseAxisConstraints","relativeConstraints","defaultElastic","resolveDragElastic","dragElastic","resolveAxisElastic","minLabel","maxLabel","resolvePointElastic","label","getBoundingBox","compareByDepth","depth","isProjecting","shouldResetTransform","collectProjectingAncestors","ancestors","collectProjectingChildren","children","addChild","updateLayoutMeasurement","getLayoutState","notifyBeforeLayoutMeasure","measureViewportBox","layoutCorrected","notifyLayoutMeasure","prevViewportBox","rebaseProjectionTarget","snapshotViewportBox","tweenAxis","calcRelativeOffsetAxis","calcRelativeOffset","checkIfParentHasChanged","prevId","getLayoutId","nextId","isDraggable","_dragX","resetAxis","originAxis","resetBox","originBox","scalePoint","distanceFromOrigin","scaled","applyPointDelta","boxScale","applyAxisDelta","applyBoxDelta","applyAxisTransforms","final","transforms","scaleKey","originKey","axisOrigin","xKeys","yKeys","applyBoxTransforms","finalBox","removePointDelta","removeAxisDelta","removeAxisTransforms","removeBoxTransforms","applyTreeDeltas","treePath","treeLength","node","getLatestValues","convertToRelativeProjection","isLayoutDrag","projectionParent","getProjectionParent","setProjectionTargetAxis","unresolvedJobs","pushJob","stack","job","pointer","batchLayout","flushLayout","reads","writes","setRead","setWrite","numStacks","executeJob","elementDragControls","WeakMap","lastPointerEvent","VisualElementDragControls","isDragging","currentDirection","hasMutatedConstraints","cursorProgress","openGlobalLock","panSession","enableLayoutProjection","originEvent","snapToCursor","stopMotion","initialPoint","cancelLayout","read","write","tree","hasManuallySetCursorOrigin","lockProjectionTarget","resetTransform","restoreTransform","isRelativeDrag","getAxisMotionValue","isExternalDrag","scheduleUpdateLayoutProjection","axisValue","flushSync","preRender","resolveDragConstraints","dragPropagation","onDragStart","dragDirectionLock","getCurrentDirection","onDirectionLock","updateAxis","onDrag","dragConstraints","resolveRefConstraints","onMeasureDragConstraints","constraintsElement","measuredConstraints","userConstraints","cancelDrag","unlockProjectionTarget","animateDragEnd","onDragEnd","shouldDrag","length_1","center","updateAxisMotionValue","updateVisualElementAxis","nextValue","axisLayout","axisProgress","_g","dragMomentum","remainingProps","dragKey","_dragY","dragTransition","isRelative","relativeConstraints_1","targetFinal","momentumAnimations","bounceStiffness","bounceDamping","timeConstant","startAxisValueAnimation","startLayoutAnimation","onDragTransitionEnd","stopLayoutAnimation","currentValue","boxProgress","updateConstraints","onReady","stopPointerListener","dragListener","stopResizeListener","stopLayoutUpdateListener","onLayoutUpdate","prevDragCursor","direction","lockThreshold","abs","useDrag","groupDragControls","dragControls","usePanGesture","onPan","onPanStart","onPanEnd","onPanSessionStart","hasPanEvents","Presence","VisibilityAction","isCSSVariable","cssVariableRegex","parseCSSVariable","match","exec","token","fallback","maxDepth","getVariableValue","getComputedStyle","getPropertyValue","resolveCSSVariables","HTMLElement","pixelsToPercent","pixels","correctBorderRadius","_layoutState","varToken","correctBoxShadow","original","containsCSSVariables","cssVariables","shadow","template","createTransformer","xScale","yScale","averageScale","output","i_1","cssVariable","borderCorrectionDefinition","defaultScaleCorrectors","boxShadow","progressTarget","_super","__extends","arguments","frameTarget","currentAnimationTarget","stopAxisAnimation","isAnimatingTree","targetBox","visibilityAction","shouldStackAnimate","prevParent","prevParentViewportBox","parentLayout","isProvidedCorrectDataForRelativeSharedLayout","boxHasMoved","hasMoved","isTargetLocked","setVisibility","Show","animateAxis","notifyLayoutAnimationComplete","componentDidMount","animateMotionValue","unsubLayoutReady","layoutSafeToRemove","componentWillUnmount","axisIsEqual","layoutProgress","getProjectionAnimationProgress","frame","unsubscribeProgress","layoutTransition","defaultLayoutTransition","AnimateLayoutContextProvider","isZeroBox","zeroAxis","defaultHandler","layoutReady","notifyLayoutReady","createBatcher","queue","flush","allElements","presence","Present","assignProjectionToSnapshot","SharedLayoutContext","FramerTreeLayoutContext","isSharedLayout","forceUpdate","Measure","syncLayout","framerSyncLayout","onUnmount","remove","getSnapshotBeforeUpdate","syncUpdate","componentDidUpdate","MeasureContextProvider","layoutAnimations","createProjectionState","createLayoutState","deltaTransform","zeroLayout","buildLayoutProjectionTransform","latestTransform","xTranslate","yTranslate","identityProjection","buildLayoutProjectionTransformOrigin","names","createLifecycles","managers","propSubscriptions","lifecycles","clearAllListeners","manager","updatePropListeners","on","propListener","args","_i","updateMotionValuesFromProps","prevValue","existingValue","getStaticValue","removeValue","updateLayoutDeltas","FlatTree","isDirty","setCurrentViewportBox","relativeOffset","treeType","build","renderInstance","readValueFromInstance","removeValueFromRenderState","leadProjection","leadLatestValues","unsubscribeFromLeadVisualElement","crossfader","hasViewportBoxUpdated","valueSubscriptions","prevMotionValues","projectionTargetProgress","baseTarget","removeFromVariantTree","isProjectionReady","triggerBuild","valuesToRender","crossfadedValues","getCrossfadeState","notifyUpdate","updateLayoutProjection","prevTreeScaleX","prevTreeScaleY","prevDeltaTransform","path","notifyViewportBoxUpdate","scheduleRender","updateTreeLayoutProjection","layoutTree","fireUpdateLayoutProjection","bindToMotionValue","removeOnChange","latestValue","removeOnRenderRequest","initialMotionValues","isVisible","isMounted","newInstance","pointTo","addVariantChild","closestVariantNode","getClosestVariantNode","other","setStaticValue","visibility","canMutate","defaultValue","newProps","startAtParent","context_1","numVariantProps","variantProps","setCrossfader","newCrossfader","withTransform","viewportBox","notifySetAxisTarget","force","shouldRebase","notifyLayoutUpdate","fireResolveRelativeTargetBox","foundParent","ancestor","resolveRelativeTargetBox","relativeParent","_layoutResetTransform","newLead","onSetAxisTarget","onLayoutAnimationComplete","Entering","positionalKeys","isPositionalKey","hasPositionalKey","setAndResetVelocity","isNumOrPxType","BoundingBoxDimension","getPosFromMatrix","matrix","pos","split","getTranslateFromMatrix","pos2","pos3","_bbox","matrix3d","nonTranslationalTransformKeys","removeNonTranslationalTransform","removedTransforms","positionalValues","convertChangedValueTypes","changedKeys","originBbox","elementComputedStyle","display","originComputedStyle","targetBbox","checkAndConvertChangedValueTypes","targetPositionalKeys","removedTransformValues","hasAttemptedToRemoveTransformValues","changedValueTypeKeys","fromType","toType","numKeyframes","convertedTarget","unitConversion","parseDomVariant","getComputedStyle$1","htmlConfig","domElement","defaultType","computedStyle","compareDocumentPosition","mutableState","parsed","isProjectionTranform","htmlVisualElement","svgVisualElement","getAttribute","_element","createDomVisualElement","featureBundle","motion","createDomMotionComponent","m","useForceUpdate","unloadingRef","useState","forcedRenderCount","setForcedRenderCount","getPresenceId","PresenceChild","presenceAffectsLayout","presenceChildren","newChildrenMap","childId","allComplete","isComplete","_","getChildKey","updateChildLookup","allChildren","seenChildren","console","warn","onlyElements","filtered","Children","isValidElement","AnimatePresence","exitBeforeEnter","forceRender","layoutContext","filteredChildren","presentChildren","exiting","childrenToRender","presentKeys","targetKeys","numPresent","insertionIndex","onExit","removeIndex","findIndex","presentChild","cloneElement","createCrossfader","lead","follow","crossfadeOpacity","preserveFollowOpacity","prevOptions","leadState","followState","finalCrossfadeFrame","prevUpdate","startCrossfadeAnimation","hasUpdated","updateCrossfade","latestLeadValues","latestFollowValues","prevValues","leadTargetOpacity","followTargetOpacity","easeCrossfadeIn","easeCrossfadeOut","mixValues","fromLead","toLead","initialProgress","reset","setOptions","newOptions","compress","easing","borders","numBorders","hasFollowElement","borderLabel","followRadius","getRadius","leadRadius","mixColor","radiusName","layoutStack","leadIsExiting","prevState","needsCrossfadeAnimation","getFollowViewportBox","getFollowLayout","getLead","updateSnapshot","clearSnapshot","updateLeadAndFollow","Exiting","shouldCrossfade","resetRotate","hasRotate","resetValues","AnimateSharedLayout","stacks","hasMounted","updateScheduled","renderScheduled","syncContext","scheduleUpdate","removeChild","shouldComponentUpdate","updateStacks","getStack","addToStack","removeFromStack","contextType","MotionConfig","transitionDependency","toString","LazyMotion","isLazyBundle","setIsLoaded","loadedRenderer","loadedFeatures","domAnimation","domMax","useMotionValue","setLatest_1","useOnChange","useMultiOnChange","unsubscribe","useCombineMotionValues","combineValues","updateValue","useMotionTemplate","fragments","numFragments","buildValue","isCustomValueType","getMixer","useImmediate","argOffset","inputValue","inputRange","outputRange","interpolator","interpolate","mixer","useTransform","input","inputRangeOrTransformer","transformer","useListTransform","numValues","useSpring","activeSpringAnimation","useVelocity","newVelocity","createScrollMotionValues","scrollX","scrollY","scrollXProgress","scrollYProgress","setProgress","maxOffset","createScrollUpdater","getOffsets","xOffset","yOffset","xMaxOffset","yMaxOffset","getElementScrollOffsets","scrollLeft","scrollTop","scrollWidth","offsetWidth","scrollHeight","offsetHeight","useElementScroll","updateScrollValues","scrollListener","passive","resizeListener","viewportScrollValues","getViewportScrollOffsets","pageXOffset","pageYOffset","document","body","clientWidth","innerWidth","clientHeight","innerHeight","hasListeners","addEventListeners","useViewportScroll","prefersReducedMotion","initPrefersReducedMotion","matchMedia","motionMediaQuery_1","setReducedMotionPreferences","matches","addListener","useReducedMotion","shouldReduceMotion","setShouldReduceMotion","animationControls","pendingAnimations","subscribers","animations_1","useAnimation","useCycle","items","setItem","wrap","DragControls","componentControls","nativeEvent","createDragControls","useDragControls","createObject","stateVisualElement","_state","initialState","useAnimatedState","setAnimationState","animationDefinition","maxScale","invertScale","hasWarned","useInvertedScale","parentScaleX","parentScaleY","useDeprecatedAnimatedState","useDeprecatedInvertedScale"],"sources":["/Users/arshadyaseen/Desktop/ReactFromValidator/form-validation-react/node_modules/framer-motion/dist/framer-motion.cjs.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar tslib = require('tslib');\nvar React = require('react');\nvar heyListen = require('hey-listen');\nvar styleValueTypes = require('style-value-types');\nvar popmotion = require('popmotion');\nvar sync = require('framesync');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function (k) {\n            if (k !== 'default') {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function () {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n['default'] = e;\n    return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\nvar React__default = /*#__PURE__*/_interopDefaultLegacy(React);\nvar sync__default = /*#__PURE__*/_interopDefaultLegacy(sync);\n\nvar createDefinition = function (propNames) { return ({\n    isEnabled: function (props) { return propNames.some(function (name) { return !!props[name]; }); },\n}); };\nvar featureDefinitions = {\n    measureLayout: createDefinition([\n        \"layout\",\n        \"layoutId\",\n        \"drag\",\n        \"_layoutResetTransform\",\n    ]),\n    animation: createDefinition([\n        \"animate\",\n        \"exit\",\n        \"variants\",\n        \"whileHover\",\n        \"whileTap\",\n        \"whileFocus\",\n        \"whileDrag\",\n    ]),\n    exit: createDefinition([\"exit\"]),\n    drag: createDefinition([\"drag\", \"dragControls\"]),\n    focus: createDefinition([\"whileFocus\"]),\n    hover: createDefinition([\"whileHover\", \"onHoverStart\", \"onHoverEnd\"]),\n    tap: createDefinition([\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"]),\n    pan: createDefinition([\n        \"onPan\",\n        \"onPanStart\",\n        \"onPanSessionStart\",\n        \"onPanEnd\",\n    ]),\n    layoutAnimation: createDefinition([\"layout\", \"layoutId\"]),\n};\nfunction loadFeatures(features) {\n    for (var key in features) {\n        var Component = features[key];\n        if (Component !== null)\n            featureDefinitions[key].Component = Component;\n    }\n}\n\nvar LazyContext = React.createContext({ strict: false });\n\nvar featureNames = Object.keys(featureDefinitions);\nvar numFeatures = featureNames.length;\n/**\n * Load features via renderless components based on the provided MotionProps.\n */\nfunction useFeatures(props, visualElement, preloadedFeatures) {\n    var features = [];\n    var lazyContext = React.useContext(LazyContext);\n    if (!visualElement)\n        return null;\n    /**\n     * If we're in development mode, check to make sure we're not rendering a motion component\n     * as a child of LazyMotion, as this will break the file-size benefits of using it.\n     */\n    if (process.env.NODE_ENV !== \"production\" &&\n        preloadedFeatures &&\n        lazyContext.strict) {\n        heyListen.invariant(false, \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\");\n    }\n    for (var i = 0; i < numFeatures; i++) {\n        var name_1 = featureNames[i];\n        var _a = featureDefinitions[name_1], isEnabled = _a.isEnabled, Component = _a.Component;\n        /**\n         * It might be possible in the future to use this moment to\n         * dynamically request functionality. In initial tests this\n         * was producing a lot of duplication amongst bundles.\n         */\n        if (isEnabled(props) && Component) {\n            features.push(React__namespace.createElement(Component, tslib.__assign({ key: name_1 }, props, { visualElement: visualElement })));\n        }\n    }\n    return features;\n}\n\n/**\n * @public\n */\nvar MotionConfigContext = React.createContext({\n    transformPagePoint: function (p) { return p; },\n    isStatic: false,\n});\n\nvar MotionContext = React.createContext({});\nfunction useVisualElementContext() {\n    return React.useContext(MotionContext).visualElement;\n}\n\n/**\n * @public\n */\nvar PresenceContext = React.createContext(null);\n\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don't execute twice or more.\n */\nfunction useConstant(init) {\n    var ref = React.useRef(null);\n    if (ref.current === null) {\n        ref.current = init();\n    }\n    return ref.current;\n}\n\n/**\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\n * to access information about whether it's still present in the React tree.\n *\n * ```jsx\n * import { usePresence } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const [isPresent, safeToRemove] = usePresence()\n *\n *   useEffect(() => {\n *     !isPresent && setTimeout(safeToRemove, 1000)\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\n *\n * @public\n */\nfunction usePresence() {\n    var context = React.useContext(PresenceContext);\n    if (context === null)\n        return [true, null];\n    var isPresent = context.isPresent, onExitComplete = context.onExitComplete, register = context.register;\n    // It's safe to call the following hooks conditionally (after an early return) because the context will always\n    // either be null or non-null for the lifespan of the component.\n    // Replace with useOpaqueId when released in React\n    var id = useUniqueId();\n    React.useEffect(function () { return register(id); }, []);\n    var safeToRemove = function () { return onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete(id); };\n    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\n}\n/**\n * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.\n * There is no `safeToRemove` function.\n *\n * ```jsx\n * import { useIsPresent } from \"framer-motion\"\n *\n * export const Component = () => {\n *   const isPresent = useIsPresent()\n *\n *   useEffect(() => {\n *     !isPresent && console.log(\"I've been removed!\")\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * @public\n */\nfunction useIsPresent() {\n    return isPresent(React.useContext(PresenceContext));\n}\nfunction isPresent(context) {\n    return context === null ? true : context.isPresent;\n}\nvar counter = 0;\nvar incrementId = function () { return counter++; };\nvar useUniqueId = function () { return useConstant(incrementId); };\n\n/**\n * @internal\n */\nvar LayoutGroupContext = React.createContext(null);\n\nvar isBrowser = typeof window !== \"undefined\";\n\nvar useIsomorphicLayoutEffect = isBrowser ? React.useLayoutEffect : React.useEffect;\n\nfunction useLayoutId(_a) {\n    var layoutId = _a.layoutId;\n    var layoutGroupId = React.useContext(LayoutGroupContext);\n    return layoutGroupId && layoutId !== undefined\n        ? layoutGroupId + \"-\" + layoutId\n        : layoutId;\n}\nfunction useVisualElement(Component, visualState, props, createVisualElement) {\n    var config = React.useContext(MotionConfigContext);\n    var lazyContext = React.useContext(LazyContext);\n    var parent = useVisualElementContext();\n    var presenceContext = React.useContext(PresenceContext);\n    var layoutId = useLayoutId(props);\n    var visualElementRef = React.useRef(undefined);\n    /**\n     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n     */\n    if (!createVisualElement)\n        createVisualElement = lazyContext.renderer;\n    if (!visualElementRef.current && createVisualElement) {\n        visualElementRef.current = createVisualElement(Component, {\n            visualState: visualState,\n            parent: parent,\n            props: tslib.__assign(tslib.__assign({}, props), { layoutId: layoutId }),\n            presenceId: presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id,\n            blockInitialAnimation: (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false,\n        });\n    }\n    var visualElement = visualElementRef.current;\n    useIsomorphicLayoutEffect(function () {\n        if (!visualElement)\n            return;\n        visualElement.setProps(tslib.__assign(tslib.__assign(tslib.__assign({}, config), props), { layoutId: layoutId }));\n        visualElement.isPresent = isPresent(presenceContext);\n        visualElement.isPresenceRoot =\n            !parent || parent.presenceId !== (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id);\n        /**\n         * Fire a render to ensure the latest state is reflected on-screen.\n         */\n        visualElement.syncRender();\n    });\n    React.useEffect(function () {\n        var _a;\n        if (!visualElement)\n            return;\n        /**\n         * In a future refactor we can replace the features-as-components and\n         * have this loop through them all firing \"effect\" listeners\n         */\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.animateChanges();\n    });\n    useIsomorphicLayoutEffect(function () { return function () { return visualElement === null || visualElement === void 0 ? void 0 : visualElement.notifyUnmount(); }; }, []);\n    return visualElement;\n}\n\nfunction isRefObject(ref) {\n    return (typeof ref === \"object\" &&\n        Object.prototype.hasOwnProperty.call(ref, \"current\"));\n}\n\n/**\n * Creates a ref function that, when called, hydrates the provided\n * external ref and VisualElement.\n */\nfunction useMotionRef(visualState, visualElement, externalRef) {\n    return React.useCallback(function (instance) {\n        var _a;\n        instance && ((_a = visualState.mount) === null || _a === void 0 ? void 0 : _a.call(visualState, instance));\n        if (visualElement) {\n            instance\n                ? visualElement.mount(instance)\n                : visualElement.unmount();\n        }\n        if (externalRef) {\n            if (typeof externalRef === \"function\") {\n                externalRef(instance);\n            }\n            else if (isRefObject(externalRef)) {\n                externalRef.current = instance;\n            }\n        }\n    }, \n    /**\n     * Only pass a new ref callback to React if we've received a visual element\n     * factory. Otherwise we'll be mounting/remounting every time externalRef\n     * or other dependencies change.\n     */\n    [visualElement]);\n}\n\n/**\n * Decides if the supplied variable is an array of variant labels\n */\nfunction isVariantLabels(v) {\n    return Array.isArray(v);\n}\n/**\n * Decides if the supplied variable is variant label\n */\nfunction isVariantLabel(v) {\n    return typeof v === \"string\" || isVariantLabels(v);\n}\n/**\n * Creates an object containing the latest state of every MotionValue on a VisualElement\n */\nfunction getCurrent(visualElement) {\n    var current = {};\n    visualElement.forEachValue(function (value, key) { return (current[key] = value.get()); });\n    return current;\n}\n/**\n * Creates an object containing the latest velocity of every MotionValue on a VisualElement\n */\nfunction getVelocity$1(visualElement) {\n    var velocity = {};\n    visualElement.forEachValue(function (value, key) { return (velocity[key] = value.getVelocity()); });\n    return velocity;\n}\nfunction resolveVariantFromProps(props, definition, custom, currentValues, currentVelocity) {\n    var _a;\n    if (currentValues === void 0) { currentValues = {}; }\n    if (currentVelocity === void 0) { currentVelocity = {}; }\n    if (typeof definition === \"string\") {\n        definition = (_a = props.variants) === null || _a === void 0 ? void 0 : _a[definition];\n    }\n    return typeof definition === \"function\"\n        ? definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity)\n        : definition;\n}\nfunction resolveVariant(visualElement, definition, custom) {\n    var props = visualElement.getProps();\n    return resolveVariantFromProps(props, definition, custom !== null && custom !== void 0 ? custom : props.custom, getCurrent(visualElement), getVelocity$1(visualElement));\n}\nfunction checkIfControllingVariants(props) {\n    var _a;\n    return (typeof ((_a = props.animate) === null || _a === void 0 ? void 0 : _a.start) === \"function\" ||\n        isVariantLabel(props.initial) ||\n        isVariantLabel(props.animate) ||\n        isVariantLabel(props.whileHover) ||\n        isVariantLabel(props.whileDrag) ||\n        isVariantLabel(props.whileTap) ||\n        isVariantLabel(props.whileFocus) ||\n        isVariantLabel(props.exit));\n}\nfunction checkIfVariantNode(props) {\n    return Boolean(checkIfControllingVariants(props) || props.variants);\n}\n\nfunction getCurrentTreeVariants(props, context) {\n    if (checkIfControllingVariants(props)) {\n        var initial = props.initial, animate = props.animate;\n        return {\n            initial: initial === false || isVariantLabel(initial)\n                ? initial\n                : undefined,\n            animate: isVariantLabel(animate) ? animate : undefined,\n        };\n    }\n    return props.inherit !== false ? context : {};\n}\n\nfunction useCreateMotionContext(props, isStatic) {\n    var _a = getCurrentTreeVariants(props, React.useContext(MotionContext)), initial = _a.initial, animate = _a.animate;\n    return React.useMemo(function () { return ({ initial: initial, animate: animate }); }, \n    /**\n     * Only break memoisation in static mode\n     */\n    isStatic\n        ? [\n            variantLabelsAsDependency(initial),\n            variantLabelsAsDependency(animate),\n        ]\n        : []);\n}\nfunction variantLabelsAsDependency(prop) {\n    return Array.isArray(prop) ? prop.join(\" \") : prop;\n}\n\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n *\n * @internal\n */\nfunction createMotionComponent(_a) {\n    var preloadedFeatures = _a.preloadedFeatures, createVisualElement = _a.createVisualElement, useRender = _a.useRender, useVisualState = _a.useVisualState, Component = _a.Component;\n    preloadedFeatures && loadFeatures(preloadedFeatures);\n    function MotionComponent(props, externalRef) {\n        /**\n         * If we're rendering in a static environment, we only visually update the component\n         * as a result of a React-rerender rather than interactions or animations. This\n         * means we don't need to load additional memory structures like VisualElement,\n         * or any gesture/animation features.\n         */\n        var isStatic = React.useContext(MotionConfigContext).isStatic;\n        var features = null;\n        /**\n         * Create the tree context. This is memoized and will only trigger renders\n         * when the current tree variant changes in static mode.\n         */\n        var context = useCreateMotionContext(props, isStatic);\n        /**\n         *\n         */\n        var visualState = useVisualState(props, isStatic);\n        if (!isStatic && isBrowser) {\n            /**\n             * Create a VisualElement for this component. A VisualElement provides a common\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n             * providing a way of rendering to these APIs outside of the React render loop\n             * for more performant animations and interactions\n             */\n            context.visualElement = useVisualElement(Component, visualState, props, createVisualElement);\n            /**\n             * Load Motion gesture and animation features. These are rendered as renderless\n             * components so each feature can optionally make use of React lifecycle methods.\n             *\n             * TODO: The intention is to move these away from a React-centric to a\n             * VisualElement-centric lifecycle scheme.\n             */\n            features = useFeatures(props, context.visualElement, preloadedFeatures);\n        }\n        /**\n         * The mount order and hierarchy is specific to ensure our element ref\n         * is hydrated by the time features fire their effects.\n         */\n        return (React__namespace.createElement(React__namespace.Fragment, null,\n            React__namespace.createElement(MotionContext.Provider, { value: context }, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic)),\n            features));\n    }\n    return React.forwardRef(MotionComponent);\n}\n\n/**\n * Convert any React component into a `motion` component. The provided component\n * **must** use `React.forwardRef` to the underlying DOM component you want to animate.\n *\n * ```jsx\n * const Component = React.forwardRef((props, ref) => {\n *   return <div ref={ref} />\n * })\n *\n * const MotionComponent = motion(Component)\n * ```\n *\n * @public\n */\nfunction createMotionProxy(createConfig) {\n    function custom(Component, customMotionComponentConfig) {\n        if (customMotionComponentConfig === void 0) { customMotionComponentConfig = {}; }\n        return createMotionComponent(createConfig(Component, customMotionComponentConfig));\n    }\n    /**\n     * A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.\n     * Rather than generating them anew every render.\n     */\n    var componentCache = new Map();\n    return new Proxy(custom, {\n        /**\n         * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.\n         * The prop name is passed through as `key` and we can use that to generate a `motion`\n         * DOM component with that name.\n         */\n        get: function (_target, key) {\n            /**\n             * If this element doesn't exist in the component cache, create it and cache.\n             */\n            if (!componentCache.has(key)) {\n                componentCache.set(key, custom(key));\n            }\n            return componentCache.get(key);\n        },\n    });\n}\n\n/**\n * We keep these listed seperately as we use the lowercase tag names as part\n * of the runtime bundle to detect SVG components\n */\nvar lowercaseSVGElements = [\n    \"animate\",\n    \"circle\",\n    \"defs\",\n    \"desc\",\n    \"ellipse\",\n    \"g\",\n    \"image\",\n    \"line\",\n    \"filter\",\n    \"marker\",\n    \"mask\",\n    \"metadata\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"rect\",\n    \"stop\",\n    \"svg\",\n    \"switch\",\n    \"symbol\",\n    \"text\",\n    \"tspan\",\n    \"use\",\n    \"view\",\n];\n\nfunction isSVGComponent(Component) {\n    if (\n    /**\n     * If it's not a string, it's a custom React component. Currently we only support\n     * HTML custom React components.\n     */\n    typeof Component !== \"string\" ||\n        /**\n         * If it contains a dash, the element is a custom HTML webcomponent.\n         */\n        Component.includes(\"-\")) {\n        return false;\n    }\n    else if (\n    /**\n     * If it's in our list of lowercase SVG tags, it's an SVG component\n     */\n    lowercaseSVGElements.indexOf(Component) > -1 ||\n        /**\n         * If it contains a capital letter, it's an SVG component\n         */\n        /[A-Z]/.test(Component)) {\n        return true;\n    }\n    return false;\n}\n\nvar valueScaleCorrection = {};\n/**\n * @internal\n */\nfunction addScaleCorrection(correctors) {\n    for (var key in correctors) {\n        valueScaleCorrection[key] = correctors[key];\n    }\n}\n\n/**\n * A list of all transformable axes. We'll use this list to generated a version\n * of each axes for each transform.\n */\nvar transformAxes = [\"\", \"X\", \"Y\", \"Z\"];\n/**\n * An ordered array of each transformable value. By default, transform values\n * will be sorted to this order.\n */\nvar order = [\"translate\", \"scale\", \"rotate\", \"skew\"];\n/**\n * Generate a list of every possible transform key.\n */\nvar transformProps = [\"transformPerspective\", \"x\", \"y\", \"z\"];\norder.forEach(function (operationKey) {\n    return transformAxes.forEach(function (axesKey) {\n        return transformProps.push(operationKey + axesKey);\n    });\n});\n/**\n * A function to use with Array.sort to sort transform keys by their default order.\n */\nfunction sortTransformProps(a, b) {\n    return transformProps.indexOf(a) - transformProps.indexOf(b);\n}\n/**\n * A quick lookup for transform props.\n */\nvar transformPropSet = new Set(transformProps);\nfunction isTransformProp(key) {\n    return transformPropSet.has(key);\n}\n/**\n * A quick lookup for transform origin props\n */\nvar transformOriginProps = new Set([\"originX\", \"originY\", \"originZ\"]);\nfunction isTransformOriginProp(key) {\n    return transformOriginProps.has(key);\n}\n\nfunction isForcedMotionValue(key, _a) {\n    var layout = _a.layout, layoutId = _a.layoutId;\n    return (isTransformProp(key) ||\n        isTransformOriginProp(key) ||\n        ((layout || layoutId !== undefined) &&\n            (!!valueScaleCorrection[key] || key === \"opacity\")));\n}\n\nvar isMotionValue = function (value) {\n    return value !== null && typeof value === \"object\" && value.getVelocity;\n};\n\nvar translateAlias = {\n    x: \"translateX\",\n    y: \"translateY\",\n    z: \"translateZ\",\n    transformPerspective: \"perspective\",\n};\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\nfunction buildTransform(_a, _b, transformIsDefault, transformTemplate) {\n    var transform = _a.transform, transformKeys = _a.transformKeys;\n    var _c = _b.enableHardwareAcceleration, enableHardwareAcceleration = _c === void 0 ? true : _c, _d = _b.allowTransformNone, allowTransformNone = _d === void 0 ? true : _d;\n    // The transform string we're going to build into.\n    var transformString = \"\";\n    // Transform keys into their default order - this will determine the output order.\n    transformKeys.sort(sortTransformProps);\n    // Track whether the defined transform has a defined z so we don't add a\n    // second to enable hardware acceleration\n    var transformHasZ = false;\n    // Loop over each transform and build them into transformString\n    var numTransformKeys = transformKeys.length;\n    for (var i = 0; i < numTransformKeys; i++) {\n        var key = transformKeys[i];\n        transformString += (translateAlias[key] || key) + \"(\" + transform[key] + \") \";\n        if (key === \"z\")\n            transformHasZ = true;\n    }\n    if (!transformHasZ && enableHardwareAcceleration) {\n        transformString += \"translateZ(0)\";\n    }\n    else {\n        transformString = transformString.trim();\n    }\n    // If we have a custom `transform` template, pass our transform values and\n    // generated transformString to that before returning\n    if (transformTemplate) {\n        transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n    }\n    else if (allowTransformNone && transformIsDefault) {\n        transformString = \"none\";\n    }\n    return transformString;\n}\n/**\n * Build a transformOrigin style. Uses the same defaults as the browser for\n * undefined origins.\n */\nfunction buildTransformOrigin(_a) {\n    var _b = _a.originX, originX = _b === void 0 ? \"50%\" : _b, _c = _a.originY, originY = _c === void 0 ? \"50%\" : _c, _d = _a.originZ, originZ = _d === void 0 ? 0 : _d;\n    return originX + \" \" + originY + \" \" + originZ;\n}\n\n/**\n * Returns true if the provided key is a CSS variable\n */\nfunction isCSSVariable$1(key) {\n    return key.startsWith(\"--\");\n}\n\n/**\n * Provided a value and a ValueType, returns the value as that value type.\n */\nvar getValueAsType = function (value, type) {\n    return type && typeof value === \"number\"\n        ? type.transform(value)\n        : value;\n};\n\nvar int = tslib.__assign(tslib.__assign({}, styleValueTypes.number), { transform: Math.round });\n\nvar numberValueTypes = {\n    // Border props\n    borderWidth: styleValueTypes.px,\n    borderTopWidth: styleValueTypes.px,\n    borderRightWidth: styleValueTypes.px,\n    borderBottomWidth: styleValueTypes.px,\n    borderLeftWidth: styleValueTypes.px,\n    borderRadius: styleValueTypes.px,\n    radius: styleValueTypes.px,\n    borderTopLeftRadius: styleValueTypes.px,\n    borderTopRightRadius: styleValueTypes.px,\n    borderBottomRightRadius: styleValueTypes.px,\n    borderBottomLeftRadius: styleValueTypes.px,\n    // Positioning props\n    width: styleValueTypes.px,\n    maxWidth: styleValueTypes.px,\n    height: styleValueTypes.px,\n    maxHeight: styleValueTypes.px,\n    size: styleValueTypes.px,\n    top: styleValueTypes.px,\n    right: styleValueTypes.px,\n    bottom: styleValueTypes.px,\n    left: styleValueTypes.px,\n    // Spacing props\n    padding: styleValueTypes.px,\n    paddingTop: styleValueTypes.px,\n    paddingRight: styleValueTypes.px,\n    paddingBottom: styleValueTypes.px,\n    paddingLeft: styleValueTypes.px,\n    margin: styleValueTypes.px,\n    marginTop: styleValueTypes.px,\n    marginRight: styleValueTypes.px,\n    marginBottom: styleValueTypes.px,\n    marginLeft: styleValueTypes.px,\n    // Transform props\n    rotate: styleValueTypes.degrees,\n    rotateX: styleValueTypes.degrees,\n    rotateY: styleValueTypes.degrees,\n    rotateZ: styleValueTypes.degrees,\n    scale: styleValueTypes.scale,\n    scaleX: styleValueTypes.scale,\n    scaleY: styleValueTypes.scale,\n    scaleZ: styleValueTypes.scale,\n    skew: styleValueTypes.degrees,\n    skewX: styleValueTypes.degrees,\n    skewY: styleValueTypes.degrees,\n    distance: styleValueTypes.px,\n    translateX: styleValueTypes.px,\n    translateY: styleValueTypes.px,\n    translateZ: styleValueTypes.px,\n    x: styleValueTypes.px,\n    y: styleValueTypes.px,\n    z: styleValueTypes.px,\n    perspective: styleValueTypes.px,\n    transformPerspective: styleValueTypes.px,\n    opacity: styleValueTypes.alpha,\n    originX: styleValueTypes.progressPercentage,\n    originY: styleValueTypes.progressPercentage,\n    originZ: styleValueTypes.px,\n    // Misc\n    zIndex: int,\n    // SVG\n    fillOpacity: styleValueTypes.alpha,\n    strokeOpacity: styleValueTypes.alpha,\n    numOctaves: int,\n};\n\nfunction buildHTMLStyles(state, latestValues, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin) {\n    var _a;\n    var style = state.style, vars = state.vars, transform = state.transform, transformKeys = state.transformKeys, transformOrigin = state.transformOrigin;\n    // Empty the transformKeys array. As we're throwing out refs to its items\n    // this might not be as cheap as suspected. Maybe using the array as a buffer\n    // with a manual incrementation would be better.\n    transformKeys.length = 0;\n    // Track whether we encounter any transform or transformOrigin values.\n    var hasTransform = false;\n    var hasTransformOrigin = false;\n    // Does the calculated transform essentially equal \"none\"?\n    var transformIsNone = true;\n    /**\n     * Loop over all our latest animated values and decide whether to handle them\n     * as a style or CSS variable.\n     *\n     * Transforms and transform origins are kept seperately for further processing.\n     */\n    for (var key in latestValues) {\n        var value = latestValues[key];\n        /**\n         * If this is a CSS variable we don't do any further processing.\n         */\n        if (isCSSVariable$1(key)) {\n            vars[key] = value;\n            continue;\n        }\n        // Convert the value to its default value type, ie 0 -> \"0px\"\n        var valueType = numberValueTypes[key];\n        var valueAsType = getValueAsType(value, valueType);\n        if (isTransformProp(key)) {\n            // If this is a transform, flag to enable further transform processing\n            hasTransform = true;\n            transform[key] = valueAsType;\n            transformKeys.push(key);\n            // If we already know we have a non-default transform, early return\n            if (!transformIsNone)\n                continue;\n            // Otherwise check to see if this is a default transform\n            if (value !== ((_a = valueType.default) !== null && _a !== void 0 ? _a : 0))\n                transformIsNone = false;\n        }\n        else if (isTransformOriginProp(key)) {\n            transformOrigin[key] = valueAsType;\n            // If this is a transform origin, flag and enable further transform-origin processing\n            hasTransformOrigin = true;\n        }\n        else {\n            /**\n             * If layout projection is on, and we need to perform scale correction for this\n             * value type, perform it.\n             */\n            if ((projection === null || projection === void 0 ? void 0 : projection.isHydrated) &&\n                (layoutState === null || layoutState === void 0 ? void 0 : layoutState.isHydrated) &&\n                valueScaleCorrection[key]) {\n                var correctedValue = valueScaleCorrection[key].process(value, layoutState, projection);\n                /**\n                 * Scale-correctable values can define a number of other values to break\n                 * down into. For instance borderRadius needs applying to borderBottomLeftRadius etc\n                 */\n                var applyTo = valueScaleCorrection[key].applyTo;\n                if (applyTo) {\n                    var num = applyTo.length;\n                    for (var i = 0; i < num; i++) {\n                        style[applyTo[i]] = correctedValue;\n                    }\n                }\n                else {\n                    style[key] = correctedValue;\n                }\n            }\n            else {\n                style[key] = valueAsType;\n            }\n        }\n    }\n    if (layoutState &&\n        projection &&\n        buildProjectionTransform &&\n        buildProjectionTransformOrigin) {\n        style.transform = buildProjectionTransform(layoutState.deltaFinal, layoutState.treeScale, hasTransform ? transform : undefined);\n        if (transformTemplate) {\n            style.transform = transformTemplate(transform, style.transform);\n        }\n        style.transformOrigin = buildProjectionTransformOrigin(layoutState);\n    }\n    else {\n        if (hasTransform) {\n            style.transform = buildTransform(state, options, transformIsNone, transformTemplate);\n        }\n        if (hasTransformOrigin) {\n            style.transformOrigin = buildTransformOrigin(transformOrigin);\n        }\n    }\n}\n\nvar createHtmlRenderState = function () { return ({\n    style: {},\n    transform: {},\n    transformKeys: [],\n    transformOrigin: {},\n    vars: {},\n}); };\n\nfunction copyRawValuesOnly(target, source, props) {\n    for (var key in source) {\n        if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n            target[key] = source[key];\n        }\n    }\n}\nfunction useInitialMotionValues(_a, visualState, isStatic) {\n    var transformTemplate = _a.transformTemplate;\n    return React.useMemo(function () {\n        var state = createHtmlRenderState();\n        buildHTMLStyles(state, visualState, undefined, undefined, { enableHardwareAcceleration: !isStatic }, transformTemplate);\n        var vars = state.vars, style = state.style;\n        return tslib.__assign(tslib.__assign({}, vars), style);\n    }, [visualState]);\n}\nfunction useStyle(props, visualState, isStatic) {\n    var styleProp = props.style || {};\n    var style = {};\n    /**\n     * Copy non-Motion Values straight into style\n     */\n    copyRawValuesOnly(style, styleProp, props);\n    Object.assign(style, useInitialMotionValues(props, visualState, isStatic));\n    if (props.transformValues) {\n        style = props.transformValues(style);\n    }\n    return style;\n}\nfunction useHTMLProps(props, visualState, isStatic) {\n    // The `any` isn't ideal but it is the type of createElement props argument\n    var htmlProps = {};\n    var style = useStyle(props, visualState, isStatic);\n    if (Boolean(props.drag)) {\n        // Disable the ghost element when a user drags\n        htmlProps.draggable = false;\n        // Disable text selection\n        style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout =\n            \"none\";\n        // Disable scrolling on the draggable direction\n        style.touchAction =\n            props.drag === true\n                ? \"none\"\n                : \"pan-\" + (props.drag === \"x\" ? \"y\" : \"x\");\n    }\n    htmlProps.style = style;\n    return htmlProps;\n}\n\n/**\n * A list of all valid MotionProps.\n *\n * @internalremarks\n * This doesn't throw if a `MotionProp` name is missing - it should.\n */\nvar validMotionProps = new Set([\n    \"initial\",\n    \"animate\",\n    \"exit\",\n    \"style\",\n    \"variants\",\n    \"transition\",\n    \"transformTemplate\",\n    \"transformValues\",\n    \"custom\",\n    \"inherit\",\n    \"layout\",\n    \"layoutId\",\n    \"_layoutResetTransform\",\n    \"onLayoutAnimationComplete\",\n    \"onViewportBoxUpdate\",\n    \"onLayoutMeasure\",\n    \"onBeforeLayoutMeasure\",\n    \"onAnimationStart\",\n    \"onAnimationComplete\",\n    \"onUpdate\",\n    \"onDragStart\",\n    \"onDrag\",\n    \"onDragEnd\",\n    \"onMeasureDragConstraints\",\n    \"onDirectionLock\",\n    \"onDragTransitionEnd\",\n    \"drag\",\n    \"dragControls\",\n    \"dragListener\",\n    \"dragConstraints\",\n    \"dragDirectionLock\",\n    \"_dragX\",\n    \"_dragY\",\n    \"dragElastic\",\n    \"dragMomentum\",\n    \"dragPropagation\",\n    \"dragTransition\",\n    \"whileDrag\",\n    \"onPan\",\n    \"onPanStart\",\n    \"onPanEnd\",\n    \"onPanSessionStart\",\n    \"onTap\",\n    \"onTapStart\",\n    \"onTapCancel\",\n    \"onHoverStart\",\n    \"onHoverEnd\",\n    \"whileFocus\",\n    \"whileTap\",\n    \"whileHover\",\n]);\n/**\n * Check whether a prop name is a valid `MotionProp` key.\n *\n * @param key - Name of the property to check\n * @returns `true` is key is a valid `MotionProp`.\n *\n * @public\n */\nfunction isValidMotionProp(key) {\n    return validMotionProps.has(key);\n}\n\nvar shouldForward = function (key) { return !isValidMotionProp(key); };\n/**\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\n * of these should be passed to the underlying DOM node.\n *\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\n *\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\n * actually required.\n */\ntry {\n    var emotionIsPropValid_1 = require(\"@emotion/is-prop-valid\").default;\n    shouldForward = function (key) {\n        // Handle events explicitly as Emotion validates them all as true\n        if (key.startsWith(\"on\")) {\n            return !isValidMotionProp(key);\n        }\n        else {\n            return emotionIsPropValid_1(key);\n        }\n    };\n}\ncatch (_a) {\n    // We don't need to actually do anything here - the fallback is the existing `isPropValid`.\n}\nfunction filterProps(props, isDom, forwardMotionProps) {\n    var filteredProps = {};\n    for (var key in props) {\n        if (shouldForward(key) ||\n            (forwardMotionProps === true && isValidMotionProp(key)) ||\n            (!isDom && !isValidMotionProp(key))) {\n            filteredProps[key] = props[key];\n        }\n    }\n    return filteredProps;\n}\n\nfunction calcOrigin$1(origin, offset, size) {\n    return typeof origin === \"string\"\n        ? origin\n        : styleValueTypes.px.transform(offset + size * origin);\n}\n/**\n * The SVG transform origin defaults are different to CSS and is less intuitive,\n * so we use the measured dimensions of the SVG to reconcile these.\n */\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n    var pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);\n    var pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);\n    return pxOriginX + \" \" + pxOriginY;\n}\n\n// Convert a progress 0-1 to a pixels value based on the provided length\nvar progressToPixels = function (progress, length) {\n    return styleValueTypes.px.transform(progress * length);\n};\nvar dashKeys = {\n    offset: \"stroke-dashoffset\",\n    array: \"stroke-dasharray\",\n};\nvar camelKeys = {\n    offset: \"strokeDashoffset\",\n    array: \"strokeDasharray\",\n};\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */\nfunction buildSVGPath(attrs, totalLength, length, spacing, offset, useDashCase) {\n    if (spacing === void 0) { spacing = 1; }\n    if (offset === void 0) { offset = 0; }\n    if (useDashCase === void 0) { useDashCase = true; }\n    // We use dash case when setting attributes directly to the DOM node and camel case\n    // when defining props on a React component.\n    var keys = useDashCase ? dashKeys : camelKeys;\n    // Build the dash offset\n    attrs[keys.offset] = progressToPixels(-offset, totalLength);\n    // Build the dash array\n    var pathLength = progressToPixels(length, totalLength);\n    var pathSpacing = progressToPixels(spacing, totalLength);\n    attrs[keys.array] = pathLength + \" \" + pathSpacing;\n}\n\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */\nfunction buildSVGAttrs(state, _a, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin) {\n    var attrX = _a.attrX, attrY = _a.attrY, originX = _a.originX, originY = _a.originY, pathLength = _a.pathLength, _b = _a.pathSpacing, pathSpacing = _b === void 0 ? 1 : _b, _c = _a.pathOffset, pathOffset = _c === void 0 ? 0 : _c, \n    // This is object creation, which we try to avoid per-frame.\n    latest = tslib.__rest(_a, [\"attrX\", \"attrY\", \"originX\", \"originY\", \"pathLength\", \"pathSpacing\", \"pathOffset\"]);\n    buildHTMLStyles(state, latest, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin);\n    state.attrs = state.style;\n    state.style = {};\n    var attrs = state.attrs, style = state.style, dimensions = state.dimensions, totalPathLength = state.totalPathLength;\n    /**\n     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n     * and copy it into style.\n     */\n    if (attrs.transform) {\n        if (dimensions)\n            style.transform = attrs.transform;\n        delete attrs.transform;\n    }\n    // Parse transformOrigin\n    if (dimensions &&\n        (originX !== undefined || originY !== undefined || style.transform)) {\n        style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n    }\n    // Treat x/y not as shortcuts but as actual attributes\n    if (attrX !== undefined)\n        attrs.x = attrX;\n    if (attrY !== undefined)\n        attrs.y = attrY;\n    // Build SVG path if one has been measured\n    if (totalPathLength !== undefined && pathLength !== undefined) {\n        buildSVGPath(attrs, totalPathLength, pathLength, pathSpacing, pathOffset, false);\n    }\n}\n\nvar createSvgRenderState = function () { return (tslib.__assign(tslib.__assign({}, createHtmlRenderState()), { attrs: {} })); };\n\nfunction useSVGProps(props, visualState) {\n    var visualProps = React.useMemo(function () {\n        var state = createSvgRenderState();\n        buildSVGAttrs(state, visualState, undefined, undefined, { enableHardwareAcceleration: false }, props.transformTemplate);\n        return tslib.__assign(tslib.__assign({}, state.attrs), { style: tslib.__assign({}, state.style) });\n    }, [visualState]);\n    if (props.style) {\n        var rawStyles = {};\n        copyRawValuesOnly(rawStyles, props.style, props);\n        visualProps.style = tslib.__assign(tslib.__assign({}, rawStyles), visualProps.style);\n    }\n    return visualProps;\n}\n\nfunction createUseRender(forwardMotionProps) {\n    if (forwardMotionProps === void 0) { forwardMotionProps = false; }\n    var useRender = function (Component, props, ref, _a, isStatic) {\n        var latestValues = _a.latestValues;\n        var useVisualProps = isSVGComponent(Component)\n            ? useSVGProps\n            : useHTMLProps;\n        var visualProps = useVisualProps(props, latestValues, isStatic);\n        var filteredProps = filterProps(props, typeof Component === \"string\", forwardMotionProps);\n        var elementProps = tslib.__assign(tslib.__assign(tslib.__assign({}, filteredProps), visualProps), { ref: ref });\n        return React.createElement(Component, elementProps);\n    };\n    return useRender;\n}\n\nvar CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;\nvar REPLACE_TEMPLATE = \"$1-$2\";\n/**\n * Convert camelCase to dash-case properties.\n */\nvar camelToDash = function (str) {\n    return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();\n};\n\nfunction renderHTML(element, _a) {\n    var style = _a.style, vars = _a.vars;\n    // Directly assign style into the Element's style prop. In tests Object.assign is the\n    // fastest way to assign styles.\n    Object.assign(element.style, style);\n    // Loop over any CSS variables and assign those.\n    for (var key in vars) {\n        element.style.setProperty(key, vars[key]);\n    }\n}\n\n/**\n * A set of attribute names that are always read/written as camel case.\n */\nvar camelCaseAttributes = new Set([\n    \"baseFrequency\",\n    \"diffuseConstant\",\n    \"kernelMatrix\",\n    \"kernelUnitLength\",\n    \"keySplines\",\n    \"keyTimes\",\n    \"limitingConeAngle\",\n    \"markerHeight\",\n    \"markerWidth\",\n    \"numOctaves\",\n    \"targetX\",\n    \"targetY\",\n    \"surfaceScale\",\n    \"specularConstant\",\n    \"specularExponent\",\n    \"stdDeviation\",\n    \"tableValues\",\n    \"viewBox\",\n    \"gradientTransform\",\n]);\n\nfunction renderSVG(element, renderState) {\n    renderHTML(element, renderState);\n    for (var key in renderState.attrs) {\n        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\n    }\n}\n\nfunction scrapeMotionValuesFromProps$1(props) {\n    var style = props.style;\n    var newValues = {};\n    for (var key in style) {\n        if (isMotionValue(style[key]) || isForcedMotionValue(key, props)) {\n            newValues[key] = style[key];\n        }\n    }\n    return newValues;\n}\n\nfunction scrapeMotionValuesFromProps(props) {\n    var newValues = scrapeMotionValuesFromProps$1(props);\n    for (var key in props) {\n        if (isMotionValue(props[key])) {\n            var targetKey = key === \"x\" || key === \"y\" ? \"attr\" + key.toUpperCase() : key;\n            newValues[targetKey] = props[key];\n        }\n    }\n    return newValues;\n}\n\nfunction isAnimationControls(v) {\n    return typeof v === \"object\" && typeof v.start === \"function\";\n}\n\nvar isKeyframesTarget = function (v) {\n    return Array.isArray(v);\n};\n\nvar isCustomValue = function (v) {\n    return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\nvar resolveFinalValueInKeyframes = function (v) {\n    // TODO maybe throw if v.length - 1 is placeholder token?\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n\n/**\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\n *\n * TODO: Remove and move to library\n *\n * @internal\n */\nfunction resolveMotionValue(value) {\n    var unwrappedValue = isMotionValue(value) ? value.get() : value;\n    return isCustomValue(unwrappedValue)\n        ? unwrappedValue.toValue()\n        : unwrappedValue;\n}\n\nfunction makeState(_a, props, context, presenceContext) {\n    var scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps, createRenderState = _a.createRenderState, onMount = _a.onMount;\n    var state = {\n        latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),\n        renderState: createRenderState(),\n    };\n    if (onMount) {\n        state.mount = function (instance) { return onMount(props, instance, state); };\n    }\n    return state;\n}\nvar makeUseVisualState = function (config) { return function (props, isStatic) {\n    var context = React.useContext(MotionContext);\n    var presenceContext = React.useContext(PresenceContext);\n    return isStatic\n        ? makeState(config, props, context, presenceContext)\n        : useConstant(function () { return makeState(config, props, context, presenceContext); });\n}; };\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n    var values = {};\n    var blockInitialAnimation = (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false;\n    var motionValues = scrapeMotionValues(props);\n    for (var key in motionValues) {\n        values[key] = resolveMotionValue(motionValues[key]);\n    }\n    var initial = props.initial, animate = props.animate;\n    var isControllingVariants = checkIfControllingVariants(props);\n    var isVariantNode = checkIfVariantNode(props);\n    if (context &&\n        isVariantNode &&\n        !isControllingVariants &&\n        props.inherit !== false) {\n        initial !== null && initial !== void 0 ? initial : (initial = context.initial);\n        animate !== null && animate !== void 0 ? animate : (animate = context.animate);\n    }\n    var variantToSet = blockInitialAnimation || initial === false ? animate : initial;\n    if (variantToSet &&\n        typeof variantToSet !== \"boolean\" &&\n        !isAnimationControls(variantToSet)) {\n        var list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\n        list.forEach(function (definition) {\n            var resolved = resolveVariantFromProps(props, definition);\n            if (!resolved)\n                return;\n            var transitionEnd = resolved.transitionEnd; resolved.transition; var target = tslib.__rest(resolved, [\"transitionEnd\", \"transition\"]);\n            for (var key in target)\n                values[key] = target[key];\n            for (var key in transitionEnd)\n                values[key] = transitionEnd[key];\n        });\n    }\n    return values;\n}\n\nvar svgMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n        createRenderState: createSvgRenderState,\n        onMount: function (props, instance, _a) {\n            var renderState = _a.renderState, latestValues = _a.latestValues;\n            try {\n                renderState.dimensions =\n                    typeof instance.getBBox ===\n                        \"function\"\n                        ? instance.getBBox()\n                        : instance.getBoundingClientRect();\n            }\n            catch (e) {\n                // Most likely trying to measure an unrendered element under Firefox\n                renderState.dimensions = {\n                    x: 0,\n                    y: 0,\n                    width: 0,\n                    height: 0,\n                };\n            }\n            if (isPath(instance)) {\n                renderState.totalPathLength = instance.getTotalLength();\n            }\n            buildSVGAttrs(renderState, latestValues, undefined, undefined, { enableHardwareAcceleration: false }, props.transformTemplate);\n            // TODO: Replace with direct assignment\n            renderSVG(instance, renderState);\n        },\n    }),\n};\nfunction isPath(element) {\n    return element.tagName === \"path\";\n}\n\nvar htmlMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,\n        createRenderState: createHtmlRenderState,\n    }),\n};\n\nfunction createDomMotionConfig(Component, _a, preloadedFeatures, createVisualElement) {\n    var _b = _a.forwardMotionProps, forwardMotionProps = _b === void 0 ? false : _b;\n    var baseConfig = isSVGComponent(Component)\n        ? svgMotionConfig\n        : htmlMotionConfig;\n    return tslib.__assign(tslib.__assign({}, baseConfig), { preloadedFeatures: preloadedFeatures, useRender: createUseRender(forwardMotionProps), createVisualElement: createVisualElement,\n        Component: Component });\n}\n\nvar AnimationType;\n(function (AnimationType) {\n    AnimationType[\"Animate\"] = \"animate\";\n    AnimationType[\"Hover\"] = \"whileHover\";\n    AnimationType[\"Tap\"] = \"whileTap\";\n    AnimationType[\"Drag\"] = \"whileDrag\";\n    AnimationType[\"Focus\"] = \"whileFocus\";\n    AnimationType[\"Exit\"] = \"exit\";\n})(AnimationType || (AnimationType = {}));\n\nfunction addDomEvent(target, eventName, handler, options) {\n    target.addEventListener(eventName, handler, options);\n    return function () { return target.removeEventListener(eventName, handler, options); };\n}\n/**\n * Attaches an event listener directly to the provided DOM element.\n *\n * Bypassing React's event system can be desirable, for instance when attaching non-passive\n * event handlers.\n *\n * ```jsx\n * const ref = useRef(null)\n *\n * useDomEvent(ref, 'wheel', onWheel, { passive: false })\n *\n * return <div ref={ref} />\n * ```\n *\n * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.\n * @param eventName - Name of the event you want listen for.\n * @param handler - Function to fire when receiving the event.\n * @param options - Options to pass to `Event.addEventListener`.\n *\n * @public\n */\nfunction useDomEvent(ref, eventName, handler, options) {\n    React.useEffect(function () {\n        var element = ref.current;\n        if (handler && element) {\n            return addDomEvent(element, eventName, handler, options);\n        }\n    }, [ref, eventName, handler, options]);\n}\n\n/**\n *\n * @param props\n * @param ref\n * @internal\n */\nfunction useFocusGesture(_a) {\n    var whileFocus = _a.whileFocus, visualElement = _a.visualElement;\n    var onFocus = function () {\n        var _a;\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Focus, true);\n    };\n    var onBlur = function () {\n        var _a;\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Focus, false);\n    };\n    useDomEvent(visualElement, \"focus\", whileFocus ? onFocus : undefined);\n    useDomEvent(visualElement, \"blur\", whileFocus ? onBlur : undefined);\n}\n\nfunction isMouseEvent(event) {\n    // PointerEvent inherits from MouseEvent so we can't use a straight instanceof check.\n    if (typeof PointerEvent !== \"undefined\" && event instanceof PointerEvent) {\n        return !!(event.pointerType === \"mouse\");\n    }\n    return event instanceof MouseEvent;\n}\nfunction isTouchEvent(event) {\n    var hasTouches = !!event.touches;\n    return hasTouches;\n}\n\n/**\n * Filters out events not attached to the primary pointer (currently left mouse button)\n * @param eventHandler\n */\nfunction filterPrimaryPointer(eventHandler) {\n    return function (event) {\n        var isMouseEvent = event instanceof MouseEvent;\n        var isPrimaryPointer = !isMouseEvent ||\n            (isMouseEvent && event.button === 0);\n        if (isPrimaryPointer) {\n            eventHandler(event);\n        }\n    };\n}\nvar defaultPagePoint = { pageX: 0, pageY: 0 };\nfunction pointFromTouch(e, pointType) {\n    if (pointType === void 0) { pointType = \"page\"; }\n    var primaryTouch = e.touches[0] || e.changedTouches[0];\n    var point = primaryTouch || defaultPagePoint;\n    return {\n        x: point[pointType + \"X\"],\n        y: point[pointType + \"Y\"],\n    };\n}\nfunction pointFromMouse(point, pointType) {\n    if (pointType === void 0) { pointType = \"page\"; }\n    return {\n        x: point[pointType + \"X\"],\n        y: point[pointType + \"Y\"],\n    };\n}\nfunction extractEventInfo(event, pointType) {\n    if (pointType === void 0) { pointType = \"page\"; }\n    return {\n        point: isTouchEvent(event)\n            ? pointFromTouch(event, pointType)\n            : pointFromMouse(event, pointType),\n    };\n}\nfunction getViewportPointFromEvent(event) {\n    return extractEventInfo(event, \"client\");\n}\nvar wrapHandler = function (handler, shouldFilterPrimaryPointer) {\n    if (shouldFilterPrimaryPointer === void 0) { shouldFilterPrimaryPointer = false; }\n    var listener = function (event) {\n        return handler(event, extractEventInfo(event));\n    };\n    return shouldFilterPrimaryPointer\n        ? filterPrimaryPointer(listener)\n        : listener;\n};\n\n// We check for event support via functions in case they've been mocked by a testing suite.\nvar supportsPointerEvents = function () {\n    return isBrowser && window.onpointerdown === null;\n};\nvar supportsTouchEvents = function () {\n    return isBrowser && window.ontouchstart === null;\n};\nvar supportsMouseEvents = function () {\n    return isBrowser && window.onmousedown === null;\n};\n\nvar mouseEventNames = {\n    pointerdown: \"mousedown\",\n    pointermove: \"mousemove\",\n    pointerup: \"mouseup\",\n    pointercancel: \"mousecancel\",\n    pointerover: \"mouseover\",\n    pointerout: \"mouseout\",\n    pointerenter: \"mouseenter\",\n    pointerleave: \"mouseleave\",\n};\nvar touchEventNames = {\n    pointerdown: \"touchstart\",\n    pointermove: \"touchmove\",\n    pointerup: \"touchend\",\n    pointercancel: \"touchcancel\",\n};\nfunction getPointerEventName(name) {\n    if (supportsPointerEvents()) {\n        return name;\n    }\n    else if (supportsTouchEvents()) {\n        return touchEventNames[name];\n    }\n    else if (supportsMouseEvents()) {\n        return mouseEventNames[name];\n    }\n    return name;\n}\nfunction addPointerEvent(target, eventName, handler, options) {\n    return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\nfunction usePointerEvent(ref, eventName, handler, options) {\n    return useDomEvent(ref, getPointerEventName(eventName), handler && wrapHandler(handler, eventName === \"pointerdown\"), options);\n}\n\nfunction createLock(name) {\n    var lock = null;\n    return function () {\n        var openLock = function () {\n            lock = null;\n        };\n        if (lock === null) {\n            lock = name;\n            return openLock;\n        }\n        return false;\n    };\n}\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\nvar globalVerticalLock = createLock(\"dragVertical\");\nfunction getGlobalLock(drag) {\n    var lock = false;\n    if (drag === \"y\") {\n        lock = globalVerticalLock();\n    }\n    else if (drag === \"x\") {\n        lock = globalHorizontalLock();\n    }\n    else {\n        var openHorizontal_1 = globalHorizontalLock();\n        var openVertical_1 = globalVerticalLock();\n        if (openHorizontal_1 && openVertical_1) {\n            lock = function () {\n                openHorizontal_1();\n                openVertical_1();\n            };\n        }\n        else {\n            // Release the locks because we don't use them\n            if (openHorizontal_1)\n                openHorizontal_1();\n            if (openVertical_1)\n                openVertical_1();\n        }\n    }\n    return lock;\n}\nfunction isDragActive() {\n    // Check the gesture lock - if we get it, it means no drag gesture is active\n    // and we can safely fire the tap gesture.\n    var openGestureLock = getGlobalLock(true);\n    if (!openGestureLock)\n        return true;\n    openGestureLock();\n    return false;\n}\n\nfunction createHoverEvent(visualElement, isActive, callback) {\n    return function (event, info) {\n        var _a;\n        if (!isMouseEvent(event) || isDragActive())\n            return;\n        callback === null || callback === void 0 ? void 0 : callback(event, info);\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Hover, isActive);\n    };\n}\nfunction useHoverGesture(_a) {\n    var onHoverStart = _a.onHoverStart, onHoverEnd = _a.onHoverEnd, whileHover = _a.whileHover, visualElement = _a.visualElement;\n    usePointerEvent(visualElement, \"pointerenter\", onHoverStart || whileHover\n        ? createHoverEvent(visualElement, true, onHoverStart)\n        : undefined);\n    usePointerEvent(visualElement, \"pointerleave\", onHoverEnd || whileHover\n        ? createHoverEvent(visualElement, false, onHoverEnd)\n        : undefined);\n}\n\n/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */\nvar isNodeOrChild = function (parent, child) {\n    if (!child) {\n        return false;\n    }\n    else if (parent === child) {\n        return true;\n    }\n    else {\n        return isNodeOrChild(parent, child.parentElement);\n    }\n};\n\nfunction useUnmountEffect(callback) {\n    return React.useEffect(function () { return function () { return callback(); }; }, []);\n}\n\n/**\n * @param handlers -\n * @internal\n */\nfunction useTapGesture(_a) {\n    var onTap = _a.onTap, onTapStart = _a.onTapStart, onTapCancel = _a.onTapCancel, whileTap = _a.whileTap, visualElement = _a.visualElement;\n    var hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;\n    var isPressing = React.useRef(false);\n    var cancelPointerEndListeners = React.useRef(null);\n    function removePointerEndListener() {\n        var _a;\n        (_a = cancelPointerEndListeners.current) === null || _a === void 0 ? void 0 : _a.call(cancelPointerEndListeners);\n        cancelPointerEndListeners.current = null;\n    }\n    function checkPointerEnd() {\n        var _a;\n        removePointerEndListener();\n        isPressing.current = false;\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Tap, false);\n        return !isDragActive();\n    }\n    function onPointerUp(event, info) {\n        if (!checkPointerEnd())\n            return;\n        /**\n         * We only count this as a tap gesture if the event.target is the same\n         * as, or a child of, this component's element\n         */\n        !isNodeOrChild(visualElement.getInstance(), event.target)\n            ? onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info)\n            : onTap === null || onTap === void 0 ? void 0 : onTap(event, info);\n    }\n    function onPointerCancel(event, info) {\n        if (!checkPointerEnd())\n            return;\n        onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info);\n    }\n    function onPointerDown(event, info) {\n        var _a;\n        removePointerEndListener();\n        if (isPressing.current)\n            return;\n        isPressing.current = true;\n        cancelPointerEndListeners.current = popmotion.pipe(addPointerEvent(window, \"pointerup\", onPointerUp), addPointerEvent(window, \"pointercancel\", onPointerCancel));\n        onTapStart === null || onTapStart === void 0 ? void 0 : onTapStart(event, info);\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Tap, true);\n    }\n    usePointerEvent(visualElement, \"pointerdown\", hasPressListeners ? onPointerDown : undefined);\n    useUnmountEffect(removePointerEndListener);\n}\n\nvar makeRenderlessComponent = function (hook) { return function (props) {\n    hook(props);\n    return null;\n}; };\n\nvar gestureAnimations = {\n    tap: makeRenderlessComponent(useTapGesture),\n    focus: makeRenderlessComponent(useFocusGesture),\n    hover: makeRenderlessComponent(useHoverGesture),\n};\n\nfunction shallowCompare(next, prev) {\n    if (!Array.isArray(prev))\n        return false;\n    var prevLength = prev.length;\n    if (prevLength !== next.length)\n        return false;\n    for (var i = 0; i < prevLength; i++) {\n        if (prev[i] !== next[i])\n            return false;\n    }\n    return true;\n}\n\n/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\nvar secondsToMilliseconds = function (seconds) { return seconds * 1000; };\n\nvar easingLookup = {\n    linear: popmotion.linear,\n    easeIn: popmotion.easeIn,\n    easeInOut: popmotion.easeInOut,\n    easeOut: popmotion.easeOut,\n    circIn: popmotion.circIn,\n    circInOut: popmotion.circInOut,\n    circOut: popmotion.circOut,\n    backIn: popmotion.backIn,\n    backInOut: popmotion.backInOut,\n    backOut: popmotion.backOut,\n    anticipate: popmotion.anticipate,\n    bounceIn: popmotion.bounceIn,\n    bounceInOut: popmotion.bounceInOut,\n    bounceOut: popmotion.bounceOut,\n};\nvar easingDefinitionToFunction = function (definition) {\n    if (Array.isArray(definition)) {\n        // If cubic bezier definition, create bezier curve\n        heyListen.invariant(definition.length === 4, \"Cubic bezier arrays must contain four numerical values.\");\n        var _a = tslib.__read(definition, 4), x1 = _a[0], y1 = _a[1], x2 = _a[2], y2 = _a[3];\n        return popmotion.cubicBezier(x1, y1, x2, y2);\n    }\n    else if (typeof definition === \"string\") {\n        // Else lookup from table\n        heyListen.invariant(easingLookup[definition] !== undefined, \"Invalid easing type '\" + definition + \"'\");\n        return easingLookup[definition];\n    }\n    return definition;\n};\nvar isEasingArray = function (ease) {\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\n/**\n * Check if a value is animatable. Examples:\n *\n * : 100, \"100px\", \"#fff\"\n * : \"block\", \"url(2.jpg)\"\n * @param value\n *\n * @internal\n */\nvar isAnimatable = function (key, value) {\n    // If the list of keys tat might be non-animatable grows, replace with Set\n    if (key === \"zIndex\")\n        return false;\n    // If it's a number or a keyframes array, we can animate it. We might at some point\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n    // but for now lets leave it like this for performance reasons\n    if (typeof value === \"number\" || Array.isArray(value))\n        return true;\n    if (typeof value === \"string\" && // It's animatable if we have a string\n        styleValueTypes.complex.test(value) && // And it contains numbers and/or colors\n        !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n    ) {\n        return true;\n    }\n    return false;\n};\n\nvar underDampedSpring = function () { return ({\n    type: \"spring\",\n    stiffness: 500,\n    damping: 25,\n    restDelta: 0.5,\n    restSpeed: 10,\n}); };\nvar criticallyDampedSpring = function (to) { return ({\n    type: \"spring\",\n    stiffness: 550,\n    damping: to === 0 ? 2 * Math.sqrt(550) : 30,\n    restDelta: 0.01,\n    restSpeed: 10,\n}); };\nvar linearTween = function () { return ({\n    type: \"keyframes\",\n    ease: \"linear\",\n    duration: 0.3,\n}); };\nvar keyframes = function (values) { return ({\n    type: \"keyframes\",\n    duration: 0.8,\n    values: values,\n}); };\nvar defaultTransitions = {\n    x: underDampedSpring,\n    y: underDampedSpring,\n    z: underDampedSpring,\n    rotate: underDampedSpring,\n    rotateX: underDampedSpring,\n    rotateY: underDampedSpring,\n    rotateZ: underDampedSpring,\n    scaleX: criticallyDampedSpring,\n    scaleY: criticallyDampedSpring,\n    scale: criticallyDampedSpring,\n    opacity: linearTween,\n    backgroundColor: linearTween,\n    color: linearTween,\n    default: criticallyDampedSpring,\n};\nvar getDefaultTransition = function (valueKey, to) {\n    var transitionFactory;\n    if (isKeyframesTarget(to)) {\n        transitionFactory = keyframes;\n    }\n    else {\n        transitionFactory =\n            defaultTransitions[valueKey] || defaultTransitions.default;\n    }\n    return tslib.__assign({ to: to }, transitionFactory(to));\n};\n\n/**\n * A map of default value types for common values\n */\nvar defaultValueTypes = tslib.__assign(tslib.__assign({}, numberValueTypes), { \n    // Color props\n    color: styleValueTypes.color, backgroundColor: styleValueTypes.color, outlineColor: styleValueTypes.color, fill: styleValueTypes.color, stroke: styleValueTypes.color, \n    // Border props\n    borderColor: styleValueTypes.color, borderTopColor: styleValueTypes.color, borderRightColor: styleValueTypes.color, borderBottomColor: styleValueTypes.color, borderLeftColor: styleValueTypes.color, filter: styleValueTypes.filter, WebkitFilter: styleValueTypes.filter });\n/**\n * Gets the default ValueType for the provided value key\n */\nvar getDefaultValueType = function (key) { return defaultValueTypes[key]; };\n\nfunction getAnimatableNone(key, value) {\n    var _a;\n    var defaultValueType = getDefaultValueType(key);\n    if (defaultValueType !== styleValueTypes.filter)\n        defaultValueType = styleValueTypes.complex;\n    // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n    return (_a = defaultValueType.getAnimatableNone) === null || _a === void 0 ? void 0 : _a.call(defaultValueType, value);\n}\n\n/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */\nfunction isTransitionDefined(_a) {\n    _a.when; _a.delay; _a.delayChildren; _a.staggerChildren; _a.staggerDirection; _a.repeat; _a.repeatType; _a.repeatDelay; _a.from; var transition = tslib.__rest(_a, [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\", \"repeat\", \"repeatType\", \"repeatDelay\", \"from\"]);\n    return !!Object.keys(transition).length;\n}\nvar legacyRepeatWarning = false;\n/**\n * Convert Framer Motion's Transition type into Popmotion-compatible options.\n */\nfunction convertTransitionToAnimationOptions(_a) {\n    var ease = _a.ease, times = _a.times, yoyo = _a.yoyo, flip = _a.flip, loop = _a.loop, transition = tslib.__rest(_a, [\"ease\", \"times\", \"yoyo\", \"flip\", \"loop\"]);\n    var options = tslib.__assign({}, transition);\n    if (times)\n        options[\"offset\"] = times;\n    /**\n     * Convert any existing durations from seconds to milliseconds\n     */\n    if (transition.duration)\n        options[\"duration\"] = secondsToMilliseconds(transition.duration);\n    if (transition.repeatDelay)\n        options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);\n    /**\n     * Map easing names to Popmotion's easing functions\n     */\n    if (ease) {\n        options[\"ease\"] = isEasingArray(ease)\n            ? ease.map(easingDefinitionToFunction)\n            : easingDefinitionToFunction(ease);\n    }\n    /**\n     * Support legacy transition API\n     */\n    if (transition.type === \"tween\")\n        options.type = \"keyframes\";\n    /**\n     * TODO: These options are officially removed from the API.\n     */\n    if (yoyo || loop || flip) {\n        heyListen.warning(!legacyRepeatWarning, \"yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.\");\n        legacyRepeatWarning = true;\n        if (yoyo) {\n            options.repeatType = \"reverse\";\n        }\n        else if (loop) {\n            options.repeatType = \"loop\";\n        }\n        else if (flip) {\n            options.repeatType = \"mirror\";\n        }\n        options.repeat = loop || yoyo || flip || transition.repeat;\n    }\n    /**\n     * TODO: Popmotion 9 has the ability to automatically detect whether to use\n     * a keyframes or spring animation, but does so by detecting velocity and other spring options.\n     * It'd be good to introduce a similar thing here.\n     */\n    if (transition.type !== \"spring\")\n        options.type = \"keyframes\";\n    return options;\n}\n/**\n * Get the delay for a value by checking Transition with decreasing specificity.\n */\nfunction getDelayFromTransition(transition, key) {\n    var _a;\n    var valueTransition = getValueTransition(transition, key) || {};\n    return (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : 0;\n}\nfunction hydrateKeyframes(options) {\n    if (Array.isArray(options.to) && options.to[0] === null) {\n        options.to = tslib.__spreadArray([], tslib.__read(options.to));\n        options.to[0] = options.from;\n    }\n    return options;\n}\nfunction getPopmotionAnimationOptions(transition, options, key) {\n    var _a;\n    if (Array.isArray(options.to)) {\n        (_a = transition.duration) !== null && _a !== void 0 ? _a : (transition.duration = 0.8);\n    }\n    hydrateKeyframes(options);\n    /**\n     * Get a default transition if none is determined to be defined.\n     */\n    if (!isTransitionDefined(transition)) {\n        transition = tslib.__assign(tslib.__assign({}, transition), getDefaultTransition(key, options.to));\n    }\n    return tslib.__assign(tslib.__assign({}, options), convertTransitionToAnimationOptions(transition));\n}\n/**\n *\n */\nfunction getAnimation(key, value, target, transition, onComplete) {\n    var _a;\n    var valueTransition = getValueTransition(transition, key);\n    var origin = (_a = valueTransition.from) !== null && _a !== void 0 ? _a : value.get();\n    var isTargetAnimatable = isAnimatable(key, target);\n    if (origin === \"none\" && isTargetAnimatable && typeof target === \"string\") {\n        /**\n         * If we're trying to animate from \"none\", try and get an animatable version\n         * of the target. This could be improved to work both ways.\n         */\n        origin = getAnimatableNone(key, target);\n    }\n    else if (isZero(origin) && typeof target === \"string\") {\n        origin = getZeroUnit(target);\n    }\n    else if (!Array.isArray(target) &&\n        isZero(target) &&\n        typeof origin === \"string\") {\n        target = getZeroUnit(origin);\n    }\n    var isOriginAnimatable = isAnimatable(key, origin);\n    heyListen.warning(isOriginAnimatable === isTargetAnimatable, \"You are trying to animate \" + key + \" from \\\"\" + origin + \"\\\" to \\\"\" + target + \"\\\". \" + origin + \" is not an animatable value - to enable this animation set \" + origin + \" to a value animatable to \" + target + \" via the `style` property.\");\n    function start() {\n        var options = {\n            from: origin,\n            to: target,\n            velocity: value.getVelocity(),\n            onComplete: onComplete,\n            onUpdate: function (v) { return value.set(v); },\n        };\n        return valueTransition.type === \"inertia\" ||\n            valueTransition.type === \"decay\"\n            ? popmotion.inertia(tslib.__assign(tslib.__assign({}, options), valueTransition))\n            : popmotion.animate(tslib.__assign(tslib.__assign({}, getPopmotionAnimationOptions(valueTransition, options, key)), { onUpdate: function (v) {\n                    var _a;\n                    options.onUpdate(v);\n                    (_a = valueTransition.onUpdate) === null || _a === void 0 ? void 0 : _a.call(valueTransition, v);\n                }, onComplete: function () {\n                    var _a;\n                    options.onComplete();\n                    (_a = valueTransition.onComplete) === null || _a === void 0 ? void 0 : _a.call(valueTransition);\n                } }));\n    }\n    function set() {\n        var _a;\n        value.set(target);\n        onComplete();\n        (_a = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onComplete) === null || _a === void 0 ? void 0 : _a.call(valueTransition);\n        return { stop: function () { } };\n    }\n    return !isOriginAnimatable ||\n        !isTargetAnimatable ||\n        valueTransition.type === false\n        ? set\n        : start;\n}\nfunction isZero(value) {\n    return (value === 0 ||\n        (typeof value === \"string\" &&\n            parseFloat(value) === 0 &&\n            value.indexOf(\" \") === -1));\n}\nfunction getZeroUnit(potentialUnitType) {\n    return typeof potentialUnitType === \"number\"\n        ? 0\n        : getAnimatableNone(\"\", potentialUnitType);\n}\nfunction getValueTransition(transition, key) {\n    return transition[key] || transition[\"default\"] || transition;\n}\n/**\n * Start animation on a MotionValue. This function is an interface between\n * Framer Motion and Popmotion\n *\n * @internal\n */\nfunction startAnimation(key, value, target, transition) {\n    if (transition === void 0) { transition = {}; }\n    return value.start(function (onComplete) {\n        var delayTimer;\n        var controls;\n        var animation = getAnimation(key, value, target, transition, onComplete);\n        var delay = getDelayFromTransition(transition, key);\n        var start = function () { return (controls = animation()); };\n        if (delay) {\n            delayTimer = setTimeout(start, secondsToMilliseconds(delay));\n        }\n        else {\n            start();\n        }\n        return function () {\n            clearTimeout(delayTimer);\n            controls === null || controls === void 0 ? void 0 : controls.stop();\n        };\n    });\n}\n\n/**\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n */\nvar isNumericalString = function (v) { return /^\\-?\\d*\\.?\\d+$/.test(v); };\n\nfunction addUniqueItem(arr, item) {\n    arr.indexOf(item) === -1 && arr.push(item);\n}\nfunction removeItem(arr, item) {\n    var index = arr.indexOf(item);\n    index > -1 && arr.splice(index, 1);\n}\n\nvar SubscriptionManager = /** @class */ (function () {\n    function SubscriptionManager() {\n        this.subscriptions = [];\n    }\n    SubscriptionManager.prototype.add = function (handler) {\n        var _this = this;\n        addUniqueItem(this.subscriptions, handler);\n        return function () { return removeItem(_this.subscriptions, handler); };\n    };\n    SubscriptionManager.prototype.notify = function (a, b, c) {\n        var numSubscriptions = this.subscriptions.length;\n        if (!numSubscriptions)\n            return;\n        if (numSubscriptions === 1) {\n            /**\n             * If there's only a single handler we can just call it without invoking a loop.\n             */\n            this.subscriptions[0](a, b, c);\n        }\n        else {\n            for (var i = 0; i < numSubscriptions; i++) {\n                /**\n                 * Check whether the handler exists before firing as it's possible\n                 * the subscriptions were modified during this loop running.\n                 */\n                var handler = this.subscriptions[i];\n                handler && handler(a, b, c);\n            }\n        }\n    };\n    SubscriptionManager.prototype.getSize = function () {\n        return this.subscriptions.length;\n    };\n    SubscriptionManager.prototype.clear = function () {\n        this.subscriptions.length = 0;\n    };\n    return SubscriptionManager;\n}());\n\nvar isFloat = function (value) {\n    return !isNaN(parseFloat(value));\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\nvar MotionValue = /** @class */ (function () {\n    /**\n     * @param init - The initiating value\n     * @param config - Optional configuration options\n     *\n     * -  `transformer`: A function to transform incoming values with.\n     *\n     * @internal\n     */\n    function MotionValue(init) {\n        var _this = this;\n        /**\n         * Duration, in milliseconds, since last updating frame.\n         *\n         * @internal\n         */\n        this.timeDelta = 0;\n        /**\n         * Timestamp of the last time this `MotionValue` was updated.\n         *\n         * @internal\n         */\n        this.lastUpdated = 0;\n        /**\n         * Functions to notify when the `MotionValue` updates.\n         *\n         * @internal\n         */\n        this.updateSubscribers = new SubscriptionManager();\n        /**\n         * Functions to notify when the velocity updates.\n         *\n         * @internal\n         */\n        this.velocityUpdateSubscribers = new SubscriptionManager();\n        /**\n         * Functions to notify when the `MotionValue` updates and `render` is set to `true`.\n         *\n         * @internal\n         */\n        this.renderSubscribers = new SubscriptionManager();\n        /**\n         * Tracks whether this value can output a velocity. Currently this is only true\n         * if the value is numerical, but we might be able to widen the scope here and support\n         * other value types.\n         *\n         * @internal\n         */\n        this.canTrackVelocity = false;\n        this.updateAndNotify = function (v, render) {\n            if (render === void 0) { render = true; }\n            _this.prev = _this.current;\n            _this.current = v;\n            // Update timestamp\n            var _a = sync.getFrameData(), delta = _a.delta, timestamp = _a.timestamp;\n            if (_this.lastUpdated !== timestamp) {\n                _this.timeDelta = delta;\n                _this.lastUpdated = timestamp;\n                sync__default['default'].postRender(_this.scheduleVelocityCheck);\n            }\n            // Update update subscribers\n            if (_this.prev !== _this.current) {\n                _this.updateSubscribers.notify(_this.current);\n            }\n            // Update velocity subscribers\n            if (_this.velocityUpdateSubscribers.getSize()) {\n                _this.velocityUpdateSubscribers.notify(_this.getVelocity());\n            }\n            // Update render subscribers\n            if (render) {\n                _this.renderSubscribers.notify(_this.current);\n            }\n        };\n        /**\n         * Schedule a velocity check for the next frame.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */\n        this.scheduleVelocityCheck = function () { return sync__default['default'].postRender(_this.velocityCheck); };\n        /**\n         * Updates `prev` with `current` if the value hasn't been updated this frame.\n         * This ensures velocity calculations return `0`.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */\n        this.velocityCheck = function (_a) {\n            var timestamp = _a.timestamp;\n            if (timestamp !== _this.lastUpdated) {\n                _this.prev = _this.current;\n                _this.velocityUpdateSubscribers.notify(_this.getVelocity());\n            }\n        };\n        this.hasAnimated = false;\n        this.prev = this.current = init;\n        this.canTrackVelocity = isFloat(this.current);\n    }\n    /**\n     * Adds a function that will be notified when the `MotionValue` is updated.\n     *\n     * It returns a function that, when called, will cancel the subscription.\n     *\n     * When calling `onChange` inside a React component, it should be wrapped with the\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\n     *\n     * @library\n     *\n     * ```jsx\n     * function MyComponent() {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.onChange(updateOpacity)\n     *     const unsubscribeY = y.onChange(updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <Frame x={x} />\n     * }\n     * ```\n     *\n     * @motion\n     *\n     * ```jsx\n     * export const MyComponent = () => {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.onChange(updateOpacity)\n     *     const unsubscribeY = y.onChange(updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <motion.div style={{ x }} />\n     * }\n     * ```\n     *\n     * @internalremarks\n     *\n     * We could look into a `useOnChange` hook if the above lifecycle management proves confusing.\n     *\n     * ```jsx\n     * useOnChange(x, () => {})\n     * ```\n     *\n     * @param subscriber - A function that receives the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @public\n     */\n    MotionValue.prototype.onChange = function (subscription) {\n        return this.updateSubscribers.add(subscription);\n    };\n    MotionValue.prototype.clearListeners = function () {\n        this.updateSubscribers.clear();\n    };\n    /**\n     * Adds a function that will be notified when the `MotionValue` requests a render.\n     *\n     * @param subscriber - A function that's provided the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @internal\n     */\n    MotionValue.prototype.onRenderRequest = function (subscription) {\n        // Render immediately\n        subscription(this.get());\n        return this.renderSubscribers.add(subscription);\n    };\n    /**\n     * Attaches a passive effect to the `MotionValue`.\n     *\n     * @internal\n     */\n    MotionValue.prototype.attach = function (passiveEffect) {\n        this.passiveEffect = passiveEffect;\n    };\n    /**\n     * Sets the state of the `MotionValue`.\n     *\n     * @remarks\n     *\n     * ```jsx\n     * const x = useMotionValue(0)\n     * x.set(10)\n     * ```\n     *\n     * @param latest - Latest value to set.\n     * @param render - Whether to notify render subscribers. Defaults to `true`\n     *\n     * @public\n     */\n    MotionValue.prototype.set = function (v, render) {\n        if (render === void 0) { render = true; }\n        if (!render || !this.passiveEffect) {\n            this.updateAndNotify(v, render);\n        }\n        else {\n            this.passiveEffect(v, this.updateAndNotify);\n        }\n    };\n    /**\n     * Returns the latest state of `MotionValue`\n     *\n     * @returns - The latest state of `MotionValue`\n     *\n     * @public\n     */\n    MotionValue.prototype.get = function () {\n        return this.current;\n    };\n    /**\n     * @public\n     */\n    MotionValue.prototype.getPrevious = function () {\n        return this.prev;\n    };\n    /**\n     * Returns the latest velocity of `MotionValue`\n     *\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n     *\n     * @public\n     */\n    MotionValue.prototype.getVelocity = function () {\n        // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\n        return this.canTrackVelocity\n            ? // These casts could be avoided if parseFloat would be typed better\n                popmotion.velocityPerSecond(parseFloat(this.current) -\n                    parseFloat(this.prev), this.timeDelta)\n            : 0;\n    };\n    /**\n     * Registers a new animation to control this `MotionValue`. Only one\n     * animation can drive a `MotionValue` at one time.\n     *\n     * ```jsx\n     * value.start()\n     * ```\n     *\n     * @param animation - A function that starts the provided animation\n     *\n     * @internal\n     */\n    MotionValue.prototype.start = function (animation) {\n        var _this = this;\n        this.stop();\n        return new Promise(function (resolve) {\n            _this.hasAnimated = true;\n            _this.stopAnimation = animation(resolve);\n        }).then(function () { return _this.clearAnimation(); });\n    };\n    /**\n     * Stop the currently active animation.\n     *\n     * @public\n     */\n    MotionValue.prototype.stop = function () {\n        if (this.stopAnimation)\n            this.stopAnimation();\n        this.clearAnimation();\n    };\n    /**\n     * Returns `true` if this value is currently animating.\n     *\n     * @public\n     */\n    MotionValue.prototype.isAnimating = function () {\n        return !!this.stopAnimation;\n    };\n    MotionValue.prototype.clearAnimation = function () {\n        this.stopAnimation = null;\n    };\n    /**\n     * Destroy and clean up subscribers to this `MotionValue`.\n     *\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n     * created a `MotionValue` via the `motionValue` function.\n     *\n     * @public\n     */\n    MotionValue.prototype.destroy = function () {\n        this.updateSubscribers.clear();\n        this.renderSubscribers.clear();\n        this.stop();\n    };\n    return MotionValue;\n}());\n/**\n * @internal\n */\nfunction motionValue(init) {\n    return new MotionValue(init);\n}\n\n/**\n * Tests a provided value against a ValueType\n */\nvar testValueType = function (v) { return function (type) { return type.test(v); }; };\n\n/**\n * ValueType for \"auto\"\n */\nvar auto = {\n    test: function (v) { return v === \"auto\"; },\n    parse: function (v) { return v; },\n};\n\n/**\n * A list of value types commonly used for dimensions\n */\nvar dimensionValueTypes = [styleValueTypes.number, styleValueTypes.px, styleValueTypes.percent, styleValueTypes.degrees, styleValueTypes.vw, styleValueTypes.vh, auto];\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */\nvar findDimensionValueType = function (v) {\n    return dimensionValueTypes.find(testValueType(v));\n};\n\n/**\n * A list of all ValueTypes\n */\nvar valueTypes = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(dimensionValueTypes)), [styleValueTypes.color, styleValueTypes.complex]);\n/**\n * Tests a value against the list of ValueTypes\n */\nvar findValueType = function (v) { return valueTypes.find(testValueType(v)); };\n\n/**\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\n * it doesn't exist.\n */\nfunction setMotionValue(visualElement, key, value) {\n    if (visualElement.hasValue(key)) {\n        visualElement.getValue(key).set(value);\n    }\n    else {\n        visualElement.addValue(key, motionValue(value));\n    }\n}\nfunction setTarget(visualElement, definition) {\n    var resolved = resolveVariant(visualElement, definition);\n    var _a = resolved\n        ? visualElement.makeTargetAnimatable(resolved, false)\n        : {}, _b = _a.transitionEnd, transitionEnd = _b === void 0 ? {} : _b; _a.transition; var target = tslib.__rest(_a, [\"transitionEnd\", \"transition\"]);\n    target = tslib.__assign(tslib.__assign({}, target), transitionEnd);\n    for (var key in target) {\n        var value = resolveFinalValueInKeyframes(target[key]);\n        setMotionValue(visualElement, key, value);\n    }\n}\nfunction setVariants(visualElement, variantLabels) {\n    var reversedLabels = tslib.__spreadArray([], tslib.__read(variantLabels)).reverse();\n    reversedLabels.forEach(function (key) {\n        var _a;\n        var variant = visualElement.getVariant(key);\n        variant && setTarget(visualElement, variant);\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n            setVariants(child, variantLabels);\n        });\n    });\n}\nfunction setValues(visualElement, definition) {\n    if (Array.isArray(definition)) {\n        return setVariants(visualElement, definition);\n    }\n    else if (typeof definition === \"string\") {\n        return setVariants(visualElement, [definition]);\n    }\n    else {\n        setTarget(visualElement, definition);\n    }\n}\nfunction checkTargetForNewValues(visualElement, target, origin) {\n    var _a, _b, _c;\n    var _d;\n    var newValueKeys = Object.keys(target).filter(function (key) { return !visualElement.hasValue(key); });\n    var numNewValues = newValueKeys.length;\n    if (!numNewValues)\n        return;\n    for (var i = 0; i < numNewValues; i++) {\n        var key = newValueKeys[i];\n        var targetValue = target[key];\n        var value = null;\n        /**\n         * If the target is a series of keyframes, we can use the first value\n         * in the array. If this first value is null, we'll still need to read from the DOM.\n         */\n        if (Array.isArray(targetValue)) {\n            value = targetValue[0];\n        }\n        /**\n         * If the target isn't keyframes, or the first keyframe was null, we need to\n         * first check if an origin value was explicitly defined in the transition as \"from\",\n         * if not read the value from the DOM. As an absolute fallback, take the defined target value.\n         */\n        if (value === null) {\n            value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n        }\n        /**\n         * If value is still undefined or null, ignore it. Preferably this would throw,\n         * but this was causing issues in Framer.\n         */\n        if (value === undefined || value === null)\n            continue;\n        if (typeof value === \"string\" && isNumericalString(value)) {\n            // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n            value = parseFloat(value);\n        }\n        else if (!findValueType(value) && styleValueTypes.complex.test(targetValue)) {\n            value = getAnimatableNone(key, targetValue);\n        }\n        visualElement.addValue(key, motionValue(value));\n        (_c = (_d = origin)[key]) !== null && _c !== void 0 ? _c : (_d[key] = value);\n        visualElement.setBaseTarget(key, value);\n    }\n}\nfunction getOriginFromTransition(key, transition) {\n    if (!transition)\n        return;\n    var valueTransition = transition[key] || transition[\"default\"] || transition;\n    return valueTransition.from;\n}\nfunction getOrigin(target, transition, visualElement) {\n    var _a, _b;\n    var origin = {};\n    for (var key in target) {\n        origin[key] =\n            (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();\n    }\n    return origin;\n}\n\n/**\n * @internal\n */\nfunction animateVisualElement(visualElement, definition, options) {\n    if (options === void 0) { options = {}; }\n    visualElement.notifyAnimationStart();\n    var animation;\n    if (Array.isArray(definition)) {\n        var animations = definition.map(function (variant) {\n            return animateVariant(visualElement, variant, options);\n        });\n        animation = Promise.all(animations);\n    }\n    else if (typeof definition === \"string\") {\n        animation = animateVariant(visualElement, definition, options);\n    }\n    else {\n        var resolvedDefinition = typeof definition === \"function\"\n            ? resolveVariant(visualElement, definition, options.custom)\n            : definition;\n        animation = animateTarget(visualElement, resolvedDefinition, options);\n    }\n    return animation.then(function () {\n        return visualElement.notifyAnimationComplete(definition);\n    });\n}\nfunction animateVariant(visualElement, variant, options) {\n    var _a;\n    if (options === void 0) { options = {}; }\n    var resolved = resolveVariant(visualElement, variant, options.custom);\n    var _b = (resolved || {}).transition, transition = _b === void 0 ? visualElement.getDefaultTransition() || {} : _b;\n    if (options.transitionOverride) {\n        transition = options.transitionOverride;\n    }\n    /**\n     * If we have a variant, create a callback that runs it as an animation.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    var getAnimation = resolved\n        ? function () { return animateTarget(visualElement, resolved, options); }\n        : function () { return Promise.resolve(); };\n    /**\n     * If we have children, create a callback that runs all their animations.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    var getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size)\n        ? function (forwardDelay) {\n            if (forwardDelay === void 0) { forwardDelay = 0; }\n            var _a = transition.delayChildren, delayChildren = _a === void 0 ? 0 : _a, staggerChildren = transition.staggerChildren, staggerDirection = transition.staggerDirection;\n            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n        }\n        : function () { return Promise.resolve(); };\n    /**\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\n     * this animation or all children animations before playing the other.\n     */\n    var when = transition.when;\n    if (when) {\n        var _c = tslib.__read(when === \"beforeChildren\"\n            ? [getAnimation, getChildAnimations]\n            : [getChildAnimations, getAnimation], 2), first = _c[0], last = _c[1];\n        return first().then(last);\n    }\n    else {\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n    }\n}\n/**\n * @internal\n */\nfunction animateTarget(visualElement, definition, _a) {\n    var _b;\n    var _c = _a === void 0 ? {} : _a, _d = _c.delay, delay = _d === void 0 ? 0 : _d, transitionOverride = _c.transitionOverride, type = _c.type;\n    var _e = visualElement.makeTargetAnimatable(definition), _f = _e.transition, transition = _f === void 0 ? visualElement.getDefaultTransition() : _f, transitionEnd = _e.transitionEnd, target = tslib.__rest(_e, [\"transition\", \"transitionEnd\"]);\n    if (transitionOverride)\n        transition = transitionOverride;\n    var animations = [];\n    var animationTypeState = type && ((_b = visualElement.animationState) === null || _b === void 0 ? void 0 : _b.getState()[type]);\n    for (var key in target) {\n        var value = visualElement.getValue(key);\n        var valueTarget = target[key];\n        if (!value ||\n            valueTarget === undefined ||\n            (animationTypeState &&\n                shouldBlockAnimation(animationTypeState, key))) {\n            continue;\n        }\n        var animation = startAnimation(key, value, valueTarget, tslib.__assign({ delay: delay }, transition));\n        animations.push(animation);\n    }\n    return Promise.all(animations).then(function () {\n        transitionEnd && setTarget(visualElement, transitionEnd);\n    });\n}\nfunction animateChildren(visualElement, variant, delayChildren, staggerChildren, staggerDirection, options) {\n    if (delayChildren === void 0) { delayChildren = 0; }\n    if (staggerChildren === void 0) { staggerChildren = 0; }\n    if (staggerDirection === void 0) { staggerDirection = 1; }\n    var animations = [];\n    var maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n    var generateStaggerDuration = staggerDirection === 1\n        ? function (i) {\n            if (i === void 0) { i = 0; }\n            return i * staggerChildren;\n        }\n        : function (i) {\n            if (i === void 0) { i = 0; }\n            return maxStaggerDuration - i * staggerChildren;\n        };\n    Array.from(visualElement.variantChildren)\n        .sort(sortByTreeOrder)\n        .forEach(function (child, i) {\n        animations.push(animateVariant(child, variant, tslib.__assign(tslib.__assign({}, options), { delay: delayChildren + generateStaggerDuration(i) })).then(function () { return child.notifyAnimationComplete(variant); }));\n    });\n    return Promise.all(animations);\n}\nfunction stopAnimation(visualElement) {\n    visualElement.forEachValue(function (value) { return value.stop(); });\n}\nfunction sortByTreeOrder(a, b) {\n    return a.sortNodePosition(b);\n}\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation(_a, key) {\n    var protectedKeys = _a.protectedKeys, needsAnimating = _a.needsAnimating;\n    var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n    needsAnimating[key] = false;\n    return shouldBlock;\n}\n\nvar variantPriorityOrder = [\n    AnimationType.Animate,\n    AnimationType.Hover,\n    AnimationType.Tap,\n    AnimationType.Drag,\n    AnimationType.Focus,\n    AnimationType.Exit,\n];\nvar reversePriorityOrder = tslib.__spreadArray([], tslib.__read(variantPriorityOrder)).reverse();\nvar numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n    return function (animations) {\n        return Promise.all(animations.map(function (_a) {\n            var animation = _a.animation, options = _a.options;\n            return animateVisualElement(visualElement, animation, options);\n        }));\n    };\n}\nfunction createAnimationState(visualElement) {\n    var animate = animateList(visualElement);\n    var state = createState();\n    var allAnimatedKeys = {};\n    var isInitialRender = true;\n    /**\n     * This function will be used to reduce the animation definitions for\n     * each active animation type into an object of resolved values for it.\n     */\n    var buildResolvedTypeValues = function (acc, definition) {\n        var resolved = resolveVariant(visualElement, definition);\n        if (resolved) {\n            resolved.transition; var transitionEnd = resolved.transitionEnd, target = tslib.__rest(resolved, [\"transition\", \"transitionEnd\"]);\n            acc = tslib.__assign(tslib.__assign(tslib.__assign({}, acc), target), transitionEnd);\n        }\n        return acc;\n    };\n    function isAnimated(key) {\n        return allAnimatedKeys[key] !== undefined;\n    }\n    /**\n     * This just allows us to inject mocked animation functions\n     * @internal\n     */\n    function setAnimateFunction(makeAnimator) {\n        animate = makeAnimator(visualElement);\n    }\n    /**\n     * When we receive new props, we need to:\n     * 1. Create a list of protected keys for each type. This is a directory of\n     *    value keys that are currently being \"handled\" by types of a higher priority\n     *    so that whenever an animation is played of a given type, these values are\n     *    protected from being animated.\n     * 2. Determine if an animation type needs animating.\n     * 3. Determine if any values have been removed from a type and figure out\n     *    what to animate those to.\n     */\n    function animateChanges(options, changedActiveType) {\n        var _a;\n        var props = visualElement.getProps();\n        var context = visualElement.getVariantContext(true) || {};\n        /**\n         * A list of animations that we'll build into as we iterate through the animation\n         * types. This will get executed at the end of the function.\n         */\n        var animations = [];\n        /**\n         * Keep track of which values have been removed. Then, as we hit lower priority\n         * animation types, we can check if they contain removed values and animate to that.\n         */\n        var removedKeys = new Set();\n        /**\n         * A dictionary of all encountered keys. This is an object to let us build into and\n         * copy it without iteration. Each time we hit an animation type we set its protected\n         * keys - the keys its not allowed to animate - to the latest version of this object.\n         */\n        var encounteredKeys = {};\n        /**\n         * If a variant has been removed at a given index, and this component is controlling\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\n         */\n        var removedVariantIndex = Infinity;\n        var _loop_1 = function (i) {\n            var type = reversePriorityOrder[i];\n            var typeState = state[type];\n            var prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];\n            var propIsVariant = isVariantLabel(prop);\n            /**\n             * If this type has *just* changed isActive status, set activeDelta\n             * to that status. Otherwise set to null.\n             */\n            var activeDelta = type === changedActiveType ? typeState.isActive : null;\n            if (activeDelta === false)\n                removedVariantIndex = i;\n            /**\n             * If this prop is an inherited variant, rather than been set directly on the\n             * component itself, we want to make sure we allow the parent to trigger animations.\n             *\n             * TODO: Can probably change this to a !isControllingVariants check\n             */\n            var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n            /**\n             *\n             */\n            if (isInherited &&\n                isInitialRender &&\n                visualElement.manuallyAnimateOnMount) {\n                isInherited = false;\n            }\n            /**\n             * Set all encountered keys so far as the protected keys for this type. This will\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n             */\n            typeState.protectedKeys = tslib.__assign({}, encounteredKeys);\n            // Check if we can skip analysing this prop early\n            if (\n            // If it isn't active and hasn't *just* been set as inactive\n            (!typeState.isActive && activeDelta === null) ||\n                // If we didn't and don't have any defined prop for this animation type\n                (!prop && !typeState.prevProp) ||\n                // Or if the prop doesn't define an animation\n                isAnimationControls(prop) ||\n                typeof prop === \"boolean\") {\n                return \"continue\";\n            }\n            /**\n             * As we go look through the values defined on this type, if we detect\n             * a changed value or a value that was removed in a higher priority, we set\n             * this to true and add this prop to the animation list.\n             */\n            var shouldAnimateType = variantsHaveChanged(typeState.prevProp, prop) ||\n                // If we're making this variant active, we want to always make it active\n                (type === changedActiveType &&\n                    typeState.isActive &&\n                    !isInherited &&\n                    propIsVariant) ||\n                // If we removed a higher-priority variant (i is in reverse order)\n                (i > removedVariantIndex && propIsVariant);\n            /**\n             * As animations can be set as variant lists, variants or target objects, we\n             * coerce everything to an array if it isn't one already\n             */\n            var definitionList = Array.isArray(prop) ? prop : [prop];\n            /**\n             * Build an object of all the resolved values. We'll use this in the subsequent\n             * animateChanges calls to determine whether a value has changed.\n             */\n            var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});\n            if (activeDelta === false)\n                resolvedValues = {};\n            /**\n             * Now we need to loop through all the keys in the prev prop and this prop,\n             * and decide:\n             * 1. If the value has changed, and needs animating\n             * 2. If it has been removed, and needs adding to the removedKeys set\n             * 3. If it has been removed in a higher priority type and needs animating\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\n             *    needs adding to the type's protectedKeys list.\n             */\n            var _b = typeState.prevResolvedValues, prevResolvedValues = _b === void 0 ? {} : _b;\n            var allKeys = tslib.__assign(tslib.__assign({}, prevResolvedValues), resolvedValues);\n            var markToAnimate = function (key) {\n                shouldAnimateType = true;\n                removedKeys.delete(key);\n                typeState.needsAnimating[key] = true;\n            };\n            for (var key in allKeys) {\n                var next = resolvedValues[key];\n                var prev = prevResolvedValues[key];\n                // If we've already handled this we can just skip ahead\n                if (encounteredKeys.hasOwnProperty(key))\n                    continue;\n                /**\n                 * If the value has changed, we probably want to animate it.\n                 */\n                if (next !== prev) {\n                    /**\n                     * If both values are keyframes, we need to shallow compare them to\n                     * detect whether any value has changed. If it has, we animate it.\n                     */\n                    if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n                        if (!shallowCompare(next, prev)) {\n                            markToAnimate(key);\n                        }\n                        else {\n                            /**\n                             * If it hasn't changed, we want to ensure it doesn't animate by\n                             * adding it to the list of protected keys.\n                             */\n                            typeState.protectedKeys[key] = true;\n                        }\n                    }\n                    else if (next !== undefined) {\n                        // If next is defined and doesn't equal prev, it needs animating\n                        markToAnimate(key);\n                    }\n                    else {\n                        // If it's undefined, it's been removed.\n                        removedKeys.add(key);\n                    }\n                }\n                else if (next !== undefined && removedKeys.has(key)) {\n                    /**\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\n                     * been removed by a higher priority\n                     */\n                    markToAnimate(key);\n                }\n                else {\n                    /**\n                     * If it hasn't changed, we add it to the list of protected values\n                     * to ensure it doesn't get animated.\n                     */\n                    typeState.protectedKeys[key] = true;\n                }\n            }\n            /**\n             * Update the typeState so next time animateChanges is called we can compare the\n             * latest prop and resolvedValues to these.\n             */\n            typeState.prevProp = prop;\n            typeState.prevResolvedValues = resolvedValues;\n            /**\n             *\n             */\n            if (typeState.isActive) {\n                encounteredKeys = tslib.__assign(tslib.__assign({}, encounteredKeys), resolvedValues);\n            }\n            if (isInitialRender && visualElement.blockInitialAnimation) {\n                shouldAnimateType = false;\n            }\n            /**\n             * If this is an inherited prop we want to hard-block animations\n             * TODO: Test as this should probably still handle animations triggered\n             * by removed values?\n             */\n            if (shouldAnimateType && !isInherited) {\n                animations.push.apply(animations, tslib.__spreadArray([], tslib.__read(definitionList.map(function (animation) { return ({\n                    animation: animation,\n                    options: tslib.__assign({ type: type }, options),\n                }); }))));\n            }\n        };\n        /**\n         * Iterate through all animation types in reverse priority order. For each, we want to\n         * detect which values it's handling and whether or not they've changed (and therefore\n         * need to be animated). If any values have been removed, we want to detect those in\n         * lower priority props and flag for animation.\n         */\n        for (var i = 0; i < numAnimationTypes; i++) {\n            _loop_1(i);\n        }\n        allAnimatedKeys = tslib.__assign({}, encounteredKeys);\n        /**\n         * If there are some removed value that haven't been dealt with,\n         * we need to create a new animation that falls back either to the value\n         * defined in the style prop, or the last read value.\n         */\n        if (removedKeys.size) {\n            var fallbackAnimation_1 = {};\n            removedKeys.forEach(function (key) {\n                var fallbackTarget = visualElement.getBaseTarget(key);\n                if (fallbackTarget !== undefined) {\n                    fallbackAnimation_1[key] = fallbackTarget;\n                }\n            });\n            animations.push({ animation: fallbackAnimation_1 });\n        }\n        var shouldAnimate = Boolean(animations.length);\n        if (isInitialRender &&\n            props.initial === false &&\n            !visualElement.manuallyAnimateOnMount) {\n            shouldAnimate = false;\n        }\n        isInitialRender = false;\n        return shouldAnimate ? animate(animations) : Promise.resolve();\n    }\n    /**\n     * Change whether a certain animation type is active.\n     */\n    function setActive(type, isActive, options) {\n        var _a;\n        // If the active state hasn't changed, we can safely do nothing here\n        if (state[type].isActive === isActive)\n            return Promise.resolve();\n        // Propagate active change to children\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) { var _a; return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive); });\n        state[type].isActive = isActive;\n        return animateChanges(options, type);\n    }\n    return {\n        isAnimated: isAnimated,\n        animateChanges: animateChanges,\n        setActive: setActive,\n        setAnimateFunction: setAnimateFunction,\n        getState: function () { return state; },\n    };\n}\nfunction variantsHaveChanged(prev, next) {\n    if (typeof next === \"string\") {\n        return next !== prev;\n    }\n    else if (isVariantLabels(next)) {\n        return !shallowCompare(next, prev);\n    }\n    return false;\n}\nfunction createTypeState(isActive) {\n    if (isActive === void 0) { isActive = false; }\n    return {\n        isActive: isActive,\n        protectedKeys: {},\n        needsAnimating: {},\n        prevResolvedValues: {},\n    };\n}\nfunction createState() {\n    var _a;\n    return _a = {},\n        _a[AnimationType.Animate] = createTypeState(true),\n        _a[AnimationType.Hover] = createTypeState(),\n        _a[AnimationType.Tap] = createTypeState(),\n        _a[AnimationType.Drag] = createTypeState(),\n        _a[AnimationType.Focus] = createTypeState(),\n        _a[AnimationType.Exit] = createTypeState(),\n        _a;\n}\n\nvar animations = {\n    animation: makeRenderlessComponent(function (_a) {\n        var visualElement = _a.visualElement, animate = _a.animate;\n        /**\n         * We dynamically generate the AnimationState manager as it contains a reference\n         * to the underlying animation library. We only want to load that if we load this,\n         * so people can optionally code split it out using the `m` component.\n         */\n        visualElement.animationState || (visualElement.animationState = createAnimationState(visualElement));\n        /**\n         * Subscribe any provided AnimationControls to the component's VisualElement\n         */\n        if (isAnimationControls(animate)) {\n            React.useEffect(function () { return animate.subscribe(visualElement); }, [animate]);\n        }\n    }),\n    exit: makeRenderlessComponent(function (props) {\n        var custom = props.custom, visualElement = props.visualElement;\n        var _a = tslib.__read(usePresence(), 2), isPresent = _a[0], onExitComplete = _a[1];\n        var presenceContext = React.useContext(PresenceContext);\n        React.useEffect(function () {\n            var _a, _b;\n            var animation = (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Exit, !isPresent, { custom: (_b = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== null && _b !== void 0 ? _b : custom });\n            !isPresent && (animation === null || animation === void 0 ? void 0 : animation.then(onExitComplete));\n        }, [isPresent]);\n    }),\n};\n\n/**\n * @internal\n */\nvar PanSession = /** @class */ (function () {\n    function PanSession(event, handlers, _a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, transformPagePoint = _b.transformPagePoint;\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        this.updatePoint = function () {\n            if (!(_this.lastMoveEvent && _this.lastMoveEventInfo))\n                return;\n            var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\n            var isPanStarted = _this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            var isDistancePastThreshold = popmotion.distance(info.offset, { x: 0, y: 0 }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            var point = info.point;\n            var timestamp = sync.getFrameData().timestamp;\n            _this.history.push(tslib.__assign(tslib.__assign({}, point), { timestamp: timestamp }));\n            var _a = _this.handlers, onStart = _a.onStart, onMove = _a.onMove;\n            if (!isPanStarted) {\n                onStart && onStart(_this.lastMoveEvent, info);\n                _this.startEvent = _this.lastMoveEvent;\n            }\n            onMove && onMove(_this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = function (event, info) {\n            _this.lastMoveEvent = event;\n            _this.lastMoveEventInfo = transformPoint(info, _this.transformPagePoint);\n            // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n            if (isMouseEvent(event) && event.buttons === 0) {\n                _this.handlePointerUp(event, info);\n                return;\n            }\n            // Throttle mouse move event to once per frame\n            sync__default['default'].update(_this.updatePoint, true);\n        };\n        this.handlePointerUp = function (event, info) {\n            _this.end();\n            var _a = _this.handlers, onEnd = _a.onEnd, onSessionEnd = _a.onSessionEnd;\n            var panInfo = getPanInfo(transformPoint(info, _this.transformPagePoint), _this.history);\n            if (_this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (isTouchEvent(event) && event.touches.length > 1)\n            return;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        var info = extractEventInfo(event);\n        var initialInfo = transformPoint(info, this.transformPagePoint);\n        var point = initialInfo.point;\n        var timestamp = sync.getFrameData().timestamp;\n        this.history = [tslib.__assign(tslib.__assign({}, point), { timestamp: timestamp })];\n        var onSessionStart = handlers.onSessionStart;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        this.removeListeners = popmotion.pipe(addPointerEvent(window, \"pointermove\", this.handlePointerMove), addPointerEvent(window, \"pointerup\", this.handlePointerUp), addPointerEvent(window, \"pointercancel\", this.handlePointerUp));\n    }\n    PanSession.prototype.updateHandlers = function (handlers) {\n        this.handlers = handlers;\n    };\n    PanSession.prototype.end = function () {\n        this.removeListeners && this.removeListeners();\n        sync.cancelSync.update(this.updatePoint);\n    };\n    return PanSession;\n}());\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo(_a, history) {\n    var point = _a.point;\n    return {\n        point: point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    var i = history.length - 1;\n    var timestampedPoint = null;\n    var lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    var currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\nfunction noop(any) {\n    return any;\n}\n\n/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it's easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */\nfunction convertBoundingBoxToAxisBox(_a) {\n    var top = _a.top, left = _a.left, right = _a.right, bottom = _a.bottom;\n    return {\n        x: { min: left, max: right },\n        y: { min: top, max: bottom },\n    };\n}\nfunction convertAxisBoxToBoundingBox(_a) {\n    var x = _a.x, y = _a.y;\n    return {\n        top: y.min,\n        bottom: y.max,\n        left: x.min,\n        right: x.max,\n    };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */\nfunction transformBoundingBox(_a, transformPoint) {\n    var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;\n    if (transformPoint === void 0) { transformPoint = noop; }\n    var topLeft = transformPoint({ x: left, y: top });\n    var bottomRight = transformPoint({ x: right, y: bottom });\n    return {\n        top: topLeft.y,\n        left: topLeft.x,\n        bottom: bottomRight.y,\n        right: bottomRight.x,\n    };\n}\n/**\n * Create an empty axis box of zero size\n */\nfunction axisBox() {\n    return { x: { min: 0, max: 1 }, y: { min: 0, max: 1 } };\n}\nfunction copyAxisBox(box) {\n    return {\n        x: tslib.__assign({}, box.x),\n        y: tslib.__assign({}, box.y),\n    };\n}\n/**\n * Create an empty box delta\n */\nvar zeroDelta = {\n    translate: 0,\n    scale: 1,\n    origin: 0,\n    originPoint: 0,\n};\nfunction delta() {\n    return {\n        x: tslib.__assign({}, zeroDelta),\n        y: tslib.__assign({}, zeroDelta),\n    };\n}\n\n// Call a handler once for each axis\nfunction eachAxis(handler) {\n    return [handler(\"x\"), handler(\"y\")];\n}\n\nvar clampProgress = function (v) { return popmotion.clamp(0, 1, v); };\n/**\n * Returns true if the provided value is within maxDistance of the provided target\n */\nfunction isNear(value, target, maxDistance) {\n    if (target === void 0) { target = 0; }\n    if (maxDistance === void 0) { maxDistance = 0.01; }\n    return popmotion.distance(value, target) < maxDistance;\n}\nfunction calcLength(axis) {\n    return axis.max - axis.min;\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\nfunction calcOrigin(source, target) {\n    var origin = 0.5;\n    var sourceLength = calcLength(source);\n    var targetLength = calcLength(target);\n    if (targetLength > sourceLength) {\n        origin = popmotion.progress(target.min, target.max - sourceLength, source.min);\n    }\n    else if (sourceLength > targetLength) {\n        origin = popmotion.progress(source.min, source.max - targetLength, target.min);\n    }\n    return clampProgress(origin);\n}\n/**\n * Update the AxisDelta with a transform that projects source into target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\nfunction updateAxisDelta(delta, source, target, origin) {\n    if (origin === void 0) { origin = 0.5; }\n    delta.origin = origin;\n    delta.originPoint = popmotion.mix(source.min, source.max, delta.origin);\n    delta.scale = calcLength(target) / calcLength(source);\n    if (isNear(delta.scale, 1, 0.0001))\n        delta.scale = 1;\n    delta.translate =\n        popmotion.mix(target.min, target.max, delta.origin) - delta.originPoint;\n    if (isNear(delta.translate))\n        delta.translate = 0;\n}\n/**\n * Update the BoxDelta with a transform that projects the source into the target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\nfunction updateBoxDelta(delta, source, target, origin) {\n    updateAxisDelta(delta.x, source.x, target.x, defaultOrigin(origin.originX));\n    updateAxisDelta(delta.y, source.y, target.y, defaultOrigin(origin.originY));\n}\n/**\n * Currently this only accepts numerical origins, measured as 0-1, but could\n * accept pixel values by comparing to the target axis.\n */\nfunction defaultOrigin(origin) {\n    return typeof origin === \"number\" ? origin : 0.5;\n}\nfunction calcRelativeAxis(target, relative, parent) {\n    target.min = parent.min + relative.min;\n    target.max = target.min + calcLength(relative);\n}\nfunction calcRelativeBox(projection, parentProjection) {\n    calcRelativeAxis(projection.target.x, projection.relativeTarget.x, parentProjection.target.x);\n    calcRelativeAxis(projection.target.y, projection.relativeTarget.y, parentProjection.target.y);\n}\n\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\nfunction applyConstraints(point, _a, elastic) {\n    var min = _a.min, max = _a.max;\n    if (min !== undefined && point < min) {\n        // If we have a min point defined, and this is outside of that, constrain\n        point = elastic ? popmotion.mix(min, point, elastic.min) : Math.max(point, min);\n    }\n    else if (max !== undefined && point > max) {\n        // If we have a max point defined, and this is outside of that, constrain\n        point = elastic ? popmotion.mix(max, point, elastic.max) : Math.min(point, max);\n    }\n    return point;\n}\n/**\n * Calculates a min projection point based on a pointer, pointer progress\n * within the drag target, and constraints.\n *\n * For instance if an element was 100px width, we were dragging from 0.25\n * along this axis, the pointer is at 200px, and there were no constraints,\n * we would calculate a min projection point of 175px.\n */\nfunction calcConstrainedMinPoint(point, length, progress, constraints, elastic) {\n    // Calculate a min point for this axis and apply it to the current pointer\n    var min = point - length * progress;\n    return constraints ? applyConstraints(min, constraints, elastic) : min;\n}\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */\nfunction calcRelativeAxisConstraints(axis, min, max) {\n    return {\n        min: min !== undefined ? axis.min + min : undefined,\n        max: max !== undefined\n            ? axis.max + max - (axis.max - axis.min)\n            : undefined,\n    };\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\nfunction calcRelativeConstraints(layoutBox, _a) {\n    var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;\n    return {\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n    var _a;\n    var min = constraintsAxis.min - layoutAxis.min;\n    var max = constraintsAxis.max - layoutAxis.max;\n    // If the constraints axis is actually smaller than the layout axis then we can\n    // flip the constraints\n    if (constraintsAxis.max - constraintsAxis.min <\n        layoutAxis.max - layoutAxis.min) {\n        _a = tslib.__read([max, min], 2), min = _a[0], max = _a[1];\n    }\n    return {\n        min: layoutAxis.min + min,\n        max: layoutAxis.min + max,\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n    return {\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),\n    };\n}\n/**\n * Calculate the an axis position based on two axes and a progress value.\n */\nfunction calcPositionFromProgress(axis, constraints, progress) {\n    var axisLength = axis.max - axis.min;\n    var min = popmotion.mix(constraints.min, constraints.max - axisLength, progress);\n    return { min: min, max: min + axisLength };\n}\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */\nfunction rebaseAxisConstraints(layout, constraints) {\n    var relativeConstraints = {};\n    if (constraints.min !== undefined) {\n        relativeConstraints.min = constraints.min - layout.min;\n    }\n    if (constraints.max !== undefined) {\n        relativeConstraints.max = constraints.max - layout.min;\n    }\n    return relativeConstraints;\n}\nvar defaultElastic = 0.35;\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */\nfunction resolveDragElastic(dragElastic) {\n    if (dragElastic === false) {\n        dragElastic = 0;\n    }\n    else if (dragElastic === true) {\n        dragElastic = defaultElastic;\n    }\n    return {\n        x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n        y: resolveAxisElastic(dragElastic, \"top\", \"bottom\"),\n    };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n    return {\n        min: resolvePointElastic(dragElastic, minLabel),\n        max: resolvePointElastic(dragElastic, maxLabel),\n    };\n}\nfunction resolvePointElastic(dragElastic, label) {\n    var _a;\n    return typeof dragElastic === \"number\"\n        ? dragElastic\n        : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;\n}\n\n/**\n * Measure and return the element bounding box.\n *\n * We convert the box into an AxisBox2D to make it easier to work with each axis\n * individually and programmatically.\n *\n * This function optionally accepts a transformPagePoint function which allows us to compensate\n * for, for instance, measuring the element within a scaled plane like a Framer devivce preview component.\n */\nfunction getBoundingBox(element, transformPagePoint) {\n    var box = element.getBoundingClientRect();\n    return convertBoundingBoxToAxisBox(transformBoundingBox(box, transformPagePoint));\n}\n\nvar compareByDepth = function (a, b) {\n    return a.depth - b.depth;\n};\n\nfunction isProjecting(visualElement) {\n    var isEnabled = visualElement.projection.isEnabled;\n    return isEnabled || visualElement.shouldResetTransform();\n}\nfunction collectProjectingAncestors(visualElement, ancestors) {\n    if (ancestors === void 0) { ancestors = []; }\n    var parent = visualElement.parent;\n    if (parent)\n        collectProjectingAncestors(parent, ancestors);\n    if (isProjecting(visualElement))\n        ancestors.push(visualElement);\n    return ancestors;\n}\nfunction collectProjectingChildren(visualElement) {\n    var children = [];\n    var addChild = function (child) {\n        if (isProjecting(child))\n            children.push(child);\n        child.children.forEach(addChild);\n    };\n    visualElement.children.forEach(addChild);\n    return children.sort(compareByDepth);\n}\n/**\n * Update the layoutState by measuring the DOM layout. This\n * should be called after resetting any layout-affecting transforms.\n */\nfunction updateLayoutMeasurement(visualElement) {\n    if (visualElement.shouldResetTransform())\n        return;\n    var layoutState = visualElement.getLayoutState();\n    visualElement.notifyBeforeLayoutMeasure(layoutState.layout);\n    layoutState.isHydrated = true;\n    layoutState.layout = visualElement.measureViewportBox();\n    layoutState.layoutCorrected = copyAxisBox(layoutState.layout);\n    visualElement.notifyLayoutMeasure(layoutState.layout, visualElement.prevViewportBox || layoutState.layout);\n    sync__default['default'].update(function () { return visualElement.rebaseProjectionTarget(); });\n}\n/**\n * Record the viewport box as it was before an expected mutation/re-render\n */\nfunction snapshotViewportBox(visualElement) {\n    if (visualElement.shouldResetTransform())\n        return;\n    visualElement.prevViewportBox = visualElement.measureViewportBox(false);\n    /**\n     * Update targetBox to match the prevViewportBox. This is just to ensure\n     * that targetBox is affected by scroll in the same way as the measured box\n     */\n    visualElement.rebaseProjectionTarget(false, visualElement.prevViewportBox);\n}\n\nfunction tweenAxis(target, prev, next, p) {\n    target.min = popmotion.mix(prev.min, next.min, p);\n    target.max = popmotion.mix(prev.max, next.max, p);\n}\nfunction calcRelativeOffsetAxis(parent, child) {\n    return {\n        min: child.min - parent.min,\n        max: child.max - parent.min,\n    };\n}\nfunction calcRelativeOffset(parent, child) {\n    return {\n        x: calcRelativeOffsetAxis(parent.x, child.x),\n        y: calcRelativeOffsetAxis(parent.y, child.y),\n    };\n}\nfunction checkIfParentHasChanged(prev, next) {\n    var prevId = prev.getLayoutId();\n    var nextId = next.getLayoutId();\n    return prevId !== nextId || (nextId === undefined && prev !== next);\n}\n\nfunction isDraggable(visualElement) {\n    var _a = visualElement.getProps(), drag = _a.drag, _dragX = _a._dragX;\n    return drag && !_dragX;\n}\n\n/**\n * Reset an axis to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction resetAxis(axis, originAxis) {\n    axis.min = originAxis.min;\n    axis.max = originAxis.max;\n}\n/**\n * Reset a box to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction resetBox(box, originBox) {\n    resetAxis(box.x, originBox.x);\n    resetAxis(box.y, originBox.y);\n}\n/**\n * Scales a point based on a factor and an originPoint\n */\nfunction scalePoint(point, scale, originPoint) {\n    var distanceFromOrigin = point - originPoint;\n    var scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\nfunction applyAxisDelta(axis, translate, scale, originPoint, boxScale) {\n    if (translate === void 0) { translate = 0; }\n    if (scale === void 0) { scale = 1; }\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\nfunction applyBoxDelta(box, _a) {\n    var x = _a.x, y = _a.y;\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nfunction applyAxisTransforms(final, axis, transforms, _a) {\n    var _b = tslib.__read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];\n    // Copy the current axis to the final axis before mutation\n    final.min = axis.min;\n    final.max = axis.max;\n    var axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;\n    var originPoint = popmotion.mix(axis.min, axis.max, axisOrigin);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(final, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\nvar xKeys = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nfunction applyBoxTransforms(finalBox, box, transforms) {\n    applyAxisTransforms(finalBox.x, box.x, transforms, xKeys);\n    applyAxisTransforms(finalBox.y, box.y, transforms, yKeys);\n}\n/**\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\n */\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\n    point -= translate;\n    point = scalePoint(point, 1 / scale, originPoint);\n    if (boxScale !== undefined) {\n        point = scalePoint(point, 1 / boxScale, originPoint);\n    }\n    return point;\n}\n/**\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\n */\nfunction removeAxisDelta(axis, translate, scale, origin, boxScale) {\n    if (translate === void 0) { translate = 0; }\n    if (scale === void 0) { scale = 1; }\n    if (origin === void 0) { origin = 0.5; }\n    var originPoint = popmotion.mix(axis.min, axis.max, origin) - translate;\n    axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeAxisTransforms(axis, transforms, _a) {\n    var _b = tslib.__read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];\n    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale);\n}\n/**\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeBoxTransforms(box, transforms) {\n    removeAxisTransforms(box.x, transforms, xKeys);\n    removeAxisTransforms(box.y, transforms, yKeys);\n}\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\nfunction applyTreeDeltas(box, treeScale, treePath) {\n    var treeLength = treePath.length;\n    if (!treeLength)\n        return;\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1;\n    var node;\n    var delta;\n    for (var i = 0; i < treeLength; i++) {\n        node = treePath[i];\n        delta = node.getLayoutState().delta;\n        // Incoporate each ancestor's scale into a culmulative treeScale for this component\n        treeScale.x *= delta.x.scale;\n        treeScale.y *= delta.y.scale;\n        // Apply each ancestor's calculated delta into this component's recorded layout box\n        applyBoxDelta(box, delta);\n        // If this is a draggable ancestor, also incorporate the node's transform to the layout box\n        if (isDraggable(node)) {\n            applyBoxTransforms(box, box, node.getLatestValues());\n        }\n    }\n}\n\n/**\n * Returns a boolean stating whether or not we converted the projection\n * to relative projection.\n */\nfunction convertToRelativeProjection(visualElement, isLayoutDrag) {\n    if (isLayoutDrag === void 0) { isLayoutDrag = true; }\n    var projectionParent = visualElement.getProjectionParent();\n    if (!projectionParent)\n        return false;\n    var offset;\n    if (isLayoutDrag) {\n        offset = calcRelativeOffset(projectionParent.projection.target, visualElement.projection.target);\n        removeBoxTransforms(offset, projectionParent.getLatestValues());\n    }\n    else {\n        offset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement.getLayoutState().layout);\n    }\n    eachAxis(function (axis) {\n        return visualElement.setProjectionTargetAxis(axis, offset[axis].min, offset[axis].max, true);\n    });\n    return true;\n}\n\nvar unresolvedJobs = new Set();\nfunction pushJob(stack, job, pointer) {\n    if (!stack[pointer])\n        stack[pointer] = [];\n    stack[pointer].push(job);\n}\nfunction batchLayout(callback) {\n    unresolvedJobs.add(callback);\n    return function () { return unresolvedJobs.delete(callback); };\n}\nfunction flushLayout() {\n    if (!unresolvedJobs.size)\n        return;\n    var pointer = 0;\n    var reads = [[]];\n    var writes = [];\n    var setRead = function (job) { return pushJob(reads, job, pointer); };\n    var setWrite = function (job) {\n        pushJob(writes, job, pointer);\n        pointer++;\n    };\n    /**\n     * Resolve jobs into their array stacks\n     */\n    unresolvedJobs.forEach(function (callback) {\n        callback(setRead, setWrite);\n        pointer = 0;\n    });\n    unresolvedJobs.clear();\n    /**\n     * Execute jobs\n     */\n    var numStacks = writes.length;\n    for (var i = 0; i <= numStacks; i++) {\n        reads[i] && reads[i].forEach(executeJob);\n        writes[i] && writes[i].forEach(executeJob);\n    }\n}\nvar executeJob = function (job) { return job(); };\n\nvar elementDragControls = new WeakMap();\n/**\n *\n */\nvar lastPointerEvent;\nvar VisualElementDragControls = /** @class */ (function () {\n    function VisualElementDragControls(_a) {\n        var visualElement = _a.visualElement;\n        /**\n         * Track whether we're currently dragging.\n         *\n         * @internal\n         */\n        this.isDragging = false;\n        /**\n         * The current direction of drag, or `null` if both.\n         *\n         * @internal\n         */\n        this.currentDirection = null;\n        /**\n         * The permitted boundaries of travel, in pixels.\n         *\n         * @internal\n         */\n        this.constraints = false;\n        /**\n         * The per-axis resolved elastic values.\n         *\n         * @internal\n         */\n        this.elastic = axisBox();\n        /**\n         * A reference to the host component's latest props.\n         *\n         * @internal\n         */\n        this.props = {};\n        /**\n         * @internal\n         */\n        this.hasMutatedConstraints = false;\n        /**\n         * Track the initial position of the cursor relative to the dragging element\n         * when dragging starts as a value of 0-1 on each axis. We then use this to calculate\n         * an ideal bounding box for the VisualElement renderer to project into every frame.\n         *\n         * @internal\n         */\n        this.cursorProgress = {\n            x: 0.5,\n            y: 0.5,\n        };\n        // When updating _dragX, or _dragY instead of the VisualElement,\n        // persist their values between drag gestures.\n        this.originPoint = {};\n        // This is a reference to the global drag gesture lock, ensuring only one component\n        // can \"capture\" the drag of one or both axes.\n        // TODO: Look into moving this into pansession?\n        this.openGlobalLock = null;\n        /**\n         * @internal\n         */\n        this.panSession = null;\n        this.visualElement = visualElement;\n        this.visualElement.enableLayoutProjection();\n        elementDragControls.set(visualElement, this);\n    }\n    /**\n     * Instantiate a PanSession for the drag gesture\n     *\n     * @public\n     */\n    VisualElementDragControls.prototype.start = function (originEvent, _a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, _c = _b.snapToCursor, snapToCursor = _c === void 0 ? false : _c, cursorProgress = _b.cursorProgress;\n        var onSessionStart = function (event) {\n            var _a;\n            // Stop any animations on both axis values immediately. This allows the user to throw and catch\n            // the component.\n            _this.stopMotion();\n            /**\n             * Save the initial point. We'll use this to calculate the pointer's position rather\n             * than the one we receive when the gesture actually starts. By then, the pointer will\n             * have already moved, and the perception will be of the pointer \"slipping\" across the element\n             */\n            var initialPoint = getViewportPointFromEvent(event).point;\n            (_a = _this.cancelLayout) === null || _a === void 0 ? void 0 : _a.call(_this);\n            _this.cancelLayout = batchLayout(function (read, write) {\n                var ancestors = collectProjectingAncestors(_this.visualElement);\n                var children = collectProjectingChildren(_this.visualElement);\n                var tree = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(ancestors)), tslib.__read(children));\n                var hasManuallySetCursorOrigin = false;\n                /**\n                 * Apply a simple lock to the projection target. This ensures no animations\n                 * can run on the projection box while this lock is active.\n                 */\n                _this.isLayoutDrag() && _this.visualElement.lockProjectionTarget();\n                write(function () {\n                    tree.forEach(function (element) { return element.resetTransform(); });\n                });\n                read(function () {\n                    updateLayoutMeasurement(_this.visualElement);\n                    children.forEach(updateLayoutMeasurement);\n                });\n                write(function () {\n                    tree.forEach(function (element) { return element.restoreTransform(); });\n                    if (snapToCursor) {\n                        hasManuallySetCursorOrigin = _this.snapToCursor(initialPoint);\n                    }\n                });\n                read(function () {\n                    var isRelativeDrag = Boolean(_this.getAxisMotionValue(\"x\") && !_this.isExternalDrag());\n                    if (!isRelativeDrag) {\n                        _this.visualElement.rebaseProjectionTarget(true, _this.visualElement.measureViewportBox(false));\n                    }\n                    _this.visualElement.scheduleUpdateLayoutProjection();\n                    /**\n                     * When dragging starts, we want to find where the cursor is relative to the bounding box\n                     * of the element. Every frame, we calculate a new bounding box using this relative position\n                     * and let the visualElement renderer figure out how to reproject the element into this bounding\n                     * box.\n                     *\n                     * By doing it this way, rather than applying an x/y transform directly to the element,\n                     * we can ensure the component always visually sticks to the cursor as we'd expect, even\n                     * if the DOM element itself changes layout as a result of React updates the user might\n                     * make based on the drag position.\n                     */\n                    var projection = _this.visualElement.projection;\n                    eachAxis(function (axis) {\n                        if (!hasManuallySetCursorOrigin) {\n                            var _a = projection.target[axis], min = _a.min, max = _a.max;\n                            _this.cursorProgress[axis] = cursorProgress\n                                ? cursorProgress[axis]\n                                : popmotion.progress(min, max, initialPoint[axis]);\n                        }\n                        /**\n                         * If we have external drag MotionValues, record their origin point. On pointermove\n                         * we'll apply the pan gesture offset directly to this value.\n                         */\n                        var axisValue = _this.getAxisMotionValue(axis);\n                        if (axisValue) {\n                            _this.originPoint[axis] = axisValue.get();\n                        }\n                    });\n                });\n                write(function () {\n                    sync.flushSync.update();\n                    sync.flushSync.preRender();\n                    sync.flushSync.render();\n                    sync.flushSync.postRender();\n                });\n                read(function () { return _this.resolveDragConstraints(); });\n            });\n        };\n        var onStart = function (event, info) {\n            var _a, _b, _c;\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n            var _d = _this.props, drag = _d.drag, dragPropagation = _d.dragPropagation;\n            if (drag && !dragPropagation) {\n                if (_this.openGlobalLock)\n                    _this.openGlobalLock();\n                _this.openGlobalLock = getGlobalLock(drag);\n                // If we don 't have the lock, don't start dragging\n                if (!_this.openGlobalLock)\n                    return;\n            }\n            flushLayout();\n            // Set current drag status\n            _this.isDragging = true;\n            _this.currentDirection = null;\n            // Fire onDragStart event\n            (_b = (_a = _this.props).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a, event, info);\n            (_c = _this.visualElement.animationState) === null || _c === void 0 ? void 0 : _c.setActive(AnimationType.Drag, true);\n        };\n        var onMove = function (event, info) {\n            var _a, _b, _c, _d;\n            var _e = _this.props, dragPropagation = _e.dragPropagation, dragDirectionLock = _e.dragDirectionLock;\n            // If we didn't successfully receive the gesture lock, early return.\n            if (!dragPropagation && !_this.openGlobalLock)\n                return;\n            var offset = info.offset;\n            // Attempt to detect drag direction if directionLock is true\n            if (dragDirectionLock && _this.currentDirection === null) {\n                _this.currentDirection = getCurrentDirection(offset);\n                // If we've successfully set a direction, notify listener\n                if (_this.currentDirection !== null) {\n                    (_b = (_a = _this.props).onDirectionLock) === null || _b === void 0 ? void 0 : _b.call(_a, _this.currentDirection);\n                }\n                return;\n            }\n            // Update each point with the latest position\n            _this.updateAxis(\"x\", info.point, offset);\n            _this.updateAxis(\"y\", info.point, offset);\n            // Fire onDrag event\n            (_d = (_c = _this.props).onDrag) === null || _d === void 0 ? void 0 : _d.call(_c, event, info);\n            // Update the last pointer event\n            lastPointerEvent = event;\n        };\n        var onSessionEnd = function (event, info) {\n            return _this.stop(event, info);\n        };\n        var transformPagePoint = this.props.transformPagePoint;\n        this.panSession = new PanSession(originEvent, {\n            onSessionStart: onSessionStart,\n            onStart: onStart,\n            onMove: onMove,\n            onSessionEnd: onSessionEnd,\n        }, { transformPagePoint: transformPagePoint });\n    };\n    VisualElementDragControls.prototype.resolveDragConstraints = function () {\n        var _this = this;\n        var _a = this.props, dragConstraints = _a.dragConstraints, dragElastic = _a.dragElastic;\n        var layout = this.visualElement.getLayoutState().layoutCorrected;\n        if (dragConstraints) {\n            this.constraints = isRefObject(dragConstraints)\n                ? this.resolveRefConstraints(layout, dragConstraints)\n                : calcRelativeConstraints(layout, dragConstraints);\n        }\n        else {\n            this.constraints = false;\n        }\n        this.elastic = resolveDragElastic(dragElastic);\n        /**\n         * If we're outputting to external MotionValues, we want to rebase the measured constraints\n         * from viewport-relative to component-relative.\n         */\n        if (this.constraints && !this.hasMutatedConstraints) {\n            eachAxis(function (axis) {\n                if (_this.getAxisMotionValue(axis)) {\n                    _this.constraints[axis] = rebaseAxisConstraints(layout[axis], _this.constraints[axis]);\n                }\n            });\n        }\n    };\n    VisualElementDragControls.prototype.resolveRefConstraints = function (layoutBox, constraints) {\n        var _a = this.props, onMeasureDragConstraints = _a.onMeasureDragConstraints, transformPagePoint = _a.transformPagePoint;\n        var constraintsElement = constraints.current;\n        heyListen.invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n        this.constraintsBox = getBoundingBox(constraintsElement, transformPagePoint);\n        var measuredConstraints = calcViewportConstraints(layoutBox, this.constraintsBox);\n        /**\n         * If there's an onMeasureDragConstraints listener we call it and\n         * if different constraints are returned, set constraints to that\n         */\n        if (onMeasureDragConstraints) {\n            var userConstraints = onMeasureDragConstraints(convertAxisBoxToBoundingBox(measuredConstraints));\n            this.hasMutatedConstraints = !!userConstraints;\n            if (userConstraints) {\n                measuredConstraints = convertBoundingBoxToAxisBox(userConstraints);\n            }\n        }\n        return measuredConstraints;\n    };\n    VisualElementDragControls.prototype.cancelDrag = function () {\n        var _a, _b;\n        this.visualElement.unlockProjectionTarget();\n        (_a = this.cancelLayout) === null || _a === void 0 ? void 0 : _a.call(this);\n        this.isDragging = false;\n        this.panSession && this.panSession.end();\n        this.panSession = null;\n        if (!this.props.dragPropagation && this.openGlobalLock) {\n            this.openGlobalLock();\n            this.openGlobalLock = null;\n        }\n        (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(AnimationType.Drag, false);\n    };\n    VisualElementDragControls.prototype.stop = function (event, info) {\n        var _a, _b, _c;\n        (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\n        this.panSession = null;\n        var isDragging = this.isDragging;\n        this.cancelDrag();\n        if (!isDragging)\n            return;\n        var velocity = info.velocity;\n        this.animateDragEnd(velocity);\n        (_c = (_b = this.props).onDragEnd) === null || _c === void 0 ? void 0 : _c.call(_b, event, info);\n    };\n    VisualElementDragControls.prototype.snapToCursor = function (point) {\n        var _this = this;\n        return eachAxis(function (axis) {\n            var drag = _this.props.drag;\n            // If we're not dragging this axis, do an early return.\n            if (!shouldDrag(axis, drag, _this.currentDirection))\n                return;\n            var axisValue = _this.getAxisMotionValue(axis);\n            if (axisValue) {\n                var box = _this.visualElement.getLayoutState().layout;\n                var length_1 = box[axis].max - box[axis].min;\n                var center = box[axis].min + length_1 / 2;\n                var offset = point[axis] - center;\n                _this.originPoint[axis] = point[axis];\n                axisValue.set(offset);\n            }\n            else {\n                _this.cursorProgress[axis] = 0.5;\n                return true;\n            }\n        }).includes(true);\n    };\n    /**\n     * Update the specified axis with the latest pointer information.\n     */\n    VisualElementDragControls.prototype.updateAxis = function (axis, point, offset) {\n        var drag = this.props.drag;\n        // If we're not dragging this axis, do an early return.\n        if (!shouldDrag(axis, drag, this.currentDirection))\n            return;\n        return this.getAxisMotionValue(axis)\n            ? this.updateAxisMotionValue(axis, offset)\n            : this.updateVisualElementAxis(axis, point);\n    };\n    VisualElementDragControls.prototype.updateAxisMotionValue = function (axis, offset) {\n        var axisValue = this.getAxisMotionValue(axis);\n        if (!offset || !axisValue)\n            return;\n        var nextValue = this.originPoint[axis] + offset[axis];\n        var update = this.constraints\n            ? applyConstraints(nextValue, this.constraints[axis], this.elastic[axis])\n            : nextValue;\n        axisValue.set(update);\n    };\n    VisualElementDragControls.prototype.updateVisualElementAxis = function (axis, point) {\n        var _a;\n        // Get the actual layout bounding box of the element\n        var axisLayout = this.visualElement.getLayoutState().layout[axis];\n        // Calculate its current length. In the future we might want to lerp this to animate\n        // between lengths if the layout changes as we change the DOM\n        var axisLength = axisLayout.max - axisLayout.min;\n        // Get the initial progress that the pointer sat on this axis on gesture start.\n        var axisProgress = this.cursorProgress[axis];\n        // Calculate a new min point based on the latest pointer position, constraints and elastic\n        var min = calcConstrainedMinPoint(point[axis], axisLength, axisProgress, (_a = this.constraints) === null || _a === void 0 ? void 0 : _a[axis], this.elastic[axis]);\n        // Update the axis viewport target with this new min and the length\n        this.visualElement.setProjectionTargetAxis(axis, min, min + axisLength);\n    };\n    VisualElementDragControls.prototype.setProps = function (_a) {\n        var _b = _a.drag, drag = _b === void 0 ? false : _b, _c = _a.dragDirectionLock, dragDirectionLock = _c === void 0 ? false : _c, _d = _a.dragPropagation, dragPropagation = _d === void 0 ? false : _d, _e = _a.dragConstraints, dragConstraints = _e === void 0 ? false : _e, _f = _a.dragElastic, dragElastic = _f === void 0 ? defaultElastic : _f, _g = _a.dragMomentum, dragMomentum = _g === void 0 ? true : _g, remainingProps = tslib.__rest(_a, [\"drag\", \"dragDirectionLock\", \"dragPropagation\", \"dragConstraints\", \"dragElastic\", \"dragMomentum\"]);\n        this.props = tslib.__assign({ drag: drag,\n            dragDirectionLock: dragDirectionLock,\n            dragPropagation: dragPropagation,\n            dragConstraints: dragConstraints,\n            dragElastic: dragElastic,\n            dragMomentum: dragMomentum }, remainingProps);\n    };\n    /**\n     * Drag works differently depending on which props are provided.\n     *\n     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n     * - If the component will perform layout animations, we output the gesture to the component's\n     *      visual bounding box\n     * - Otherwise, we apply the delta to the x/y motion values.\n     */\n    VisualElementDragControls.prototype.getAxisMotionValue = function (axis) {\n        var _a = this.props, layout = _a.layout, layoutId = _a.layoutId;\n        var dragKey = \"_drag\" + axis.toUpperCase();\n        if (this.props[dragKey]) {\n            return this.props[dragKey];\n        }\n        else if (!layout && layoutId === undefined) {\n            return this.visualElement.getValue(axis, 0);\n        }\n    };\n    VisualElementDragControls.prototype.isLayoutDrag = function () {\n        return !this.getAxisMotionValue(\"x\");\n    };\n    VisualElementDragControls.prototype.isExternalDrag = function () {\n        var _a = this.props, _dragX = _a._dragX, _dragY = _a._dragY;\n        return _dragX || _dragY;\n    };\n    VisualElementDragControls.prototype.animateDragEnd = function (velocity) {\n        var _this = this;\n        var _a = this.props, drag = _a.drag, dragMomentum = _a.dragMomentum, dragElastic = _a.dragElastic, dragTransition = _a.dragTransition;\n        /**\n         * Everything beyond the drag gesture should be performed with\n         * relative projection so children stay in sync with their parent element.\n         */\n        var isRelative = convertToRelativeProjection(this.visualElement, this.isLayoutDrag() && !this.isExternalDrag());\n        /**\n         * If we had previously resolved constraints relative to the viewport,\n         * we need to also convert those to a relative coordinate space for the animation\n         */\n        var constraints = this.constraints || {};\n        if (isRelative &&\n            Object.keys(constraints).length &&\n            this.isLayoutDrag()) {\n            var projectionParent = this.visualElement.getProjectionParent();\n            if (projectionParent) {\n                var relativeConstraints_1 = calcRelativeOffset(projectionParent.projection.targetFinal, constraints);\n                eachAxis(function (axis) {\n                    var _a = relativeConstraints_1[axis], min = _a.min, max = _a.max;\n                    constraints[axis] = {\n                        min: isNaN(min) ? undefined : min,\n                        max: isNaN(max) ? undefined : max,\n                    };\n                });\n            }\n        }\n        var momentumAnimations = eachAxis(function (axis) {\n            var _a;\n            if (!shouldDrag(axis, drag, _this.currentDirection)) {\n                return;\n            }\n            var transition = (_a = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a !== void 0 ? _a : {};\n            /**\n             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n             * using the value of `dragElastic`.\n             */\n            var bounceStiffness = dragElastic ? 200 : 1000000;\n            var bounceDamping = dragElastic ? 40 : 10000000;\n            var inertia = tslib.__assign(tslib.__assign({ type: \"inertia\", velocity: dragMomentum ? velocity[axis] : 0, bounceStiffness: bounceStiffness,\n                bounceDamping: bounceDamping, timeConstant: 750, restDelta: 1, restSpeed: 10 }, dragTransition), transition);\n            // If we're not animating on an externally-provided `MotionValue` we can use the\n            // component's animation controls which will handle interactions with whileHover (etc),\n            // otherwise we just have to animate the `MotionValue` itself.\n            return _this.getAxisMotionValue(axis)\n                ? _this.startAxisValueAnimation(axis, inertia)\n                : _this.visualElement.startLayoutAnimation(axis, inertia, isRelative);\n        });\n        // Run all animations and then resolve the new drag constraints.\n        return Promise.all(momentumAnimations).then(function () {\n            var _a, _b;\n            (_b = (_a = _this.props).onDragTransitionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);\n        });\n    };\n    VisualElementDragControls.prototype.stopMotion = function () {\n        var _this = this;\n        eachAxis(function (axis) {\n            var axisValue = _this.getAxisMotionValue(axis);\n            axisValue\n                ? axisValue.stop()\n                : _this.visualElement.stopLayoutAnimation();\n        });\n    };\n    VisualElementDragControls.prototype.startAxisValueAnimation = function (axis, transition) {\n        var axisValue = this.getAxisMotionValue(axis);\n        if (!axisValue)\n            return;\n        var currentValue = axisValue.get();\n        axisValue.set(currentValue);\n        axisValue.set(currentValue); // Set twice to hard-reset velocity\n        return startAnimation(axis, axisValue, 0, transition);\n    };\n    VisualElementDragControls.prototype.scalePoint = function () {\n        var _this = this;\n        var _a = this.props, drag = _a.drag, dragConstraints = _a.dragConstraints;\n        if (!isRefObject(dragConstraints) || !this.constraintsBox)\n            return;\n        // Stop any current animations as there can be some visual glitching if we resize mid animation\n        this.stopMotion();\n        // Record the relative progress of the targetBox relative to the constraintsBox\n        var boxProgress = { x: 0, y: 0 };\n        eachAxis(function (axis) {\n            boxProgress[axis] = calcOrigin(_this.visualElement.projection.target[axis], _this.constraintsBox[axis]);\n        });\n        /**\n         * For each axis, calculate the current progress of the layout axis within the constraints.\n         * Then, using the latest layout and constraints measurements, reposition the new layout axis\n         * proportionally within the constraints.\n         */\n        this.updateConstraints(function () {\n            eachAxis(function (axis) {\n                if (!shouldDrag(axis, drag, null))\n                    return;\n                // Calculate the position of the targetBox relative to the constraintsBox using the\n                // previously calculated progress\n                var _a = calcPositionFromProgress(_this.visualElement.projection.target[axis], _this.constraintsBox[axis], boxProgress[axis]), min = _a.min, max = _a.max;\n                _this.visualElement.setProjectionTargetAxis(axis, min, max);\n            });\n        });\n        /**\n         * If any other draggable components are queuing the same tasks synchronously\n         * this will wait until they've all been scheduled before flushing.\n         */\n        setTimeout(flushLayout, 1);\n    };\n    VisualElementDragControls.prototype.updateConstraints = function (onReady) {\n        var _this = this;\n        this.cancelLayout = batchLayout(function (read, write) {\n            var ancestors = collectProjectingAncestors(_this.visualElement);\n            write(function () {\n                return ancestors.forEach(function (element) { return element.resetTransform(); });\n            });\n            read(function () { return updateLayoutMeasurement(_this.visualElement); });\n            write(function () {\n                return ancestors.forEach(function (element) { return element.restoreTransform(); });\n            });\n            read(function () {\n                _this.resolveDragConstraints();\n            });\n            if (onReady)\n                write(onReady);\n        });\n    };\n    VisualElementDragControls.prototype.mount = function (visualElement) {\n        var _this = this;\n        var element = visualElement.getInstance();\n        /**\n         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n         */\n        var stopPointerListener = addPointerEvent(element, \"pointerdown\", function (event) {\n            var _a = _this.props, drag = _a.drag, _b = _a.dragListener, dragListener = _b === void 0 ? true : _b;\n            drag && dragListener && _this.start(event);\n        });\n        /**\n         * Attach a window resize listener to scale the draggable target within its defined\n         * constraints as the window resizes.\n         */\n        var stopResizeListener = addDomEvent(window, \"resize\", function () {\n            _this.scalePoint();\n        });\n        /**\n         * Ensure drag constraints are resolved correctly relative to the dragging element\n         * whenever its layout changes.\n         */\n        var stopLayoutUpdateListener = visualElement.onLayoutUpdate(function () {\n            if (_this.isDragging) {\n                _this.resolveDragConstraints();\n            }\n        });\n        /**\n         * If the previous component with this same layoutId was dragging at the time\n         * it was unmounted, we want to continue the same gesture on this component.\n         */\n        var prevDragCursor = visualElement.prevDragCursor;\n        if (prevDragCursor) {\n            this.start(lastPointerEvent, { cursorProgress: prevDragCursor });\n        }\n        /**\n         * Return a function that will teardown the drag gesture\n         */\n        return function () {\n            stopPointerListener === null || stopPointerListener === void 0 ? void 0 : stopPointerListener();\n            stopResizeListener === null || stopResizeListener === void 0 ? void 0 : stopResizeListener();\n            stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();\n            _this.cancelDrag();\n        };\n    };\n    return VisualElementDragControls;\n}());\nfunction shouldDrag(direction, drag, currentDirection) {\n    return ((drag === true || drag === direction) &&\n        (currentDirection === null || currentDirection === direction));\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\nfunction getCurrentDirection(offset, lockThreshold) {\n    if (lockThreshold === void 0) { lockThreshold = 10; }\n    var direction = null;\n    if (Math.abs(offset.y) > lockThreshold) {\n        direction = \"y\";\n    }\n    else if (Math.abs(offset.x) > lockThreshold) {\n        direction = \"x\";\n    }\n    return direction;\n}\n\n/**\n * A hook that allows an element to be dragged.\n *\n * @internal\n */\nfunction useDrag(props) {\n    var groupDragControls = props.dragControls, visualElement = props.visualElement;\n    var transformPagePoint = React.useContext(MotionConfigContext).transformPagePoint;\n    var dragControls = useConstant(function () {\n        return new VisualElementDragControls({\n            visualElement: visualElement,\n        });\n    });\n    dragControls.setProps(tslib.__assign(tslib.__assign({}, props), { transformPagePoint: transformPagePoint }));\n    // If we've been provided a DragControls for manual control over the drag gesture,\n    // subscribe this component to it on mount.\n    React.useEffect(function () { return groupDragControls && groupDragControls.subscribe(dragControls); }, [dragControls]);\n    // Mount the drag controls with the visualElement\n    React.useEffect(function () { return dragControls.mount(visualElement); }, []);\n}\n\n/**\n *\n * @param handlers -\n * @param ref -\n *\n * @internalremarks\n * Currently this sets new pan gesture functions every render. The memo route has been explored\n * in the past but ultimately we're still creating new functions every render. An optimisation\n * to explore is creating the pan gestures and loading them into a `ref`.\n *\n * @internal\n */\nfunction usePanGesture(_a) {\n    var onPan = _a.onPan, onPanStart = _a.onPanStart, onPanEnd = _a.onPanEnd, onPanSessionStart = _a.onPanSessionStart, visualElement = _a.visualElement;\n    var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\n    var panSession = React.useRef(null);\n    var transformPagePoint = React.useContext(MotionConfigContext).transformPagePoint;\n    var handlers = {\n        onSessionStart: onPanSessionStart,\n        onStart: onPanStart,\n        onMove: onPan,\n        onEnd: function (event, info) {\n            panSession.current = null;\n            onPanEnd && onPanEnd(event, info);\n        },\n    };\n    React.useEffect(function () {\n        if (panSession.current !== null) {\n            panSession.current.updateHandlers(handlers);\n        }\n    });\n    function onPointerDown(event) {\n        panSession.current = new PanSession(event, handlers, {\n            transformPagePoint: transformPagePoint,\n        });\n    }\n    usePointerEvent(visualElement, \"pointerdown\", hasPanEvents && onPointerDown);\n    useUnmountEffect(function () { return panSession.current && panSession.current.end(); });\n}\n\nvar drag = {\n    pan: makeRenderlessComponent(usePanGesture),\n    drag: makeRenderlessComponent(useDrag),\n};\n\n/**\n * @public\n */\nvar Presence;\n(function (Presence) {\n    Presence[Presence[\"Entering\"] = 0] = \"Entering\";\n    Presence[Presence[\"Present\"] = 1] = \"Present\";\n    Presence[Presence[\"Exiting\"] = 2] = \"Exiting\";\n})(Presence || (Presence = {}));\n/**\n * @public\n */\nexports.VisibilityAction = void 0;\n(function (VisibilityAction) {\n    VisibilityAction[VisibilityAction[\"Hide\"] = 0] = \"Hide\";\n    VisibilityAction[VisibilityAction[\"Show\"] = 1] = \"Show\";\n})(exports.VisibilityAction || (exports.VisibilityAction = {}));\n\nfunction isCSSVariable(value) {\n    return typeof value === \"string\" && value.startsWith(\"var(--\");\n}\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction parseCSSVariable(current) {\n    var match = cssVariableRegex.exec(current);\n    if (!match)\n        return [,];\n    var _a = tslib.__read(match, 3), token = _a[1], fallback = _a[2];\n    return [token, fallback];\n}\nvar maxDepth = 4;\nfunction getVariableValue(current, element, depth) {\n    if (depth === void 0) { depth = 1; }\n    heyListen.invariant(depth <= maxDepth, \"Max CSS variable fallback depth detected in property \\\"\" + current + \"\\\". This may indicate a circular fallback dependency.\");\n    var _a = tslib.__read(parseCSSVariable(current), 2), token = _a[0], fallback = _a[1];\n    // No CSS variable detected\n    if (!token)\n        return;\n    // Attempt to read this CSS variable off the element\n    var resolved = window.getComputedStyle(element).getPropertyValue(token);\n    if (resolved) {\n        return resolved.trim();\n    }\n    else if (isCSSVariable(fallback)) {\n        // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n        return getVariableValue(fallback, element, depth + 1);\n    }\n    else {\n        return fallback;\n    }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\nfunction resolveCSSVariables(visualElement, _a, transitionEnd) {\n    var _b;\n    var target = tslib.__rest(_a, []);\n    var element = visualElement.getInstance();\n    if (!(element instanceof HTMLElement))\n        return { target: target, transitionEnd: transitionEnd };\n    // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n    // only if they change but I think this reads clearer and this isn't a performance-critical path.\n    if (transitionEnd) {\n        transitionEnd = tslib.__assign({}, transitionEnd);\n    }\n    // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n    visualElement.forEachValue(function (value) {\n        var current = value.get();\n        if (!isCSSVariable(current))\n            return;\n        var resolved = getVariableValue(current, element);\n        if (resolved)\n            value.set(resolved);\n    });\n    // Cycle through every target property and resolve CSS variables. Currently\n    // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n    for (var key in target) {\n        var current = target[key];\n        if (!isCSSVariable(current))\n            continue;\n        var resolved = getVariableValue(current, element);\n        if (!resolved)\n            continue;\n        // Clone target if it hasn't already been\n        target[key] = resolved;\n        // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n        // CSS variable. This will ensure that after the animation the component will reflect\n        // changes in the value of the CSS variable.\n        if (transitionEnd)\n            (_b = transitionEnd[key]) !== null && _b !== void 0 ? _b : (transitionEnd[key] = current);\n    }\n    return { target: target, transitionEnd: transitionEnd };\n}\n\nfunction pixelsToPercent(pixels, axis) {\n    return (pixels / (axis.max - axis.min)) * 100;\n}\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\n */\nfunction correctBorderRadius(latest, _layoutState, _a) {\n    var target = _a.target;\n    /**\n     * If latest is a string, if it's a percentage we can return immediately as it's\n     * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\n     */\n    if (typeof latest === \"string\") {\n        if (styleValueTypes.px.test(latest)) {\n            latest = parseFloat(latest);\n        }\n        else {\n            return latest;\n        }\n    }\n    /**\n     * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\n     * pixel value as a percentage of each axis\n     */\n    var x = pixelsToPercent(latest, target.x);\n    var y = pixelsToPercent(latest, target.y);\n    return x + \"% \" + y + \"%\";\n}\nvar varToken = \"_$css\";\nfunction correctBoxShadow(latest, _a) {\n    var delta = _a.delta, treeScale = _a.treeScale;\n    var original = latest;\n    /**\n     * We need to first strip and store CSS variables from the string.\n     */\n    var containsCSSVariables = latest.includes(\"var(\");\n    var cssVariables = [];\n    if (containsCSSVariables) {\n        latest = latest.replace(cssVariableRegex, function (match) {\n            cssVariables.push(match);\n            return varToken;\n        });\n    }\n    var shadow = styleValueTypes.complex.parse(latest);\n    // TODO: Doesn't support multiple shadows\n    if (shadow.length > 5)\n        return original;\n    var template = styleValueTypes.complex.createTransformer(latest);\n    var offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n    // Calculate the overall context scale\n    var xScale = delta.x.scale * treeScale.x;\n    var yScale = delta.y.scale * treeScale.y;\n    shadow[0 + offset] /= xScale;\n    shadow[1 + offset] /= yScale;\n    /**\n     * Ideally we'd correct x and y scales individually, but because blur and\n     * spread apply to both we have to take a scale average and apply that instead.\n     * We could potentially improve the outcome of this by incorporating the ratio between\n     * the two scales.\n     */\n    var averageScale = popmotion.mix(xScale, yScale, 0.5);\n    // Blur\n    if (typeof shadow[2 + offset] === \"number\")\n        shadow[2 + offset] /= averageScale;\n    // Spread\n    if (typeof shadow[3 + offset] === \"number\")\n        shadow[3 + offset] /= averageScale;\n    var output = template(shadow);\n    if (containsCSSVariables) {\n        var i_1 = 0;\n        output = output.replace(varToken, function () {\n            var cssVariable = cssVariables[i_1];\n            i_1++;\n            return cssVariable;\n        });\n    }\n    return output;\n}\nvar borderCorrectionDefinition = {\n    process: correctBorderRadius,\n};\nvar defaultScaleCorrectors = {\n    borderRadius: tslib.__assign(tslib.__assign({}, borderCorrectionDefinition), { applyTo: [\n            \"borderTopLeftRadius\",\n            \"borderTopRightRadius\",\n            \"borderBottomLeftRadius\",\n            \"borderBottomRightRadius\",\n        ] }),\n    borderTopLeftRadius: borderCorrectionDefinition,\n    borderTopRightRadius: borderCorrectionDefinition,\n    borderBottomLeftRadius: borderCorrectionDefinition,\n    borderBottomRightRadius: borderCorrectionDefinition,\n    boxShadow: {\n        process: correctBoxShadow,\n    },\n};\n\nvar progressTarget = 1000;\nvar Animate = /** @class */ (function (_super) {\n    tslib.__extends(Animate, _super);\n    function Animate() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * A mutable object that tracks the target viewport box\n         * for the current animation frame.\n         */\n        _this.frameTarget = axisBox();\n        /**\n         * The current animation target, we use this to check whether to start\n         * a new animation or continue the existing one.\n         */\n        _this.currentAnimationTarget = axisBox();\n        /**\n         * Track whether we're animating this axis.\n         */\n        _this.isAnimating = {\n            x: false,\n            y: false,\n        };\n        _this.stopAxisAnimation = {\n            x: undefined,\n            y: undefined,\n        };\n        _this.isAnimatingTree = false;\n        _this.animate = function (target, origin, _a) {\n            if (_a === void 0) { _a = {}; }\n            var originBox = _a.originBox, targetBox = _a.targetBox, visibilityAction = _a.visibilityAction, shouldStackAnimate = _a.shouldStackAnimate, onComplete = _a.onComplete, prevParent = _a.prevParent, config = tslib.__rest(_a, [\"originBox\", \"targetBox\", \"visibilityAction\", \"shouldStackAnimate\", \"onComplete\", \"prevParent\"]);\n            var _b = _this.props, visualElement = _b.visualElement, layout = _b.layout;\n            /**\n             * Early return if we've been instructed not to animate this render.\n             */\n            if (shouldStackAnimate === false) {\n                _this.isAnimatingTree = false;\n                return _this.safeToRemove();\n            }\n            /**\n             * Prioritise tree animations\n             */\n            if (_this.isAnimatingTree && shouldStackAnimate !== true) {\n                return;\n            }\n            else if (shouldStackAnimate) {\n                _this.isAnimatingTree = true;\n            }\n            /**\n             * Allow the measured origin (prev bounding box) and target (actual layout) to be\n             * overridden by the provided config.\n             */\n            origin = originBox || origin;\n            target = targetBox || target;\n            /**\n             * If this element has a projecting parent, there's an opportunity to animate\n             * it relatively to that parent rather than relatively to the viewport. This\n             * allows us to add orchestrated animations.\n             */\n            var isRelative = false;\n            var projectionParent = visualElement.getProjectionParent();\n            if (projectionParent) {\n                var prevParentViewportBox = projectionParent.prevViewportBox;\n                var parentLayout = projectionParent.getLayoutState().layout;\n                /**\n                 * If we're being provided a previous parent VisualElement by AnimateSharedLayout\n                 */\n                if (prevParent) {\n                    /**\n                     * If we've been provided an explicit target box it means we're animating back\n                     * to this previous parent. So we can make a relative box by comparing to the previous\n                     * parent's layout\n                     */\n                    if (targetBox) {\n                        parentLayout = prevParent.getLayoutState().layout;\n                    }\n                    /**\n                     * Likewise if we've been provided an explicit origin box it means we're\n                     * animating out from a different element. So we should figure out where that was\n                     * on screen relative to the new parent element.\n                     */\n                    if (originBox &&\n                        !checkIfParentHasChanged(prevParent, projectionParent) &&\n                        prevParent.prevViewportBox) {\n                        prevParentViewportBox = prevParent.prevViewportBox;\n                    }\n                }\n                if (prevParentViewportBox &&\n                    isProvidedCorrectDataForRelativeSharedLayout(prevParent, originBox, targetBox)) {\n                    isRelative = true;\n                    origin = calcRelativeOffset(prevParentViewportBox, origin);\n                    target = calcRelativeOffset(parentLayout, target);\n                }\n            }\n            var boxHasMoved = hasMoved(origin, target);\n            var animations = eachAxis(function (axis) {\n                var _a, _b;\n                /**\n                 * If layout is set to \"position\", we can resize the origin box based on the target\n                 * box and only animate its position.\n                 */\n                if (layout === \"position\") {\n                    var targetLength = target[axis].max - target[axis].min;\n                    origin[axis].max = origin[axis].min + targetLength;\n                }\n                if (visualElement.projection.isTargetLocked) {\n                    return;\n                }\n                else if (visibilityAction !== undefined) {\n                    visualElement.setVisibility(visibilityAction === exports.VisibilityAction.Show);\n                }\n                else if (boxHasMoved) {\n                    // If the box has moved, animate between it's current visual state and its\n                    // final state\n                    return _this.animateAxis(axis, target[axis], origin[axis], tslib.__assign(tslib.__assign({}, config), { isRelative: isRelative }));\n                }\n                else {\n                    (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a);\n                    // If the box has remained in the same place, immediately set the axis target\n                    // to the final desired state\n                    return visualElement.setProjectionTargetAxis(axis, target[axis].min, target[axis].max, isRelative);\n                }\n            });\n            // Force a render to ensure there's no flash of uncorrected bounding box.\n            visualElement.syncRender();\n            /**\n             * If this visualElement isn't present (ie it's been removed from the tree by the user but\n             * kept in by the tree by AnimatePresence) then call safeToRemove when all axis animations\n             * have successfully finished.\n             */\n            return Promise.all(animations).then(function () {\n                _this.isAnimatingTree = false;\n                onComplete && onComplete();\n                visualElement.notifyLayoutAnimationComplete();\n            });\n        };\n        return _this;\n    }\n    Animate.prototype.componentDidMount = function () {\n        var _this = this;\n        var visualElement = this.props.visualElement;\n        visualElement.animateMotionValue = startAnimation;\n        visualElement.enableLayoutProjection();\n        this.unsubLayoutReady = visualElement.onLayoutUpdate(this.animate);\n        visualElement.layoutSafeToRemove = function () { return _this.safeToRemove(); };\n        addScaleCorrection(defaultScaleCorrectors);\n    };\n    Animate.prototype.componentWillUnmount = function () {\n        var _this = this;\n        this.unsubLayoutReady();\n        eachAxis(function (axis) { var _a, _b; return (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a); });\n    };\n    /**\n     * TODO: This manually performs animations on the visualElement's layout progress\n     * values. It'd be preferable to amend the startLayoutAxisAnimation\n     * API to accept more custom animations like this.\n     */\n    Animate.prototype.animateAxis = function (axis, target, origin, _a) {\n        var _this = this;\n        var _b, _c;\n        var _d = _a === void 0 ? {} : _a, transition = _d.transition, isRelative = _d.isRelative;\n        /**\n         * If we're not animating to a new target, don't run this animation\n         */\n        if (this.isAnimating[axis] &&\n            axisIsEqual(target, this.currentAnimationTarget[axis])) {\n            return;\n        }\n        (_c = (_b = this.stopAxisAnimation)[axis]) === null || _c === void 0 ? void 0 : _c.call(_b);\n        this.isAnimating[axis] = true;\n        var visualElement = this.props.visualElement;\n        var frameTarget = this.frameTarget[axis];\n        var layoutProgress = visualElement.getProjectionAnimationProgress()[axis];\n        /**\n         * Set layout progress back to 0. We set it twice to hard-reset any velocity that might\n         * be re-incoporated into a subsequent spring animation.\n         */\n        layoutProgress.clearListeners();\n        layoutProgress.set(0);\n        layoutProgress.set(0);\n        /**\n         * Create an animation function to run once per frame. This will tween the visual bounding box from\n         * origin to target using the latest progress value.\n         */\n        var frame = function () {\n            // Convert the latest layoutProgress, which is a value from 0-1000, into a 0-1 progress\n            var p = layoutProgress.get() / progressTarget;\n            // Tween the axis and update the visualElement with the latest values\n            tweenAxis(frameTarget, origin, target, p);\n            visualElement.setProjectionTargetAxis(axis, frameTarget.min, frameTarget.max, isRelative);\n        };\n        // Synchronously run a frame to ensure there's no flash of the uncorrected bounding box.\n        frame();\n        // Create a function to stop animation on this specific axis\n        var unsubscribeProgress = layoutProgress.onChange(frame);\n        this.stopAxisAnimation[axis] = function () {\n            _this.isAnimating[axis] = false;\n            layoutProgress.stop();\n            unsubscribeProgress();\n        };\n        this.currentAnimationTarget[axis] = target;\n        var layoutTransition = transition ||\n            visualElement.getDefaultTransition() ||\n            defaultLayoutTransition;\n        // Start the animation on this axis\n        var animation = startAnimation(axis === \"x\" ? \"layoutX\" : \"layoutY\", layoutProgress, progressTarget, layoutTransition && getValueTransition(layoutTransition, \"layout\")).then(this.stopAxisAnimation[axis]);\n        return animation;\n    };\n    Animate.prototype.safeToRemove = function () {\n        var _a, _b;\n        (_b = (_a = this.props).safeToRemove) === null || _b === void 0 ? void 0 : _b.call(_a);\n    };\n    Animate.prototype.render = function () {\n        return null;\n    };\n    return Animate;\n}(React__namespace.Component));\nfunction AnimateLayoutContextProvider(props) {\n    var _a = tslib.__read(usePresence(), 2), safeToRemove = _a[1];\n    return React__namespace.createElement(Animate, tslib.__assign({}, props, { safeToRemove: safeToRemove }));\n}\nfunction hasMoved(a, b) {\n    return (!isZeroBox(a) &&\n        !isZeroBox(b) &&\n        (!axisIsEqual(a.x, b.x) || !axisIsEqual(a.y, b.y)));\n}\nvar zeroAxis = { min: 0, max: 0 };\nfunction isZeroBox(a) {\n    return axisIsEqual(a.x, zeroAxis) && axisIsEqual(a.y, zeroAxis);\n}\nfunction axisIsEqual(a, b) {\n    return a.min === b.min && a.max === b.max;\n}\nvar defaultLayoutTransition = {\n    duration: 0.45,\n    ease: [0.4, 0, 0.1, 1],\n};\nfunction isProvidedCorrectDataForRelativeSharedLayout(prevParent, originBox, targetBox) {\n    return prevParent || (!prevParent && !(originBox || targetBox));\n}\n\n/**\n * Default handlers for batching VisualElements\n */\nvar defaultHandler = {\n    layoutReady: function (child) { return child.notifyLayoutReady(); },\n};\n/**\n * Create a batcher to process VisualElements\n */\nfunction createBatcher() {\n    var queue = new Set();\n    return {\n        add: function (child) { return queue.add(child); },\n        flush: function (_a) {\n            var _b = _a === void 0 ? defaultHandler : _a, layoutReady = _b.layoutReady, parent = _b.parent;\n            batchLayout(function (read, write) {\n                var order = Array.from(queue).sort(compareByDepth);\n                var ancestors = parent\n                    ? collectProjectingAncestors(parent)\n                    : [];\n                write(function () {\n                    var allElements = tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(ancestors)), tslib.__read(order));\n                    allElements.forEach(function (element) { return element.resetTransform(); });\n                });\n                read(function () {\n                    order.forEach(updateLayoutMeasurement);\n                });\n                write(function () {\n                    ancestors.forEach(function (element) { return element.restoreTransform(); });\n                    order.forEach(layoutReady);\n                });\n                read(function () {\n                    /**\n                     * After all children have started animating, ensure any Entering components are set to Present.\n                     * If we add deferred animations (set up all animations and then start them in two loops) this\n                     * could be moved to the start loop. But it needs to happen after all the animations configs\n                     * are generated in AnimateSharedLayout as this relies on presence data\n                     */\n                    order.forEach(function (child) {\n                        if (child.isPresent)\n                            child.presence = Presence.Present;\n                    });\n                });\n                write(function () {\n                    /**\n                     * Starting these animations will have queued jobs on the frame loop. In some situations,\n                     * like when removing an element, these will be processed too late after the DOM is manipulated,\n                     * leaving a flash of incorrectly-projected content. By manually flushing these jobs\n                     * we ensure there's no flash.\n                     */\n                    sync.flushSync.preRender();\n                    sync.flushSync.render();\n                });\n                read(function () {\n                    /**\n                     * Schedule a callback at the end of the following frame to assign the latest projection\n                     * box to the prevViewportBox snapshot. Once global batching is in place this could be run\n                     * synchronously. But for now it ensures that if any nested `AnimateSharedLayout` top-level\n                     * child attempts to calculate its previous relative position against a prevViewportBox\n                     * it will be against its latest projection box instead, as the snapshot is useless beyond this\n                     * render.\n                     */\n                    sync__default['default'].postRender(function () {\n                        return order.forEach(assignProjectionToSnapshot);\n                    });\n                    queue.clear();\n                });\n            });\n            // TODO: Need to find a layout-synchronous way of flushing this\n            flushLayout();\n        },\n    };\n}\nfunction assignProjectionToSnapshot(child) {\n    child.prevViewportBox = child.projection.target;\n}\n\nvar SharedLayoutContext = React.createContext(createBatcher());\n/**\n * @internal\n */\nvar FramerTreeLayoutContext = React.createContext(createBatcher());\nfunction isSharedLayout(context) {\n    return !!context.forceUpdate;\n}\n\n/**\n * This component is responsible for scheduling the measuring of the motion component\n */\nvar Measure = /** @class */ (function (_super) {\n    tslib.__extends(Measure, _super);\n    function Measure() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * If this is a child of a SyncContext, register the VisualElement with it on mount.\n     */\n    Measure.prototype.componentDidMount = function () {\n        var _a = this.props, syncLayout = _a.syncLayout, framerSyncLayout = _a.framerSyncLayout, visualElement = _a.visualElement;\n        isSharedLayout(syncLayout) && syncLayout.register(visualElement);\n        isSharedLayout(framerSyncLayout) &&\n            framerSyncLayout.register(visualElement);\n        visualElement.onUnmount(function () {\n            if (isSharedLayout(syncLayout)) {\n                syncLayout.remove(visualElement);\n            }\n            if (isSharedLayout(framerSyncLayout)) {\n                framerSyncLayout.remove(visualElement);\n            }\n        });\n    };\n    /**\n     * If this is a child of a SyncContext, notify it that it needs to re-render. It will then\n     * handle the snapshotting.\n     *\n     * If it is stand-alone component, add it to the batcher.\n     */\n    Measure.prototype.getSnapshotBeforeUpdate = function () {\n        var _a = this.props, syncLayout = _a.syncLayout, visualElement = _a.visualElement;\n        if (isSharedLayout(syncLayout)) {\n            syncLayout.syncUpdate();\n        }\n        else {\n            snapshotViewportBox(visualElement);\n            syncLayout.add(visualElement);\n        }\n        return null;\n    };\n    Measure.prototype.componentDidUpdate = function () {\n        var syncLayout = this.props.syncLayout;\n        if (!isSharedLayout(syncLayout))\n            syncLayout.flush();\n    };\n    Measure.prototype.render = function () {\n        return null;\n    };\n    return Measure;\n}(React__default['default'].Component));\nfunction MeasureContextProvider(props) {\n    var syncLayout = React.useContext(SharedLayoutContext);\n    var framerSyncLayout = React.useContext(FramerTreeLayoutContext);\n    return (React__default['default'].createElement(Measure, tslib.__assign({}, props, { syncLayout: syncLayout, framerSyncLayout: framerSyncLayout })));\n}\n\nvar layoutAnimations = {\n    measureLayout: MeasureContextProvider,\n    layoutAnimation: AnimateLayoutContextProvider,\n};\n\nvar createProjectionState = function () { return ({\n    isEnabled: false,\n    isHydrated: false,\n    isTargetLocked: false,\n    target: axisBox(),\n    targetFinal: axisBox(),\n}); };\nfunction createLayoutState() {\n    return {\n        isHydrated: false,\n        layout: axisBox(),\n        layoutCorrected: axisBox(),\n        treeScale: { x: 1, y: 1 },\n        delta: delta(),\n        deltaFinal: delta(),\n        deltaTransform: \"\",\n    };\n}\nvar zeroLayout = createLayoutState();\n\n/**\n * Build a transform style that takes a calculated delta between the element's current\n * space on screen and projects it into the desired space.\n */\nfunction buildLayoutProjectionTransform(_a, treeScale, latestTransform) {\n    var x = _a.x, y = _a.y;\n    /**\n     * The translations we use to calculate are always relative to the viewport coordinate space.\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n     */\n    var xTranslate = x.translate / treeScale.x;\n    var yTranslate = y.translate / treeScale.y;\n    var transform = \"translate3d(\" + xTranslate + \"px, \" + yTranslate + \"px, 0) \";\n    if (latestTransform) {\n        var rotate = latestTransform.rotate, rotateX = latestTransform.rotateX, rotateY = latestTransform.rotateY;\n        if (rotate)\n            transform += \"rotate(\" + rotate + \") \";\n        if (rotateX)\n            transform += \"rotateX(\" + rotateX + \") \";\n        if (rotateY)\n            transform += \"rotateY(\" + rotateY + \") \";\n    }\n    transform += \"scale(\" + x.scale + \", \" + y.scale + \")\";\n    return !latestTransform && transform === identityProjection ? \"\" : transform;\n}\n/**\n * Take the calculated delta origin and apply it as a transform string.\n */\nfunction buildLayoutProjectionTransformOrigin(_a) {\n    var deltaFinal = _a.deltaFinal;\n    return deltaFinal.x.origin * 100 + \"% \" + deltaFinal.y.origin * 100 + \"% 0\";\n}\nvar identityProjection = buildLayoutProjectionTransform(zeroLayout.delta, zeroLayout.treeScale, { x: 1, y: 1 });\n\nvar names = [\n    \"LayoutMeasure\",\n    \"BeforeLayoutMeasure\",\n    \"LayoutUpdate\",\n    \"ViewportBoxUpdate\",\n    \"Update\",\n    \"Render\",\n    \"AnimationComplete\",\n    \"LayoutAnimationComplete\",\n    \"AnimationStart\",\n    \"SetAxisTarget\",\n    \"Unmount\",\n];\nfunction createLifecycles() {\n    var managers = names.map(function () { return new SubscriptionManager(); });\n    var propSubscriptions = {};\n    var lifecycles = {\n        clearAllListeners: function () { return managers.forEach(function (manager) { return manager.clear(); }); },\n        updatePropListeners: function (props) {\n            return names.forEach(function (name) {\n                var _a;\n                (_a = propSubscriptions[name]) === null || _a === void 0 ? void 0 : _a.call(propSubscriptions);\n                var on = \"on\" + name;\n                var propListener = props[on];\n                if (propListener) {\n                    propSubscriptions[name] = lifecycles[on](propListener);\n                }\n            });\n        },\n    };\n    managers.forEach(function (manager, i) {\n        lifecycles[\"on\" + names[i]] = function (handler) { return manager.add(handler); };\n        lifecycles[\"notify\" + names[i]] = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return manager.notify.apply(manager, tslib.__spreadArray([], tslib.__read(args)));\n        };\n    });\n    return lifecycles;\n}\n\nfunction updateMotionValuesFromProps(element, next, prev) {\n    var _a;\n    for (var key in next) {\n        var nextValue = next[key];\n        var prevValue = prev[key];\n        if (isMotionValue(nextValue)) {\n            /**\n             * If this is a motion value found in props or style, we want to add it\n             * to our visual element's motion value map.\n             */\n            element.addValue(key, nextValue);\n        }\n        else if (isMotionValue(prevValue)) {\n            /**\n             * If we're swapping to a new motion value, create a new motion value\n             * from that\n             */\n            element.addValue(key, motionValue(nextValue));\n        }\n        else if (prevValue !== nextValue) {\n            /**\n             * If this is a flat value that has changed, update the motion value\n             * or create one if it doesn't exist. We only want to do this if we're\n             * not handling the value with our animation state.\n             */\n            if (element.hasValue(key)) {\n                var existingValue = element.getValue(key);\n                // TODO: Only update values that aren't being animated or even looked at\n                !existingValue.hasAnimated && existingValue.set(nextValue);\n            }\n            else {\n                element.addValue(key, motionValue((_a = element.getStaticValue(key)) !== null && _a !== void 0 ? _a : nextValue));\n            }\n        }\n    }\n    // Handle removed values\n    for (var key in prev) {\n        if (next[key] === undefined)\n            element.removeValue(key);\n    }\n    return next;\n}\n\nfunction updateLayoutDeltas(_a, _b, treePath, transformOrigin) {\n    var delta = _a.delta, layout = _a.layout, layoutCorrected = _a.layoutCorrected, treeScale = _a.treeScale;\n    var target = _b.target;\n    /**\n     * Reset the corrected box with the latest values from box, as we're then going\n     * to perform mutative operations on it.\n     */\n    resetBox(layoutCorrected, layout);\n    /**\n     * Apply all the parent deltas to this box to produce the corrected box. This\n     * is the layout box, as it will appear on screen as a result of the transforms of its parents.\n     */\n    applyTreeDeltas(layoutCorrected, treeScale, treePath);\n    /**\n     * Update the delta between the corrected box and the target box before user-set transforms were applied.\n     * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\n     * for our layout reprojection, but still allow them to be scaled correctly by the user.\n     * It might be that to simplify this we may want to accept that user-set scale is also corrected\n     * and we wouldn't have to keep and calc both deltas, OR we could support a user setting\n     * to allow people to choose whether these styles are corrected based on just the\n     * layout reprojection or the final bounding box.\n     */\n    updateBoxDelta(delta, layoutCorrected, target, transformOrigin);\n}\n\nvar FlatTree = /** @class */ (function () {\n    function FlatTree() {\n        this.children = [];\n        this.isDirty = false;\n    }\n    FlatTree.prototype.add = function (child) {\n        addUniqueItem(this.children, child);\n        this.isDirty = true;\n    };\n    FlatTree.prototype.remove = function (child) {\n        removeItem(this.children, child);\n        this.isDirty = true;\n    };\n    FlatTree.prototype.forEach = function (callback) {\n        this.isDirty && this.children.sort(compareByDepth);\n        this.isDirty = false;\n        this.children.forEach(callback);\n    };\n    return FlatTree;\n}());\n\nfunction setCurrentViewportBox(visualElement) {\n    var projectionParent = visualElement.getProjectionParent();\n    if (!projectionParent) {\n        visualElement.rebaseProjectionTarget();\n        return;\n    }\n    var relativeOffset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement.getLayoutState().layout);\n    eachAxis(function (axis) {\n        visualElement.setProjectionTargetAxis(axis, relativeOffset[axis].min, relativeOffset[axis].max, true);\n    });\n}\n\nvar visualElement = function (_a) {\n    var _b = _a.treeType, treeType = _b === void 0 ? \"\" : _b, build = _a.build, getBaseTarget = _a.getBaseTarget, makeTargetAnimatable = _a.makeTargetAnimatable, measureViewportBox = _a.measureViewportBox, renderInstance = _a.render, readValueFromInstance = _a.readValueFromInstance, resetTransform = _a.resetTransform, restoreTransform = _a.restoreTransform, removeValueFromRenderState = _a.removeValueFromRenderState, sortNodePosition = _a.sortNodePosition, scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps;\n    return function (_a, options) {\n        var parent = _a.parent, props = _a.props, presenceId = _a.presenceId, blockInitialAnimation = _a.blockInitialAnimation, visualState = _a.visualState;\n        if (options === void 0) { options = {}; }\n        var latestValues = visualState.latestValues, renderState = visualState.renderState;\n        /**\n         * The instance of the render-specific node that will be hydrated by the\n         * exposed React ref. So for example, this visual element can host a\n         * HTMLElement, plain object, or Three.js object. The functions provided\n         * in VisualElementConfig allow us to interface with this instance.\n         */\n        var instance;\n        /**\n         * Manages the subscriptions for a visual element's lifecycle, for instance\n         * onRender and onViewportBoxUpdate.\n         */\n        var lifecycles = createLifecycles();\n        /**\n         *\n         */\n        var projection = createProjectionState();\n        /**\n         * A reference to the nearest projecting parent. This is either\n         * undefined if we haven't looked for the nearest projecting parent,\n         * false if there is no parent performing layout projection, or a reference\n         * to the projecting parent.\n         */\n        var projectionParent;\n        /**\n         * This is a reference to the visual state of the \"lead\" visual element.\n         * Usually, this will be this visual element. But if it shares a layoutId\n         * with other visual elements, only one of them will be designated lead by\n         * AnimateSharedLayout. All the other visual elements will take on the visual\n         * appearance of the lead while they crossfade to it.\n         */\n        var leadProjection = projection;\n        var leadLatestValues = latestValues;\n        var unsubscribeFromLeadVisualElement;\n        /**\n         * The latest layout measurements and calculated projections. This\n         * is seperate from the target projection data in visualState as\n         * many visual elements might point to the same piece of visualState as\n         * a target, whereas they might each have different layouts and thus\n         * projection calculations needed to project into the same viewport box.\n         */\n        var layoutState = createLayoutState();\n        /**\n         *\n         */\n        var crossfader;\n        /**\n         * Keep track of whether the viewport box has been updated since the\n         * last time the layout projection was re-calculated.\n         */\n        var hasViewportBoxUpdated = false;\n        /**\n         * A map of all motion values attached to this visual element. Motion\n         * values are source of truth for any given animated value. A motion\n         * value might be provided externally by the component via props.\n         */\n        var values = new Map();\n        /**\n         * A map of every subscription that binds the provided or generated\n         * motion values onChange listeners to this visual element.\n         */\n        var valueSubscriptions = new Map();\n        /**\n         * A reference to the previously-provided motion values as returned\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\n         * if any motion values need to be removed after props are updated.\n         */\n        var prevMotionValues = {};\n        /**\n         * x/y motion values that track the progress of initiated layout\n         * animations.\n         *\n         * TODO: Target for removal\n         */\n        var projectionTargetProgress;\n        /**\n         * When values are removed from all animation props we need to search\n         * for a fallback value to animate to. These values are tracked in baseTarget.\n         */\n        var baseTarget = tslib.__assign({}, latestValues);\n        // Internal methods ========================\n        /**\n         * On mount, this will be hydrated with a callback to disconnect\n         * this visual element from its parent on unmount.\n         */\n        var removeFromVariantTree;\n        /**\n         *\n         */\n        function render() {\n            if (!instance)\n                return;\n            if (element.isProjectionReady()) {\n                /**\n                 * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\n                 * This is the final box that we will then project into by calculating a transform delta and\n                 * applying it to the corrected box.\n                 */\n                applyBoxTransforms(leadProjection.targetFinal, leadProjection.target, leadLatestValues);\n                /**\n                 * Update the delta between the corrected box and the final target box, after\n                 * user-set transforms are applied to it. This will be used by the renderer to\n                 * create a transform style that will reproject the element from its actual layout\n                 * into the desired bounding box.\n                 */\n                updateBoxDelta(layoutState.deltaFinal, layoutState.layoutCorrected, leadProjection.targetFinal, latestValues);\n            }\n            triggerBuild();\n            renderInstance(instance, renderState);\n        }\n        function triggerBuild() {\n            var valuesToRender = latestValues;\n            if (crossfader && crossfader.isActive()) {\n                var crossfadedValues = crossfader.getCrossfadeState(element);\n                if (crossfadedValues)\n                    valuesToRender = crossfadedValues;\n            }\n            build(element, renderState, valuesToRender, leadProjection, layoutState, options, props);\n        }\n        function update() {\n            lifecycles.notifyUpdate(latestValues);\n        }\n        function updateLayoutProjection() {\n            if (!element.isProjectionReady())\n                return;\n            var delta = layoutState.delta, treeScale = layoutState.treeScale;\n            var prevTreeScaleX = treeScale.x;\n            var prevTreeScaleY = treeScale.y;\n            var prevDeltaTransform = layoutState.deltaTransform;\n            updateLayoutDeltas(layoutState, leadProjection, element.path, latestValues);\n            hasViewportBoxUpdated &&\n                element.notifyViewportBoxUpdate(leadProjection.target, delta);\n            hasViewportBoxUpdated = false;\n            var deltaTransform = buildLayoutProjectionTransform(delta, treeScale);\n            if (deltaTransform !== prevDeltaTransform ||\n                // Also compare calculated treeScale, for values that rely on this only for scale correction\n                prevTreeScaleX !== treeScale.x ||\n                prevTreeScaleY !== treeScale.y) {\n                element.scheduleRender();\n            }\n            layoutState.deltaTransform = deltaTransform;\n        }\n        function updateTreeLayoutProjection() {\n            element.layoutTree.forEach(fireUpdateLayoutProjection);\n        }\n        /**\n         *\n         */\n        function bindToMotionValue(key, value) {\n            var removeOnChange = value.onChange(function (latestValue) {\n                latestValues[key] = latestValue;\n                props.onUpdate && sync__default['default'].update(update, false, true);\n            });\n            var removeOnRenderRequest = value.onRenderRequest(element.scheduleRender);\n            valueSubscriptions.set(key, function () {\n                removeOnChange();\n                removeOnRenderRequest();\n            });\n        }\n        /**\n         * Any motion values that are provided to the element when created\n         * aren't yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn't neccessarily a breaking change,\n         * more a reflection of the test.\n         */\n        var initialMotionValues = scrapeMotionValuesFromProps(props);\n        for (var key in initialMotionValues) {\n            var value = initialMotionValues[key];\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key], false);\n            }\n        }\n        /**\n         * Determine what role this visual element should take in the variant tree.\n         */\n        var isControllingVariants = checkIfControllingVariants(props);\n        var isVariantNode = checkIfVariantNode(props);\n        var element = tslib.__assign(tslib.__assign({ treeType: treeType, \n            /**\n             * This is a mirror of the internal instance prop, which keeps\n             * VisualElement type-compatible with React's RefObject.\n             */\n            current: null, \n            /**\n             * The depth of this visual element within the visual element tree.\n             */\n            depth: parent ? parent.depth + 1 : 0, parent: parent, children: new Set(), \n            /**\n             * An ancestor path back to the root visual element. This is used\n             * by layout projection to quickly recurse back up the tree.\n             */\n            path: parent ? tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(parent.path)), [parent]) : [], layoutTree: parent ? parent.layoutTree : new FlatTree(), \n            /**\n             *\n             */\n            presenceId: presenceId,\n            projection: projection, \n            /**\n             * If this component is part of the variant tree, it should track\n             * any children that are also part of the tree. This is essentially\n             * a shadow tree to simplify logic around how to stagger over children.\n             */\n            variantChildren: isVariantNode ? new Set() : undefined, \n            /**\n             * Whether this instance is visible. This can be changed imperatively\n             * by AnimateSharedLayout, is analogous to CSS's visibility in that\n             * hidden elements should take up layout, and needs enacting by the configured\n             * render function.\n             */\n            isVisible: undefined, \n            /**\n             * Normally, if a component is controlled by a parent's variants, it can\n             * rely on that ancestor to trigger animations further down the tree.\n             * However, if a component is created after its parent is mounted, the parent\n             * won't trigger that mount animation so the child needs to.\n             *\n             * TODO: This might be better replaced with a method isParentMounted\n             */\n            manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()), \n            /**\n             * This can be set by AnimatePresence to force components that mount\n             * at the same time as it to mount as if they have initial={false} set.\n             */\n            blockInitialAnimation: blockInitialAnimation, \n            /**\n             * Determine whether this component has mounted yet. This is mostly used\n             * by variant children to determine whether they need to trigger their\n             * own animations on mount.\n             */\n            isMounted: function () { return Boolean(instance); }, mount: function (newInstance) {\n                instance = element.current = newInstance;\n                element.pointTo(element);\n                if (isVariantNode && parent && !isControllingVariants) {\n                    removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);\n                }\n                parent === null || parent === void 0 ? void 0 : parent.children.add(element);\n            },\n            /**\n             *\n             */\n            unmount: function () {\n                sync.cancelSync.update(update);\n                sync.cancelSync.render(render);\n                sync.cancelSync.preRender(element.updateLayoutProjection);\n                valueSubscriptions.forEach(function (remove) { return remove(); });\n                element.stopLayoutAnimation();\n                element.layoutTree.remove(element);\n                removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();\n                parent === null || parent === void 0 ? void 0 : parent.children.delete(element);\n                unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\n                lifecycles.clearAllListeners();\n            },\n            /**\n             * Add a child visual element to our set of children.\n             */\n            addVariantChild: function (child) {\n                var _a;\n                var closestVariantNode = element.getClosestVariantNode();\n                if (closestVariantNode) {\n                    (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);\n                    return function () { return closestVariantNode.variantChildren.delete(child); };\n                }\n            },\n            sortNodePosition: function (other) {\n                /**\n                 * If these nodes aren't even of the same type we can't compare their depth.\n                 */\n                if (!sortNodePosition || treeType !== other.treeType)\n                    return 0;\n                return sortNodePosition(element.getInstance(), other.getInstance());\n            }, \n            /**\n             * Returns the closest variant node in the tree starting from\n             * this visual element.\n             */\n            getClosestVariantNode: function () {\n                return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();\n            }, \n            /**\n             * A method that schedules an update to layout projections throughout\n             * the tree. We inherit from the parent so there's only ever one\n             * job scheduled on the next frame - that of the root visual element.\n             */\n            scheduleUpdateLayoutProjection: parent\n                ? parent.scheduleUpdateLayoutProjection\n                : function () {\n                    return sync__default['default'].preRender(element.updateTreeLayoutProjection, false, true);\n                }, \n            /**\n             * Expose the latest layoutId prop.\n             */\n            getLayoutId: function () { return props.layoutId; }, \n            /**\n             * Returns the current instance.\n             */\n            getInstance: function () { return instance; }, \n            /**\n             * Get/set the latest static values.\n             */\n            getStaticValue: function (key) { return latestValues[key]; }, setStaticValue: function (key, value) { return (latestValues[key] = value); }, \n            /**\n             * Returns the latest motion value state. Currently only used to take\n             * a snapshot of the visual element - perhaps this can return the whole\n             * visual state\n             */\n            getLatestValues: function () { return latestValues; }, \n            /**\n             * Set the visiblity of the visual element. If it's changed, schedule\n             * a render to reflect these changes.\n             */\n            setVisibility: function (visibility) {\n                if (element.isVisible === visibility)\n                    return;\n                element.isVisible = visibility;\n                element.scheduleRender();\n            },\n            /**\n             * Make a target animatable by Popmotion. For instance, if we're\n             * trying to animate width from 100px to 100vw we need to measure 100vw\n             * in pixels to determine what we really need to animate to. This is also\n             * pluggable to support Framer's custom value types like Color,\n             * and CSS variables.\n             */\n            makeTargetAnimatable: function (target, canMutate) {\n                if (canMutate === void 0) { canMutate = true; }\n                return makeTargetAnimatable(element, target, props, canMutate);\n            },\n            // Motion values ========================\n            /**\n             * Add a motion value and bind it to this visual element.\n             */\n            addValue: function (key, value) {\n                // Remove existing value if it exists\n                if (element.hasValue(key))\n                    element.removeValue(key);\n                values.set(key, value);\n                latestValues[key] = value.get();\n                bindToMotionValue(key, value);\n            },\n            /**\n             * Remove a motion value and unbind any active subscriptions.\n             */\n            removeValue: function (key) {\n                var _a;\n                values.delete(key);\n                (_a = valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();\n                valueSubscriptions.delete(key);\n                delete latestValues[key];\n                removeValueFromRenderState(key, renderState);\n            }, \n            /**\n             * Check whether we have a motion value for this key\n             */\n            hasValue: function (key) { return values.has(key); }, \n            /**\n             * Get a motion value for this key. If called with a default\n             * value, we'll create one if none exists.\n             */\n            getValue: function (key, defaultValue) {\n                var value = values.get(key);\n                if (value === undefined && defaultValue !== undefined) {\n                    value = motionValue(defaultValue);\n                    element.addValue(key, value);\n                }\n                return value;\n            }, \n            /**\n             * Iterate over our motion values.\n             */\n            forEachValue: function (callback) { return values.forEach(callback); }, \n            /**\n             * If we're trying to animate to a previously unencountered value,\n             * we need to check for it in our state and as a last resort read it\n             * directly from the instance (which might have performance implications).\n             */\n            readValue: function (key) { var _a; return (_a = latestValues[key]) !== null && _a !== void 0 ? _a : readValueFromInstance(instance, key, options); }, \n            /**\n             * Set the base target to later animate back to. This is currently\n             * only hydrated on creation and when we first read a value.\n             */\n            setBaseTarget: function (key, value) {\n                baseTarget[key] = value;\n            },\n            /**\n             * Find the base target for a value thats been removed from all animation\n             * props.\n             */\n            getBaseTarget: function (key) {\n                if (getBaseTarget) {\n                    var target = getBaseTarget(props, key);\n                    if (target !== undefined && !isMotionValue(target))\n                        return target;\n                }\n                return baseTarget[key];\n            } }, lifecycles), { \n            /**\n             * Build the renderer state based on the latest visual state.\n             */\n            build: function () {\n                triggerBuild();\n                return renderState;\n            },\n            /**\n             * Schedule a render on the next animation frame.\n             */\n            scheduleRender: function () {\n                sync__default['default'].render(render, false, true);\n            }, \n            /**\n             * Synchronously fire render. It's prefered that we batch renders but\n             * in many circumstances, like layout measurement, we need to run this\n             * synchronously. However in those instances other measures should be taken\n             * to batch reads/writes.\n             */\n            syncRender: render, \n            /**\n             * Update the provided props. Ensure any newly-added motion values are\n             * added to our map, old ones removed, and listeners updated.\n             */\n            setProps: function (newProps) {\n                props = newProps;\n                lifecycles.updatePropListeners(newProps);\n                prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps(props), prevMotionValues);\n            }, getProps: function () { return props; }, \n            // Variants ==============================\n            /**\n             * Returns the variant definition with a given name.\n             */\n            getVariant: function (name) { var _a; return (_a = props.variants) === null || _a === void 0 ? void 0 : _a[name]; }, \n            /**\n             * Returns the defined default transition on this component.\n             */\n            getDefaultTransition: function () { return props.transition; }, \n            /**\n             * Used by child variant nodes to get the closest ancestor variant props.\n             */\n            getVariantContext: function (startAtParent) {\n                if (startAtParent === void 0) { startAtParent = false; }\n                if (startAtParent)\n                    return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();\n                if (!isControllingVariants) {\n                    var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};\n                    if (props.initial !== undefined) {\n                        context_1.initial = props.initial;\n                    }\n                    return context_1;\n                }\n                var context = {};\n                for (var i = 0; i < numVariantProps; i++) {\n                    var name_1 = variantProps[i];\n                    var prop = props[name_1];\n                    if (isVariantLabel(prop) || prop === false) {\n                        context[name_1] = prop;\n                    }\n                }\n                return context;\n            },\n            // Layout projection ==============================\n            /**\n             * Enable layout projection for this visual element. Won't actually\n             * occur until we also have hydrated layout measurements.\n             */\n            enableLayoutProjection: function () {\n                projection.isEnabled = true;\n                element.layoutTree.add(element);\n            },\n            /**\n             * Lock the projection target, for instance when dragging, so\n             * nothing else can try and animate it.\n             */\n            lockProjectionTarget: function () {\n                projection.isTargetLocked = true;\n            },\n            unlockProjectionTarget: function () {\n                element.stopLayoutAnimation();\n                projection.isTargetLocked = false;\n            }, getLayoutState: function () { return layoutState; }, setCrossfader: function (newCrossfader) {\n                crossfader = newCrossfader;\n            }, isProjectionReady: function () {\n                return projection.isEnabled &&\n                    projection.isHydrated &&\n                    layoutState.isHydrated;\n            }, \n            /**\n             * Start a layout animation on a given axis.\n             */\n            startLayoutAnimation: function (axis, transition, isRelative) {\n                if (isRelative === void 0) { isRelative = false; }\n                var progress = element.getProjectionAnimationProgress()[axis];\n                var _a = isRelative\n                    ? projection.relativeTarget[axis]\n                    : projection.target[axis], min = _a.min, max = _a.max;\n                var length = max - min;\n                progress.clearListeners();\n                progress.set(min);\n                progress.set(min); // Set twice to hard-reset velocity\n                progress.onChange(function (v) {\n                    element.setProjectionTargetAxis(axis, v, v + length, isRelative);\n                });\n                return element.animateMotionValue(axis, progress, 0, transition);\n            },\n            /**\n             * Stop layout animations.\n             */\n            stopLayoutAnimation: function () {\n                eachAxis(function (axis) {\n                    return element.getProjectionAnimationProgress()[axis].stop();\n                });\n            },\n            /**\n             * Measure the current viewport box with or without transforms.\n             * Only measures axis-aligned boxes, rotate and skew must be manually\n             * removed with a re-render to work.\n             */\n            measureViewportBox: function (withTransform) {\n                if (withTransform === void 0) { withTransform = true; }\n                var viewportBox = measureViewportBox(instance, options);\n                if (!withTransform)\n                    removeBoxTransforms(viewportBox, latestValues);\n                return viewportBox;\n            },\n            /**\n             * Get the motion values tracking the layout animations on each\n             * axis. Lazy init if not already created.\n             */\n            getProjectionAnimationProgress: function () {\n                projectionTargetProgress || (projectionTargetProgress = {\n                    x: motionValue(0),\n                    y: motionValue(0),\n                });\n                return projectionTargetProgress;\n            },\n            /**\n             * Update the projection of a single axis. Schedule an update to\n             * the tree layout projection.\n             */\n            setProjectionTargetAxis: function (axis, min, max, isRelative) {\n                if (isRelative === void 0) { isRelative = false; }\n                var target;\n                if (isRelative) {\n                    if (!projection.relativeTarget) {\n                        projection.relativeTarget = axisBox();\n                    }\n                    target = projection.relativeTarget[axis];\n                }\n                else {\n                    projection.relativeTarget = undefined;\n                    target = projection.target[axis];\n                }\n                projection.isHydrated = true;\n                target.min = min;\n                target.max = max;\n                // Flag that we want to fire the onViewportBoxUpdate event handler\n                hasViewportBoxUpdated = true;\n                lifecycles.notifySetAxisTarget();\n            },\n            /**\n             * Rebase the projection target on top of the provided viewport box\n             * or the measured layout. This ensures that non-animating elements\n             * don't fall out of sync differences in measurements vs projections\n             * after a page scroll or other relayout.\n             */\n            rebaseProjectionTarget: function (force, box) {\n                if (box === void 0) { box = layoutState.layout; }\n                var _a = element.getProjectionAnimationProgress(), x = _a.x, y = _a.y;\n                var shouldRebase = !projection.relativeTarget &&\n                    !projection.isTargetLocked &&\n                    !x.isAnimating() &&\n                    !y.isAnimating();\n                if (force || shouldRebase) {\n                    eachAxis(function (axis) {\n                        var _a = box[axis], min = _a.min, max = _a.max;\n                        element.setProjectionTargetAxis(axis, min, max);\n                    });\n                }\n            },\n            /**\n             * Notify the visual element that its layout is up-to-date.\n             * Currently Animate.tsx uses this to check whether a layout animation\n             * needs to be performed.\n             */\n            notifyLayoutReady: function (config) {\n                setCurrentViewportBox(element);\n                element.notifyLayoutUpdate(layoutState.layout, element.prevViewportBox || layoutState.layout, config);\n            }, \n            /**\n             * Temporarily reset the transform of the instance.\n             */\n            resetTransform: function () { return resetTransform(element, instance, props); }, restoreTransform: function () { return restoreTransform(instance, renderState); }, updateLayoutProjection: updateLayoutProjection,\n            updateTreeLayoutProjection: function () {\n                element.layoutTree.forEach(fireResolveRelativeTargetBox);\n                /**\n                 * Schedule the projection updates at the end of the current preRender\n                 * step. This will ensure that all layout trees will first resolve\n                 * relative projection boxes into viewport boxes, and *then*\n                 * update projections.\n                 */\n                sync__default['default'].preRender(updateTreeLayoutProjection, false, true);\n                // sync.postRender(() => element.scheduleUpdateLayoutProjection())\n            },\n            getProjectionParent: function () {\n                if (projectionParent === undefined) {\n                    var foundParent = false;\n                    // Search backwards through the tree path\n                    for (var i = element.path.length - 1; i >= 0; i--) {\n                        var ancestor = element.path[i];\n                        if (ancestor.projection.isEnabled) {\n                            foundParent = ancestor;\n                            break;\n                        }\n                    }\n                    projectionParent = foundParent;\n                }\n                return projectionParent;\n            },\n            resolveRelativeTargetBox: function () {\n                var relativeParent = element.getProjectionParent();\n                if (!projection.relativeTarget || !relativeParent)\n                    return;\n                calcRelativeBox(projection, relativeParent.projection);\n                if (isDraggable(relativeParent)) {\n                    var target = projection.target;\n                    applyBoxTransforms(target, target, relativeParent.getLatestValues());\n                }\n            },\n            shouldResetTransform: function () {\n                return Boolean(props._layoutResetTransform);\n            },\n            /**\n             *\n             */\n            pointTo: function (newLead) {\n                leadProjection = newLead.projection;\n                leadLatestValues = newLead.getLatestValues();\n                /**\n                 * Subscribe to lead component's layout animations\n                 */\n                unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\n                unsubscribeFromLeadVisualElement = popmotion.pipe(newLead.onSetAxisTarget(element.scheduleUpdateLayoutProjection), newLead.onLayoutAnimationComplete(function () {\n                    var _a;\n                    if (element.isPresent) {\n                        element.presence = Presence.Present;\n                    }\n                    else {\n                        (_a = element.layoutSafeToRemove) === null || _a === void 0 ? void 0 : _a.call(element);\n                    }\n                }));\n            }, \n            // TODO: Clean this up\n            isPresent: true, presence: Presence.Entering });\n        return element;\n    };\n};\nfunction fireResolveRelativeTargetBox(child) {\n    child.resolveRelativeTargetBox();\n}\nfunction fireUpdateLayoutProjection(child) {\n    child.updateLayoutProjection();\n}\nvar variantProps = tslib.__spreadArray([\"initial\"], tslib.__read(variantPriorityOrder));\nvar numVariantProps = variantProps.length;\n\nvar positionalKeys = new Set([\n    \"width\",\n    \"height\",\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\",\n    \"x\",\n    \"y\",\n]);\nvar isPositionalKey = function (key) { return positionalKeys.has(key); };\nvar hasPositionalKey = function (target) {\n    return Object.keys(target).some(isPositionalKey);\n};\nvar setAndResetVelocity = function (value, to) {\n    // Looks odd but setting it twice doesn't render, it'll just\n    // set both prev and current to the latest value\n    value.set(to, false);\n    value.set(to);\n};\nvar isNumOrPxType = function (v) {\n    return v === styleValueTypes.number || v === styleValueTypes.px;\n};\nvar BoundingBoxDimension;\n(function (BoundingBoxDimension) {\n    BoundingBoxDimension[\"width\"] = \"width\";\n    BoundingBoxDimension[\"height\"] = \"height\";\n    BoundingBoxDimension[\"left\"] = \"left\";\n    BoundingBoxDimension[\"right\"] = \"right\";\n    BoundingBoxDimension[\"top\"] = \"top\";\n    BoundingBoxDimension[\"bottom\"] = \"bottom\";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\nvar getPosFromMatrix = function (matrix, pos) {\n    return parseFloat(matrix.split(\", \")[pos]);\n};\nvar getTranslateFromMatrix = function (pos2, pos3) { return function (_bbox, _a) {\n    var transform = _a.transform;\n    if (transform === \"none\" || !transform)\n        return 0;\n    var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n    if (matrix3d) {\n        return getPosFromMatrix(matrix3d[1], pos3);\n    }\n    else {\n        var matrix = transform.match(/^matrix\\((.+)\\)$/);\n        if (matrix) {\n            return getPosFromMatrix(matrix[1], pos2);\n        }\n        else {\n            return 0;\n        }\n    }\n}; };\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\nvar nonTranslationalTransformKeys = transformProps.filter(function (key) { return !transformKeys.has(key); });\nfunction removeNonTranslationalTransform(visualElement) {\n    var removedTransforms = [];\n    nonTranslationalTransformKeys.forEach(function (key) {\n        var value = visualElement.getValue(key);\n        if (value !== undefined) {\n            removedTransforms.push([key, value.get()]);\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\n        }\n    });\n    // Apply changes to element before measurement\n    if (removedTransforms.length)\n        visualElement.syncRender();\n    return removedTransforms;\n}\nvar positionalValues = {\n    // Dimensions\n    width: function (_a) {\n        var x = _a.x;\n        return x.max - x.min;\n    },\n    height: function (_a) {\n        var y = _a.y;\n        return y.max - y.min;\n    },\n    top: function (_bbox, _a) {\n        var top = _a.top;\n        return parseFloat(top);\n    },\n    left: function (_bbox, _a) {\n        var left = _a.left;\n        return parseFloat(left);\n    },\n    bottom: function (_a, _b) {\n        var y = _a.y;\n        var top = _b.top;\n        return parseFloat(top) + (y.max - y.min);\n    },\n    right: function (_a, _b) {\n        var x = _a.x;\n        var left = _b.left;\n        return parseFloat(left) + (x.max - x.min);\n    },\n    // Transform\n    x: getTranslateFromMatrix(4, 13),\n    y: getTranslateFromMatrix(5, 14),\n};\nvar convertChangedValueTypes = function (target, visualElement, changedKeys) {\n    var originBbox = visualElement.measureViewportBox();\n    var element = visualElement.getInstance();\n    var elementComputedStyle = getComputedStyle(element);\n    var display = elementComputedStyle.display, top = elementComputedStyle.top, left = elementComputedStyle.left, bottom = elementComputedStyle.bottom, right = elementComputedStyle.right, transform = elementComputedStyle.transform;\n    var originComputedStyle = { top: top, left: left, bottom: bottom, right: right, transform: transform };\n    // If the element is currently set to display: \"none\", make it visible before\n    // measuring the target bounding box\n    if (display === \"none\") {\n        visualElement.setStaticValue(\"display\", target.display || \"block\");\n    }\n    // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n    visualElement.syncRender();\n    var targetBbox = visualElement.measureViewportBox();\n    changedKeys.forEach(function (key) {\n        // Restore styles to their **calculated computed style**, not their actual\n        // originally set style. This allows us to animate between equivalent pixel units.\n        var value = visualElement.getValue(key);\n        setAndResetVelocity(value, positionalValues[key](originBbox, originComputedStyle));\n        target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n    });\n    return target;\n};\nvar checkAndConvertChangedValueTypes = function (visualElement, target, origin, transitionEnd) {\n    if (origin === void 0) { origin = {}; }\n    if (transitionEnd === void 0) { transitionEnd = {}; }\n    target = tslib.__assign({}, target);\n    transitionEnd = tslib.__assign({}, transitionEnd);\n    var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\n    // We want to remove any transform values that could affect the element's bounding box before\n    // it's measured. We'll reapply these later.\n    var removedTransformValues = [];\n    var hasAttemptedToRemoveTransformValues = false;\n    var changedValueTypeKeys = [];\n    targetPositionalKeys.forEach(function (key) {\n        var value = visualElement.getValue(key);\n        if (!visualElement.hasValue(key))\n            return;\n        var from = origin[key];\n        var to = target[key];\n        var fromType = findDimensionValueType(from);\n        var toType;\n        // TODO: The current implementation of this basically throws an error\n        // if you try and do value conversion via keyframes. There's probably\n        // a way of doing this but the performance implications would need greater scrutiny,\n        // as it'd be doing multiple resize-remeasure operations.\n        if (isKeyframesTarget(to)) {\n            var numKeyframes = to.length;\n            for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {\n                if (!toType) {\n                    toType = findDimensionValueType(to[i]);\n                    heyListen.invariant(toType === fromType ||\n                        (isNumOrPxType(fromType) && isNumOrPxType(toType)), \"Keyframes must be of the same dimension as the current value\");\n                }\n                else {\n                    heyListen.invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n                }\n            }\n        }\n        else {\n            toType = findDimensionValueType(to);\n        }\n        if (fromType !== toType) {\n            // If they're both just number or px, convert them both to numbers rather than\n            // relying on resize/remeasure to convert (which is wasteful in this situation)\n            if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n                var current = value.get();\n                if (typeof current === \"string\") {\n                    value.set(parseFloat(current));\n                }\n                if (typeof to === \"string\") {\n                    target[key] = parseFloat(to);\n                }\n                else if (Array.isArray(to) && toType === styleValueTypes.px) {\n                    target[key] = to.map(parseFloat);\n                }\n            }\n            else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) &&\n                (toType === null || toType === void 0 ? void 0 : toType.transform) &&\n                (from === 0 || to === 0)) {\n                // If one or the other value is 0, it's safe to coerce it to the\n                // type of the other without measurement\n                if (from === 0) {\n                    value.set(toType.transform(from));\n                }\n                else {\n                    target[key] = fromType.transform(to);\n                }\n            }\n            else {\n                // If we're going to do value conversion via DOM measurements, we first\n                // need to remove non-positional transform values that could affect the bbox measurements.\n                if (!hasAttemptedToRemoveTransformValues) {\n                    removedTransformValues = removeNonTranslationalTransform(visualElement);\n                    hasAttemptedToRemoveTransformValues = true;\n                }\n                changedValueTypeKeys.push(key);\n                transitionEnd[key] =\n                    transitionEnd[key] !== undefined\n                        ? transitionEnd[key]\n                        : target[key];\n                setAndResetVelocity(value, to);\n            }\n        }\n    });\n    if (changedValueTypeKeys.length) {\n        var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\n        // If we removed transform values, reapply them before the next render\n        if (removedTransformValues.length) {\n            removedTransformValues.forEach(function (_a) {\n                var _b = tslib.__read(_a, 2), key = _b[0], value = _b[1];\n                visualElement.getValue(key).set(value);\n            });\n        }\n        // Reapply original values\n        visualElement.syncRender();\n        return { target: convertedTarget, transitionEnd: transitionEnd };\n    }\n    else {\n        return { target: target, transitionEnd: transitionEnd };\n    }\n};\n/**\n * Convert value types for x/y/width/height/top/left/bottom/right\n *\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\n *\n * @internal\n */\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n    return hasPositionalKey(target)\n        ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd)\n        : { target: target, transitionEnd: transitionEnd };\n}\n\n/**\n * Parse a DOM variant to make it animatable. This involves resolving CSS variables\n * and ensuring animations like \"20%\" => \"calc(50vw)\" are performed in pixels.\n */\nvar parseDomVariant = function (visualElement, target, origin, transitionEnd) {\n    var resolved = resolveCSSVariables(visualElement, target, transitionEnd);\n    target = resolved.target;\n    transitionEnd = resolved.transitionEnd;\n    return unitConversion(visualElement, target, origin, transitionEnd);\n};\n\nfunction getComputedStyle$1(element) {\n    return window.getComputedStyle(element);\n}\nvar htmlConfig = {\n    treeType: \"dom\",\n    readValueFromInstance: function (domElement, key) {\n        if (isTransformProp(key)) {\n            var defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        }\n        else {\n            var computedStyle = getComputedStyle$1(domElement);\n            return ((isCSSVariable$1(key)\n                ? computedStyle.getPropertyValue(key)\n                : computedStyle[key]) || 0);\n        }\n    },\n    sortNodePosition: function (a, b) {\n        /**\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\n         * we're returning true if 2 in that bitmask is set to true. 2 is set\n         * to true if b preceeds a.\n         */\n        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n    },\n    getBaseTarget: function (props, key) {\n        var _a;\n        return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\n    },\n    measureViewportBox: function (element, _a) {\n        var transformPagePoint = _a.transformPagePoint;\n        return getBoundingBox(element, transformPagePoint);\n    },\n    /**\n     * Reset the transform on the current Element. This is called as part\n     * of a batched process across the entire layout tree. To remove this write\n     * cycle it'd be interesting to see if it's possible to \"undo\" all the current\n     * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\n     * works\n     */\n    resetTransform: function (element, domElement, props) {\n        var transformTemplate = props.transformTemplate;\n        domElement.style.transform = transformTemplate\n            ? transformTemplate({}, \"\")\n            : \"none\";\n        // Ensure that whatever happens next, we restore our transform on the next frame\n        element.scheduleRender();\n    },\n    restoreTransform: function (instance, mutableState) {\n        instance.style.transform = mutableState.style.transform;\n    },\n    removeValueFromRenderState: function (key, _a) {\n        var vars = _a.vars, style = _a.style;\n        delete vars[key];\n        delete style[key];\n    },\n    /**\n     * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`\n     * can be animated by Motion.\n     */\n    makeTargetAnimatable: function (element, _a, _b, isMounted) {\n        var transformValues = _b.transformValues;\n        if (isMounted === void 0) { isMounted = true; }\n        var transition = _a.transition, transitionEnd = _a.transitionEnd, target = tslib.__rest(_a, [\"transition\", \"transitionEnd\"]);\n        var origin = getOrigin(target, transition || {}, element);\n        /**\n         * If Framer has provided a function to convert `Color` etc value types, convert them\n         */\n        if (transformValues) {\n            if (transitionEnd)\n                transitionEnd = transformValues(transitionEnd);\n            if (target)\n                target = transformValues(target);\n            if (origin)\n                origin = transformValues(origin);\n        }\n        if (isMounted) {\n            checkTargetForNewValues(element, target, origin);\n            var parsed = parseDomVariant(element, target, origin, transitionEnd);\n            transitionEnd = parsed.transitionEnd;\n            target = parsed.target;\n        }\n        return tslib.__assign({ transition: transition,\n            transitionEnd: transitionEnd }, target);\n    },\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,\n    build: function (element, renderState, latestValues, projection, layoutState, options, props) {\n        if (element.isVisible !== undefined) {\n            renderState.style.visibility = element.isVisible\n                ? \"visible\"\n                : \"hidden\";\n        }\n        var isProjectionTranform = projection.isEnabled && layoutState.isHydrated;\n        buildHTMLStyles(renderState, latestValues, projection, layoutState, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : undefined, isProjectionTranform\n            ? buildLayoutProjectionTransformOrigin\n            : undefined);\n    },\n    render: renderHTML,\n};\nvar htmlVisualElement = visualElement(htmlConfig);\n\nvar svgVisualElement = visualElement(tslib.__assign(tslib.__assign({}, htmlConfig), { getBaseTarget: function (props, key) {\n        return props[key];\n    },\n    readValueFromInstance: function (domElement, key) {\n        var _a;\n        if (isTransformProp(key)) {\n            return ((_a = getDefaultValueType(key)) === null || _a === void 0 ? void 0 : _a.default) || 0;\n        }\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n        return domElement.getAttribute(key);\n    },\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n    build: function (_element, renderState, latestValues, projection, layoutState, options, props) {\n        var isProjectionTranform = projection.isEnabled && layoutState.isHydrated;\n        buildSVGAttrs(renderState, latestValues, projection, layoutState, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : undefined, isProjectionTranform\n            ? buildLayoutProjectionTransformOrigin\n            : undefined);\n    }, render: renderSVG }));\n\nvar createDomVisualElement = function (Component, options) {\n    return isSVGComponent(Component)\n        ? svgVisualElement(options, { enableHardwareAcceleration: false })\n        : htmlVisualElement(options, { enableHardwareAcceleration: true });\n};\n\nvar featureBundle = tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({}, animations), gestureAnimations), drag), layoutAnimations);\n/**\n * HTML & SVG components, optimised for use with gestures and animation. These can be used as\n * drop-in replacements for any HTML & SVG component, all CSS & SVG properties are supported.\n *\n * @public\n */\nvar motion = /*@__PURE__*/ createMotionProxy(function (Component, config) {\n    return createDomMotionConfig(Component, config, featureBundle, createDomVisualElement);\n});\n/**\n * Create a DOM `motion` component with the provided string. This is primarily intended\n * as a full alternative to `motion` for consumers who have to support environments that don't\n * support `Proxy`.\n *\n * ```javascript\n * import { createDomMotionComponent } from \"framer-motion\"\n *\n * const motion = {\n *   div: createDomMotionComponent('div')\n * }\n * ```\n *\n * @public\n */\nfunction createDomMotionComponent(key) {\n    return createMotionComponent(createDomMotionConfig(key, { forwardMotionProps: false }, featureBundle, createDomVisualElement));\n}\n\n/**\n * @public\n */\nvar m = createMotionProxy(createDomMotionConfig);\n\nfunction useForceUpdate() {\n    var unloadingRef = React.useRef(false);\n    var _a = tslib.__read(React.useState(0), 2), forcedRenderCount = _a[0], setForcedRenderCount = _a[1];\n    useUnmountEffect(function () { return (unloadingRef.current = true); });\n    return React.useCallback(function () {\n        !unloadingRef.current && setForcedRenderCount(forcedRenderCount + 1);\n    }, [forcedRenderCount]);\n}\n\nvar presenceId = 0;\nfunction getPresenceId() {\n    var id = presenceId;\n    presenceId++;\n    return id;\n}\nvar PresenceChild = function (_a) {\n    var children = _a.children, initial = _a.initial, isPresent = _a.isPresent, onExitComplete = _a.onExitComplete, custom = _a.custom, presenceAffectsLayout = _a.presenceAffectsLayout;\n    var presenceChildren = useConstant(newChildrenMap);\n    var id = useConstant(getPresenceId);\n    var context = React.useMemo(function () { return ({\n        id: id,\n        initial: initial,\n        isPresent: isPresent,\n        custom: custom,\n        onExitComplete: function (childId) {\n            presenceChildren.set(childId, true);\n            var allComplete = true;\n            presenceChildren.forEach(function (isComplete) {\n                if (!isComplete)\n                    allComplete = false;\n            });\n            allComplete && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n        },\n        register: function (childId) {\n            presenceChildren.set(childId, false);\n            return function () { return presenceChildren.delete(childId); };\n        },\n    }); }, \n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    presenceAffectsLayout ? undefined : [isPresent]);\n    React.useMemo(function () {\n        presenceChildren.forEach(function (_, key) { return presenceChildren.set(key, false); });\n    }, [isPresent]);\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    React__namespace.useEffect(function () {\n        !isPresent && !presenceChildren.size && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n    }, [isPresent]);\n    return (React__namespace.createElement(PresenceContext.Provider, { value: context }, children));\n};\nfunction newChildrenMap() {\n    return new Map();\n}\n\nfunction getChildKey(child) {\n    return child.key || \"\";\n}\nfunction updateChildLookup(children, allChildren) {\n    var seenChildren = process.env.NODE_ENV !== \"production\" ? new Set() : null;\n    children.forEach(function (child) {\n        var key = getChildKey(child);\n        if (process.env.NODE_ENV !== \"production\" && seenChildren) {\n            if (seenChildren.has(key)) {\n                console.warn(\"Children of AnimatePresence require unique keys. \\\"\" + key + \"\\\" is a duplicate.\");\n            }\n            seenChildren.add(key);\n        }\n        allChildren.set(key, child);\n    });\n}\nfunction onlyElements(children) {\n    var filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    React.Children.forEach(children, function (child) {\n        if (React.isValidElement(child))\n            filtered.push(child);\n    });\n    return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * @library\n *\n * Any `Frame` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { Frame, AnimatePresence } from 'framer'\n *\n * // As items are added and removed from `items`\n * export function Items({ items }) {\n *   return (\n *     <AnimatePresence>\n *       {items.map(item => (\n *         <Frame\n *           key={item.id}\n *           initial={{ opacity: 0 }}\n *           animate={{ opacity: 1 }}\n *           exit={{ opacity: 0 }}\n *         />\n *       ))}\n *     </AnimatePresence>\n *   )\n * }\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * @motion\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nvar AnimatePresence = function (_a) {\n    var children = _a.children, custom = _a.custom, _b = _a.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a.onExitComplete, exitBeforeEnter = _a.exitBeforeEnter, _c = _a.presenceAffectsLayout, presenceAffectsLayout = _c === void 0 ? true : _c;\n    // We want to force a re-render once all exiting animations have finished. We\n    // either use a local forceRender function, or one from a parent context if it exists.\n    var forceRender = useForceUpdate();\n    var layoutContext = React.useContext(SharedLayoutContext);\n    if (isSharedLayout(layoutContext)) {\n        forceRender = layoutContext.forceUpdate;\n    }\n    var isInitialRender = React.useRef(true);\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n    var filteredChildren = onlyElements(children);\n    // Keep a living record of the children we're actually rendering so we\n    // can diff to figure out which are entering and exiting\n    var presentChildren = React.useRef(filteredChildren);\n    // A lookup table to quickly reference components by key\n    var allChildren = React.useRef(new Map())\n        .current;\n    // A living record of all currently exiting components.\n    var exiting = React.useRef(new Set()).current;\n    updateChildLookup(filteredChildren, allChildren);\n    // If this is the initial component render, just deal with logic surrounding whether\n    // we play onMount animations or not.\n    if (isInitialRender.current) {\n        isInitialRender.current = false;\n        return (React__namespace.createElement(React__namespace.Fragment, null, filteredChildren.map(function (child) { return (React__namespace.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? undefined : false, presenceAffectsLayout: presenceAffectsLayout }, child)); })));\n    }\n    // If this is a subsequent render, deal with entering and exiting children\n    var childrenToRender = tslib.__spreadArray([], tslib.__read(filteredChildren));\n    // Diff the keys of the currently-present and target children to update our\n    // exiting list.\n    var presentKeys = presentChildren.current.map(getChildKey);\n    var targetKeys = filteredChildren.map(getChildKey);\n    // Diff the present children with our target children and mark those that are exiting\n    var numPresent = presentKeys.length;\n    for (var i = 0; i < numPresent; i++) {\n        var key = presentKeys[i];\n        if (targetKeys.indexOf(key) === -1) {\n            exiting.add(key);\n        }\n        else {\n            // In case this key has re-entered, remove from the exiting list\n            exiting.delete(key);\n        }\n    }\n    // If we currently have exiting children, and we're deferring rendering incoming children\n    // until after all current children have exiting, empty the childrenToRender array\n    if (exitBeforeEnter && exiting.size) {\n        childrenToRender = [];\n    }\n    // Loop through all currently exiting components and clone them to overwrite `animate`\n    // with any `exit` prop they might have defined.\n    exiting.forEach(function (key) {\n        // If this component is actually entering again, early return\n        if (targetKeys.indexOf(key) !== -1)\n            return;\n        var child = allChildren.get(key);\n        if (!child)\n            return;\n        var insertionIndex = presentKeys.indexOf(key);\n        var onExit = function () {\n            allChildren.delete(key);\n            exiting.delete(key);\n            // Remove this child from the present children\n            var removeIndex = presentChildren.current.findIndex(function (presentChild) { return presentChild.key === key; });\n            presentChildren.current.splice(removeIndex, 1);\n            // Defer re-rendering until all exiting children have indeed left\n            if (!exiting.size) {\n                presentChildren.current = filteredChildren;\n                forceRender();\n                onExitComplete && onExitComplete();\n            }\n        };\n        childrenToRender.splice(insertionIndex, 0, React__namespace.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom, presenceAffectsLayout: presenceAffectsLayout }, child));\n    });\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\n    // the same tree between renders\n    childrenToRender = childrenToRender.map(function (child) {\n        var key = child.key;\n        return exiting.has(key) ? (child) : (React__namespace.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout: presenceAffectsLayout }, child));\n    });\n    presentChildren.current = childrenToRender;\n    if (process.env.NODE_ENV !== \"production\" &&\n        exitBeforeEnter &&\n        childrenToRender.length > 1) {\n        console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n    }\n    return (React__namespace.createElement(React__namespace.Fragment, null, exiting.size\n        ? childrenToRender\n        : childrenToRender.map(function (child) { return React.cloneElement(child); })));\n};\n\n/**\n * Animate a single value or a `MotionValue`.\n *\n * The first argument is either a `MotionValue` to animate, or an initial animation value.\n *\n * The second is either a value to animate to, or an array of keyframes to animate through.\n *\n * The third argument can be either tween or spring options, and optional lifecycle methods: `onUpdate`, `onPlay`, `onComplete`, `onRepeat` and `onStop`.\n *\n * Returns `AnimationPlaybackControls`, currently just a `stop` method.\n *\n * ```javascript\n * const x = useMotionValue(0)\n *\n * useEffect(() => {\n *   const controls = animate(x, 100, {\n *     type: \"spring\",\n *     stiffness: 2000,\n *     onComplete: v => {}\n *   })\n *\n *   return controls.stop\n * })\n * ```\n *\n * @public\n */\nfunction animate(from, to, transition) {\n    if (transition === void 0) { transition = {}; }\n    var value = isMotionValue(from) ? from : motionValue(from);\n    startAnimation(\"\", value, to, transition);\n    return {\n        stop: function () { return value.stop(); },\n    };\n}\n\nfunction createCrossfader() {\n    /**\n     * The current state of the crossfade as a value between 0 and 1\n     */\n    var progress = motionValue(1);\n    var options = {\n        lead: undefined,\n        follow: undefined,\n        crossfadeOpacity: false,\n        preserveFollowOpacity: false,\n    };\n    var prevOptions = tslib.__assign({}, options);\n    var leadState = {};\n    var followState = {};\n    /**\n     *\n     */\n    var isActive = false;\n    /**\n     *\n     */\n    var finalCrossfadeFrame = null;\n    /**\n     * Framestamp of the last frame we updated values at.\n     */\n    var prevUpdate = 0;\n    function startCrossfadeAnimation(target, transition) {\n        var lead = options.lead, follow = options.follow;\n        isActive = true;\n        finalCrossfadeFrame = null;\n        var hasUpdated = false;\n        var onUpdate = function () {\n            hasUpdated = true;\n            lead && lead.scheduleRender();\n            follow && follow.scheduleRender();\n        };\n        var onComplete = function () {\n            isActive = false;\n            /**\n             * If the crossfade animation is no longer active, flag a frame\n             * that we're still allowed to crossfade\n             */\n            finalCrossfadeFrame = sync.getFrameData().timestamp;\n        };\n        transition = transition && getValueTransition(transition, \"crossfade\");\n        return animate(progress, target, tslib.__assign(tslib.__assign({}, transition), { onUpdate: onUpdate, onComplete: function () {\n                if (!hasUpdated) {\n                    progress.set(target);\n                    /**\n                     * If we never ran an update, for instance if this was an instant transition, fire a\n                     * simulated final frame to ensure the crossfade gets applied correctly.\n                     */\n                    sync__default['default'].read(onComplete);\n                }\n                else {\n                    onComplete();\n                }\n                onUpdate();\n            } }));\n    }\n    function updateCrossfade() {\n        var _a, _b;\n        /**\n         * We only want to compute the crossfade once per frame, so we\n         * compare the previous update framestamp with the current frame\n         * and early return if they're the same.\n         */\n        var timestamp = sync.getFrameData().timestamp;\n        var lead = options.lead, follow = options.follow;\n        if (timestamp === prevUpdate || !lead)\n            return;\n        prevUpdate = timestamp;\n        /**\n         * Merge each component's latest values into our crossfaded state\n         * before crossfading.\n         */\n        var latestLeadValues = lead.getLatestValues();\n        Object.assign(leadState, latestLeadValues);\n        var latestFollowValues = follow\n            ? follow.getLatestValues()\n            : options.prevValues;\n        Object.assign(followState, latestFollowValues);\n        var p = progress.get();\n        /**\n         * Crossfade the opacity between the two components. This will result\n         * in a different opacity for each component.\n         */\n        var leadTargetOpacity = (_a = latestLeadValues.opacity) !== null && _a !== void 0 ? _a : 1;\n        var followTargetOpacity = (_b = latestFollowValues === null || latestFollowValues === void 0 ? void 0 : latestFollowValues.opacity) !== null && _b !== void 0 ? _b : 1;\n        if (options.crossfadeOpacity && follow) {\n            leadState.opacity = popmotion.mix(\n            /**\n             * If the follow child has been completely hidden we animate\n             * this opacity from its previous opacity, but otherwise from completely transparent.\n             */\n            follow.isVisible !== false ? 0 : followTargetOpacity, leadTargetOpacity, easeCrossfadeIn(p));\n            followState.opacity = options.preserveFollowOpacity\n                ? followTargetOpacity\n                : popmotion.mix(followTargetOpacity, 0, easeCrossfadeOut(p));\n        }\n        else if (!follow) {\n            leadState.opacity = popmotion.mix(followTargetOpacity, leadTargetOpacity, p);\n        }\n        mixValues(leadState, followState, latestLeadValues, latestFollowValues || {}, Boolean(follow), p);\n    }\n    return {\n        isActive: function () {\n            return leadState &&\n                (isActive || sync.getFrameData().timestamp === finalCrossfadeFrame);\n        },\n        fromLead: function (transition) {\n            return startCrossfadeAnimation(0, transition);\n        },\n        toLead: function (transition) {\n            var initialProgress = 0;\n            if (!options.prevValues && !options.follow) {\n                /**\n                 * If we're not coming from anywhere, start at the end of the animation.\n                 */\n                initialProgress = 1;\n            }\n            else if (prevOptions.lead === options.follow &&\n                prevOptions.follow === options.lead) {\n                /**\n                 * If we're swapping follow/lead we can reverse the progress\n                 */\n                initialProgress = 1 - progress.get();\n            }\n            progress.set(initialProgress);\n            return startCrossfadeAnimation(1, transition);\n        },\n        reset: function () { return progress.set(1); },\n        stop: function () { return progress.stop(); },\n        getCrossfadeState: function (element) {\n            updateCrossfade();\n            if (element === options.lead) {\n                return leadState;\n            }\n            else if (element === options.follow) {\n                return followState;\n            }\n        },\n        setOptions: function (newOptions) {\n            prevOptions = options;\n            options = newOptions;\n            leadState = {};\n            followState = {};\n        },\n        getLatestValues: function () {\n            return leadState;\n        },\n    };\n}\nvar easeCrossfadeIn = compress(0, 0.5, popmotion.circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, popmotion.linear);\nfunction compress(min, max, easing) {\n    return function (p) {\n        // Could replace ifs with clamp\n        if (p < min)\n            return 0;\n        if (p > max)\n            return 1;\n        return easing(popmotion.progress(min, max, p));\n    };\n}\nvar borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nvar numBorders = borders.length;\nfunction mixValues(leadState, followState, latestLeadValues, latestFollowValues, hasFollowElement, p) {\n    /**\n     * Mix border radius\n     */\n    for (var i = 0; i < numBorders; i++) {\n        var borderLabel = \"border\" + borders[i] + \"Radius\";\n        var followRadius = getRadius(latestFollowValues, borderLabel);\n        var leadRadius = getRadius(latestLeadValues, borderLabel);\n        if (followRadius === undefined && leadRadius === undefined)\n            continue;\n        followRadius || (followRadius = 0);\n        leadRadius || (leadRadius = 0);\n        /**\n         * Currently we're only crossfading between numerical border radius.\n         * It would be possible to crossfade between percentages for a little\n         * extra bundle size.\n         */\n        if (typeof followRadius === \"number\" &&\n            typeof leadRadius === \"number\") {\n            var radius = Math.max(popmotion.mix(followRadius, leadRadius, p), 0);\n            leadState[borderLabel] = followState[borderLabel] = radius;\n        }\n    }\n    /**\n     * Mix rotation\n     */\n    if (latestFollowValues.rotate || latestLeadValues.rotate) {\n        var rotate = popmotion.mix(latestFollowValues.rotate || 0, latestLeadValues.rotate || 0, p);\n        leadState.rotate = followState.rotate = rotate;\n    }\n    /**\n     * We only want to mix the background color if there's a follow element\n     * that we're not crossfading opacity between. For instance with switch\n     * AnimateSharedLayout animations, this helps the illusion of a continuous\n     * element being animated but also cuts down on the number of paints triggered\n     * for elements where opacity is doing that work for us.\n     */\n    if (!hasFollowElement &&\n        latestLeadValues.backgroundColor &&\n        latestFollowValues.backgroundColor) {\n        /**\n         * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n         * We could probably create a mixer that runs at the start of the animation but\n         * the idea behind the crossfader is that it runs dynamically between two potentially\n         * changing targets (ie opacity or borderRadius may be animating independently via variants)\n         */\n        leadState.backgroundColor = followState.backgroundColor = popmotion.mixColor(latestFollowValues.backgroundColor, latestLeadValues.backgroundColor)(p);\n    }\n}\nfunction getRadius(values, radiusName) {\n    var _a;\n    return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n}\n\nfunction layoutStack() {\n    var stack = new Set();\n    var state = { leadIsExiting: false };\n    var prevState = tslib.__assign({}, state);\n    var prevValues;\n    var prevViewportBox;\n    var prevDragCursor;\n    var crossfader = createCrossfader();\n    var needsCrossfadeAnimation = false;\n    function getFollowViewportBox() {\n        return state.follow ? state.follow.prevViewportBox : prevViewportBox;\n    }\n    function getFollowLayout() {\n        var _a;\n        return (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getLayoutState().layout;\n    }\n    return {\n        add: function (element) {\n            element.setCrossfader(crossfader);\n            stack.add(element);\n            /**\n             * Hydrate new element with previous drag position if we have one\n             */\n            if (prevDragCursor)\n                element.prevDragCursor = prevDragCursor;\n            if (!state.lead)\n                state.lead = element;\n        },\n        remove: function (element) {\n            stack.delete(element);\n        },\n        getLead: function () { return state.lead; },\n        updateSnapshot: function () {\n            if (!state.lead)\n                return;\n            prevValues = crossfader.isActive()\n                ? crossfader.getLatestValues()\n                : state.lead.getLatestValues();\n            prevViewportBox = state.lead.prevViewportBox;\n            var dragControls = elementDragControls.get(state.lead);\n            if (dragControls && dragControls.isDragging) {\n                prevDragCursor = dragControls.cursorProgress;\n            }\n        },\n        clearSnapshot: function () {\n            prevDragCursor = prevViewportBox = undefined;\n        },\n        updateLeadAndFollow: function () {\n            var _a;\n            prevState = tslib.__assign({}, state);\n            var lead;\n            var follow;\n            var order = Array.from(stack);\n            for (var i = order.length; i--; i >= 0) {\n                var element = order[i];\n                if (lead)\n                    follow !== null && follow !== void 0 ? follow : (follow = element);\n                lead !== null && lead !== void 0 ? lead : (lead = element);\n                if (lead && follow)\n                    break;\n            }\n            state.lead = lead;\n            state.follow = follow;\n            state.leadIsExiting = ((_a = state.lead) === null || _a === void 0 ? void 0 : _a.presence) === Presence.Exiting;\n            crossfader.setOptions({\n                lead: lead,\n                follow: follow,\n                prevValues: prevValues,\n                crossfadeOpacity: (follow === null || follow === void 0 ? void 0 : follow.isPresenceRoot) || (lead === null || lead === void 0 ? void 0 : lead.isPresenceRoot),\n            });\n            if (\n            // Don't crossfade if we've just animated back from lead and switched the\n            // old follow to the new lead.\n            state.lead !== prevState.follow &&\n                (prevState.lead !== state.lead ||\n                    prevState.leadIsExiting !== state.leadIsExiting)) {\n                needsCrossfadeAnimation = true;\n            }\n        },\n        animate: function (child, shouldCrossfade) {\n            var _a;\n            if (shouldCrossfade === void 0) { shouldCrossfade = false; }\n            if (child === state.lead) {\n                if (shouldCrossfade) {\n                    /**\n                     * Point a lead to itself in case it was previously pointing\n                     * to a different visual element\n                     */\n                    child.pointTo(state.lead);\n                }\n                else {\n                    child.setVisibility(true);\n                }\n                var config = {};\n                var prevParent = (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getProjectionParent();\n                if (prevParent) {\n                    /**\n                     * We'll use this to determine if the element or its layoutId has been reparented.\n                     */\n                    config.prevParent = prevParent;\n                }\n                if (child.presence === Presence.Entering) {\n                    config.originBox = getFollowViewportBox();\n                }\n                else if (child.presence === Presence.Exiting) {\n                    config.targetBox = getFollowLayout();\n                }\n                if (needsCrossfadeAnimation) {\n                    needsCrossfadeAnimation = false;\n                    var transition = child.getDefaultTransition();\n                    child.presence === Presence.Entering\n                        ? crossfader.toLead(transition)\n                        : crossfader.fromLead(transition);\n                }\n                child.notifyLayoutReady(config);\n            }\n            else {\n                if (shouldCrossfade) {\n                    state.lead && child.pointTo(state.lead);\n                }\n                else {\n                    child.setVisibility(false);\n                }\n            }\n        },\n    };\n}\n\nfunction resetRotate(child) {\n    // If there's no detected rotation values, we can early return without a forced render.\n    var hasRotate = false;\n    // Keep a record of all the values we've reset\n    var resetValues = {};\n    // Check the rotate value of all axes and reset to 0\n    for (var i = 0; i < transformAxes.length; i++) {\n        var axis = transformAxes[i];\n        var key = \"rotate\" + axis;\n        // If this rotation doesn't exist as a motion value, then we don't\n        // need to reset it\n        if (!child.hasValue(key) || child.getStaticValue(key) === 0)\n            continue;\n        hasRotate = true;\n        // Record the rotation and then temporarily set it to 0\n        resetValues[key] = child.getStaticValue(key);\n        child.setStaticValue(key, 0);\n    }\n    // If there's no rotation values, we don't need to do any more.\n    if (!hasRotate)\n        return;\n    // Force a render of this element to apply the transform with all rotations\n    // set to 0.\n    child.syncRender();\n    // Put back all the values we reset\n    for (var key in resetValues) {\n        child.setStaticValue(key, resetValues[key]);\n    }\n    // Schedule a render for the next frame. This ensures we won't visually\n    // see the element with the reset rotate value applied.\n    child.scheduleRender();\n}\n\n/**\n * @public\n */\nvar AnimateSharedLayout = /** @class */ (function (_super) {\n    tslib.__extends(AnimateSharedLayout, _super);\n    function AnimateSharedLayout() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * A list of all the children in the shared layout\n         */\n        _this.children = new Set();\n        /**\n         * As animate components with a defined `layoutId` are added/removed to the tree,\n         * we store them in order. When one is added, it will animate out from the\n         * previous one, and when it's removed, it'll animate to the previous one.\n         */\n        _this.stacks = new Map();\n        /**\n         * Track whether the component has mounted. If it hasn't, the presence of added children\n         * are set to Present, whereas if it has they're considered Entering\n         */\n        _this.hasMounted = false;\n        /**\n         * Track whether we already have an update scheduled. If we don't, we'll run snapshots\n         * and schedule one.\n         */\n        _this.updateScheduled = false;\n        /**\n         * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\n         */\n        _this.renderScheduled = false;\n        /**\n         * The methods provided to all children in the shared layout tree.\n         */\n        _this.syncContext = tslib.__assign(tslib.__assign({}, createBatcher()), { syncUpdate: function (force) { return _this.scheduleUpdate(force); }, forceUpdate: function () {\n                // By copying syncContext to itself, when this component re-renders it'll also re-render\n                // all children subscribed to the SharedLayout context.\n                _this.syncContext = tslib.__assign({}, _this.syncContext);\n                _this.scheduleUpdate(true);\n            }, register: function (child) { return _this.addChild(child); }, remove: function (child) { return _this.removeChild(child); } });\n        return _this;\n    }\n    AnimateSharedLayout.prototype.componentDidMount = function () {\n        this.hasMounted = true;\n    };\n    AnimateSharedLayout.prototype.componentDidUpdate = function () {\n        this.startLayoutAnimation();\n    };\n    AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\n        this.renderScheduled = true;\n        return true;\n    };\n    AnimateSharedLayout.prototype.startLayoutAnimation = function () {\n        var _this = this;\n        /**\n         * Reset update and render scheduled status\n         */\n        this.renderScheduled = this.updateScheduled = false;\n        var type = this.props.type;\n        /**\n         * Update presence metadata based on the latest AnimatePresence status.\n         * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\n         */\n        this.children.forEach(function (child) {\n            if (!child.isPresent) {\n                child.presence = Presence.Exiting;\n            }\n            else if (child.presence !== Presence.Entering) {\n                child.presence =\n                    child.presence === Presence.Exiting\n                        ? Presence.Entering\n                        : Presence.Present;\n            }\n        });\n        this.updateStacks();\n        /**\n         * Create a handler which we can use to flush the children animations\n         */\n        var handler = {\n            layoutReady: function (child) {\n                if (child.getLayoutId() !== undefined) {\n                    var stack = _this.getStack(child);\n                    stack.animate(child, type === \"crossfade\");\n                }\n                else {\n                    child.notifyLayoutReady();\n                }\n            },\n            parent: this.context.visualElement,\n        };\n        /**\n         * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\n         * This requires some co-ordination across components to stop layout thrashing\n         * and ensure measurements are taken at the correct time.\n         *\n         * Here we use that same mechanism of schedule/flush.\n         */\n        this.children.forEach(function (child) { return _this.syncContext.add(child); });\n        this.syncContext.flush(handler);\n        /**\n         * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\n         */\n        this.stacks.forEach(function (stack) { return stack.clearSnapshot(); });\n    };\n    AnimateSharedLayout.prototype.updateStacks = function () {\n        this.stacks.forEach(function (stack) { return stack.updateLeadAndFollow(); });\n    };\n    AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\n        if (force === void 0) { force = false; }\n        if (!(force || !this.updateScheduled))\n            return;\n        /**\n         * Flag we've scheduled an update\n         */\n        this.updateScheduled = true;\n        /**\n         * Write: Reset transforms so bounding boxes can be accurately measured.\n         */\n        this.children.forEach(function (child) {\n            resetRotate(child);\n            if (child.shouldResetTransform())\n                child.resetTransform();\n        });\n        /**\n         * Read: Snapshot children\n         */\n        this.children.forEach(snapshotViewportBox);\n        /**\n         * Every child keeps a local snapshot, but we also want to record\n         * snapshots of the visible children as, if they're are being removed\n         * in this render, we can still access them.\n         *\n         * TODO: What would be better here is doing a single loop where we\n         * only snapshotViewportBoxes of undefined layoutIds and then one for each stack\n         */\n        this.stacks.forEach(function (stack) { return stack.updateSnapshot(); });\n        /**\n         * Force a rerender by setting state if we aren't already going to render.\n         */\n        if (force || !this.renderScheduled) {\n            this.renderScheduled = true;\n            this.forceUpdate();\n        }\n    };\n    AnimateSharedLayout.prototype.addChild = function (child) {\n        this.children.add(child);\n        this.addToStack(child);\n        child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n    };\n    AnimateSharedLayout.prototype.removeChild = function (child) {\n        this.scheduleUpdate();\n        this.children.delete(child);\n        this.removeFromStack(child);\n    };\n    AnimateSharedLayout.prototype.addToStack = function (child) {\n        var stack = this.getStack(child);\n        stack === null || stack === void 0 ? void 0 : stack.add(child);\n    };\n    AnimateSharedLayout.prototype.removeFromStack = function (child) {\n        var stack = this.getStack(child);\n        stack === null || stack === void 0 ? void 0 : stack.remove(child);\n    };\n    /**\n     * Return a stack of animate children based on the provided layoutId.\n     * Will create a stack if none currently exists with that layoutId.\n     */\n    AnimateSharedLayout.prototype.getStack = function (child) {\n        var id = child.getLayoutId();\n        if (id === undefined)\n            return;\n        // Create stack if it doesn't already exist\n        !this.stacks.has(id) && this.stacks.set(id, layoutStack());\n        return this.stacks.get(id);\n    };\n    AnimateSharedLayout.prototype.render = function () {\n        return (React__namespace.createElement(SharedLayoutContext.Provider, { value: this.syncContext }, this.props.children));\n    };\n    AnimateSharedLayout.contextType = MotionContext;\n    return AnimateSharedLayout;\n}(React__namespace.Component));\n\n/**\n * `MotionConfig` is used to set configuration options for all children `motion` components.\n *\n * ```jsx\n * import { motion, MotionConfig } from \"framer-motion\"\n *\n * export function App() {\n *   return (\n *     <MotionConfig transition={{ type: \"spring\" }}>\n *       <motion.div animate={{ x: 100 }} />\n *     </MotionConfig>\n *   )\n * }\n * ```\n *\n * @public\n */\nfunction MotionConfig(_a) {\n    var children = _a.children, config = tslib.__rest(_a, [\"children\"]);\n    /**\n     * Inherit props from any parent MotionConfig components\n     */\n    config = tslib.__assign(tslib.__assign({}, React.useContext(MotionConfigContext)), config);\n    /**\n     * Don't allow isStatic to change between renders as it affects how many hooks\n     * motion components fire.\n     */\n    config.isStatic = useConstant(function () { return config.isStatic; });\n    /**\n     * Creating a new config context object will re-render every `motion` component\n     * every time it renders. So we only want to create a new one sparingly.\n     */\n    var transitionDependency = typeof config.transition === \"object\"\n        ? config.transition.toString()\n        : \"\";\n    var context = React.useMemo(function () { return config; }, [\n        transitionDependency,\n        config.transformPagePoint,\n    ]);\n    return (React__namespace.createElement(MotionConfigContext.Provider, { value: context }, children));\n}\n\n/**\n * Used in conjunction with the `m` component to reduce bundle size.\n *\n * `m` is a version of the `motion` component that only loads functionality\n * critical for the initial render.\n *\n * `LazyMotion` can then be used to either synchronously or asynchronously\n * load animation and gesture support.\n *\n * ```jsx\n * // Synchronous loading\n * import { LazyMotion, m, domAnimations } from \"framer-motion\"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={domAnimations}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n *\n * // Asynchronous loading\n * import { LazyMotion, m } from \"framer-motion\"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={() => import('./path/to/domAnimations')}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n * ```\n *\n * @public\n */\nfunction LazyMotion(_a) {\n    var children = _a.children, features = _a.features, _b = _a.strict, strict = _b === void 0 ? false : _b;\n    var _c = tslib.__read(React.useState(!isLazyBundle(features)), 2), setIsLoaded = _c[1];\n    var loadedRenderer = React.useRef(undefined);\n    /**\n     * If this is a synchronous load, load features immediately\n     */\n    if (!isLazyBundle(features)) {\n        var renderer = features.renderer, loadedFeatures = tslib.__rest(features, [\"renderer\"]);\n        loadedRenderer.current = renderer;\n        loadFeatures(loadedFeatures);\n    }\n    React.useEffect(function () {\n        if (isLazyBundle(features)) {\n            features().then(function (_a) {\n                var renderer = _a.renderer, loadedFeatures = tslib.__rest(_a, [\"renderer\"]);\n                loadFeatures(loadedFeatures);\n                loadedRenderer.current = renderer;\n                setIsLoaded(true);\n            });\n        }\n    }, []);\n    return (React__namespace.createElement(LazyContext.Provider, { value: { renderer: loadedRenderer.current, strict: strict } }, children));\n}\nfunction isLazyBundle(features) {\n    return typeof features === \"function\";\n}\n\n/**\n * @public\n */\nvar domAnimation = tslib.__assign(tslib.__assign({ renderer: createDomVisualElement }, animations), gestureAnimations);\n\n/**\n * @public\n */\nvar domMax = tslib.__assign(tslib.__assign(tslib.__assign({}, domAnimation), drag), layoutAnimations);\n\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * @library\n *\n * ```jsx\n * export function MyComponent() {\n *   const scale = useMotionValue(1)\n *\n *   return <Frame scale={scale} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\nfunction useMotionValue(initial) {\n    var value = useConstant(function () { return motionValue(initial); });\n    /**\n     * If this motion value is being used in static mode, like on\n     * the Framer canvas, force components to rerender when the motion\n     * value is updated.\n     */\n    var isStatic = React.useContext(MotionConfigContext).isStatic;\n    if (isStatic) {\n        var _a = tslib.__read(React.useState(initial), 2), setLatest_1 = _a[1];\n        React.useEffect(function () { return value.onChange(setLatest_1); }, []);\n    }\n    return value;\n}\n\nfunction useOnChange(value, callback) {\n    React.useEffect(function () {\n        if (isMotionValue(value))\n            return value.onChange(callback);\n    }, [callback]);\n}\nfunction useMultiOnChange(values, handler) {\n    React.useEffect(function () {\n        var subscriptions = values.map(function (value) { return value.onChange(handler); });\n        return function () { return subscriptions.forEach(function (unsubscribe) { return unsubscribe(); }); };\n    });\n}\n\nfunction useCombineMotionValues(values, combineValues) {\n    /**\n     * Initialise the returned motion value. This remains the same between renders.\n     */\n    var value = useMotionValue(combineValues());\n    /**\n     * Create a function that will update the template motion value with the latest values.\n     * This is pre-bound so whenever a motion value updates it can schedule its\n     * execution in Framesync. If it's already been scheduled it won't be fired twice\n     * in a single frame.\n     */\n    var updateValue = function () { return value.set(combineValues()); };\n    /**\n     * Synchronously update the motion value with the latest values during the render.\n     * This ensures that within a React render, the styles applied to the DOM are up-to-date.\n     */\n    updateValue();\n    /**\n     * Subscribe to all motion values found within the template. Whenever any of them change,\n     * schedule an update.\n     */\n    useMultiOnChange(values, function () { return sync__default['default'].update(updateValue, false, true); });\n    return value;\n}\n\n/**\n * Combine multiple motion values into a new one using a string template literal.\n *\n * ```jsx\n * import {\n *   motion,\n *   useSpring,\n *   useMotionValue,\n *   useMotionTemplate\n * } from \"framer-motion\"\n *\n * function Component() {\n *   const shadowX = useSpring(0)\n *   const shadowY = useMotionValue(0)\n *   const shadow = useMotionTemplate`drop-shadow(${shadowX}px ${shadowY}px 20px rgba(0,0,0,0.3))`\n *\n *   return <motion.div style={{ filter: shadow }} />\n * }\n * ```\n *\n * @public\n */\nfunction useMotionTemplate(fragments) {\n    var values = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        values[_i - 1] = arguments[_i];\n    }\n    /**\n     * Create a function that will build a string from the latest motion values.\n     */\n    var numFragments = fragments.length;\n    function buildValue() {\n        var output = \"\";\n        for (var i = 0; i < numFragments; i++) {\n            output += fragments[i];\n            var value = values[i];\n            if (value)\n                output += values[i].get();\n        }\n        return output;\n    }\n    return useCombineMotionValues(values, buildValue);\n}\n\nvar isCustomValueType = function (v) {\n    return typeof v === \"object\" && v.mix;\n};\nvar getMixer = function (v) { return (isCustomValueType(v) ? v.mix : undefined); };\nfunction transform() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var useImmediate = !Array.isArray(args[0]);\n    var argOffset = useImmediate ? 0 : -1;\n    var inputValue = args[0 + argOffset];\n    var inputRange = args[1 + argOffset];\n    var outputRange = args[2 + argOffset];\n    var options = args[3 + argOffset];\n    var interpolator = popmotion.interpolate(inputRange, outputRange, tslib.__assign({ mixer: getMixer(outputRange[0]) }, options));\n    return useImmediate ? interpolator(inputValue) : interpolator;\n}\n\nfunction useTransform(input, inputRangeOrTransformer, outputRange, options) {\n    var transformer = typeof inputRangeOrTransformer === \"function\"\n        ? inputRangeOrTransformer\n        : transform(inputRangeOrTransformer, outputRange, options);\n    return Array.isArray(input)\n        ? useListTransform(input, transformer)\n        : useListTransform([input], function (_a) {\n            var _b = tslib.__read(_a, 1), latest = _b[0];\n            return transformer(latest);\n        });\n}\nfunction useListTransform(values, transformer) {\n    var latest = useConstant(function () { return []; });\n    return useCombineMotionValues(values, function () {\n        latest.length = 0;\n        var numValues = values.length;\n        for (var i = 0; i < numValues; i++) {\n            latest[i] = values[i].get();\n        }\n        return transformer(latest);\n    });\n}\n\n/**\n * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.\n *\n * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber\n * to another `MotionValue`.\n *\n * @remarks\n *\n * ```jsx\n * const x = useSpring(0, { stiffness: 300 })\n * const y = useSpring(x, { damping: 10 })\n * ```\n *\n * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.\n * @param springConfig - Configuration options for the spring.\n * @returns `MotionValue`\n *\n * @public\n */\nfunction useSpring(source, config) {\n    if (config === void 0) { config = {}; }\n    var isStatic = React.useContext(MotionConfigContext).isStatic;\n    var activeSpringAnimation = React.useRef(null);\n    var value = useMotionValue(isMotionValue(source) ? source.get() : source);\n    React.useMemo(function () {\n        return value.attach(function (v, set) {\n            /**\n             * A more hollistic approach to this might be to use isStatic to fix VisualElement animations\n             * at that level, but this will work for now\n             */\n            if (isStatic)\n                return set(v);\n            if (activeSpringAnimation.current) {\n                activeSpringAnimation.current.stop();\n            }\n            activeSpringAnimation.current = popmotion.animate(tslib.__assign(tslib.__assign({ from: value.get(), to: v, velocity: value.getVelocity() }, config), { onUpdate: set }));\n            return value.get();\n        });\n    }, Object.values(config));\n    useOnChange(source, function (v) { return value.set(parseFloat(v)); });\n    return value;\n}\n\n/**\n * Creates a `MotionValue` that updates when the velocity of the provided `MotionValue` changes.\n *\n * ```javascript\n * const x = useMotionValue(0)\n * const xVelocity = useVelocity(x)\n * const xAcceleration = useVelocity(xVelocity)\n * ```\n *\n * @public\n */\nfunction useVelocity(value) {\n    var velocity = useMotionValue(value.getVelocity());\n    React.useEffect(function () {\n        return value.velocityUpdateSubscribers.add(function (newVelocity) {\n            velocity.set(newVelocity);\n        });\n    }, [value]);\n    return velocity;\n}\n\nfunction createScrollMotionValues() {\n    return {\n        scrollX: motionValue(0),\n        scrollY: motionValue(0),\n        scrollXProgress: motionValue(0),\n        scrollYProgress: motionValue(0),\n    };\n}\nfunction setProgress(offset, maxOffset, value) {\n    value.set(!offset || !maxOffset ? 0 : offset / maxOffset);\n}\nfunction createScrollUpdater(values, getOffsets) {\n    var update = function () {\n        var _a = getOffsets(), xOffset = _a.xOffset, yOffset = _a.yOffset, xMaxOffset = _a.xMaxOffset, yMaxOffset = _a.yMaxOffset;\n        // Set absolute positions\n        values.scrollX.set(xOffset);\n        values.scrollY.set(yOffset);\n        // Set 0-1 progress\n        setProgress(xOffset, xMaxOffset, values.scrollXProgress);\n        setProgress(yOffset, yMaxOffset, values.scrollYProgress);\n    };\n    update();\n    return update;\n}\n\nvar getElementScrollOffsets = function (element) { return function () {\n    return {\n        xOffset: element.scrollLeft,\n        yOffset: element.scrollTop,\n        xMaxOffset: element.scrollWidth - element.offsetWidth,\n        yMaxOffset: element.scrollHeight - element.offsetHeight,\n    };\n}; };\n/**\n * Returns MotionValues that update when the provided element scrolls:\n *\n * - `scrollX`  Horizontal scroll distance in pixels.\n * - `scrollY`  Vertical scroll distance in pixels.\n * - `scrollXProgress`  Horizontal scroll progress between `0` and `1`.\n * - `scrollYProgress`  Vertical scroll progress between `0` and `1`.\n *\n * This element must be set to `overflow: scroll` on either or both axes to report scroll offset.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import {\n *   Frame,\n *   useElementScroll,\n *   useTransform\n * } from \"framer\"\n *\n * export function MyComponent() {\n *   const ref = React.useRef()\n *   const { scrollYProgress } = useElementScroll(ref)\n *\n *   return (\n *     <Frame ref={ref}>\n *       <Frame scaleX={scrollYProgress} />\n *     </Frame>\n *   )\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const ref = useRef()\n *   const { scrollYProgress } = useElementScroll(ref)\n *\n *   return (\n *     <div ref={ref}>\n *       <motion.div style={{ scaleX: scrollYProgress }} />\n *     </div>\n *   )\n * }\n * ```\n *\n * @public\n */\nfunction useElementScroll(ref) {\n    var values = useConstant(createScrollMotionValues);\n    useIsomorphicLayoutEffect(function () {\n        var element = ref.current;\n        heyListen.invariant(!!element, \"ref provided to useScroll must be passed into a HTML element.\");\n        if (!element)\n            return;\n        var updateScrollValues = createScrollUpdater(values, getElementScrollOffsets(element));\n        var scrollListener = addDomEvent(element, \"scroll\", updateScrollValues, { passive: true });\n        var resizeListener = addDomEvent(element, \"resize\", updateScrollValues);\n        return function () {\n            scrollListener && scrollListener();\n            resizeListener && resizeListener();\n        };\n    }, []);\n    return values;\n}\n\nvar viewportScrollValues;\nfunction getViewportScrollOffsets() {\n    return {\n        xOffset: window.pageXOffset,\n        yOffset: window.pageYOffset,\n        xMaxOffset: document.body.clientWidth - window.innerWidth,\n        yMaxOffset: document.body.clientHeight - window.innerHeight,\n    };\n}\nvar hasListeners = false;\nfunction addEventListeners() {\n    hasListeners = true;\n    if (typeof window === \"undefined\")\n        return;\n    var updateScrollValues = createScrollUpdater(viewportScrollValues, getViewportScrollOffsets);\n    addDomEvent(window, \"scroll\", updateScrollValues, { passive: true });\n    addDomEvent(window, \"resize\", updateScrollValues);\n}\n/**\n * Returns MotionValues that update when the viewport scrolls:\n *\n * - `scrollX`  Horizontal scroll distance in pixels.\n * - `scrollY`  Vertical scroll distance in pixels.\n * - `scrollXProgress`  Horizontal scroll progress between `0` and `1`.\n * - `scrollYProgress`  Vertical scroll progress between `0` and `1`.\n *\n * **Warning:** Setting `body` or `html` to `height: 100%` or similar will break the `Progress`\n * values as this breaks the browser's capability to accurately measure the page length.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import {\n *   Frame,\n *   useViewportScroll,\n *   useTransform\n * } from \"framer\"\n *\n * export function MyComponent() {\n *   const { scrollYProgress } = useViewportScroll()\n *   return <Frame scaleX={scrollYProgress} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const { scrollYProgress } = useViewportScroll()\n *   return <motion.div style={{ scaleX: scrollYProgress }} />\n * }\n * ```\n *\n * @public\n */\nfunction useViewportScroll() {\n    /**\n     * Lazy-initialise the viewport scroll values\n     */\n    if (!viewportScrollValues) {\n        viewportScrollValues = createScrollMotionValues();\n    }\n    useIsomorphicLayoutEffect(function () {\n        !hasListeners && addEventListeners();\n    }, []);\n    return viewportScrollValues;\n}\n\n// Does this device prefer reduced motion? Returns `null` server-side.\nvar prefersReducedMotion;\nfunction initPrefersReducedMotion() {\n    prefersReducedMotion = motionValue(null);\n    if (typeof window === \"undefined\")\n        return;\n    if (window.matchMedia) {\n        var motionMediaQuery_1 = window.matchMedia(\"(prefers-reduced-motion)\");\n        var setReducedMotionPreferences = function () {\n            return prefersReducedMotion.set(motionMediaQuery_1.matches);\n        };\n        motionMediaQuery_1.addListener(setReducedMotionPreferences);\n        setReducedMotionPreferences();\n    }\n    else {\n        prefersReducedMotion.set(false);\n    }\n}\n/**\n * A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.\n *\n * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing\n * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.\n *\n * It will actively respond to changes and re-render your components with the latest setting.\n *\n * ```jsx\n * export function Sidebar({ isOpen }) {\n *   const shouldReduceMotion = useReducedMotion()\n *   const closedX = shouldReduceMotion ? 0 : \"-100%\"\n *\n *   return (\n *     <motion.div animate={{\n *       opacity: isOpen ? 1 : 0,\n *       x: isOpen ? 0 : closedX\n *     }} />\n *   )\n * }\n * ```\n *\n * @return boolean\n *\n * @public\n */\nfunction useReducedMotion() {\n    /**\n     * Lazy initialisation of prefersReducedMotion\n     */\n    !prefersReducedMotion && initPrefersReducedMotion();\n    var _a = tslib.__read(React.useState(prefersReducedMotion.get()), 2), shouldReduceMotion = _a[0], setShouldReduceMotion = _a[1];\n    useOnChange(prefersReducedMotion, setShouldReduceMotion);\n    return shouldReduceMotion;\n}\n\n/**\n * @public\n */\nfunction animationControls() {\n    /**\n     * Track whether the host component has mounted.\n     */\n    var hasMounted = false;\n    /**\n     * Pending animations that are started before a component is mounted.\n     * TODO: Remove this as animations should only run in effects\n     */\n    var pendingAnimations = [];\n    /**\n     * A collection of linked component animation controls.\n     */\n    var subscribers = new Set();\n    var controls = {\n        subscribe: function (visualElement) {\n            subscribers.add(visualElement);\n            return function () { return void subscribers.delete(visualElement); };\n        },\n        start: function (definition, transitionOverride) {\n            /**\n             * TODO: We only perform this hasMounted check because in Framer we used to\n             * encourage the ability to start an animation within the render phase. This\n             * isn't behaviour concurrent-safe so when we make Framer concurrent-safe\n             * we can ditch this.\n             */\n            if (hasMounted) {\n                var animations_1 = [];\n                subscribers.forEach(function (visualElement) {\n                    animations_1.push(animateVisualElement(visualElement, definition, {\n                        transitionOverride: transitionOverride,\n                    }));\n                });\n                return Promise.all(animations_1);\n            }\n            else {\n                return new Promise(function (resolve) {\n                    pendingAnimations.push({\n                        animation: [definition, transitionOverride],\n                        resolve: resolve,\n                    });\n                });\n            }\n        },\n        set: function (definition) {\n            heyListen.invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            return subscribers.forEach(function (visualElement) {\n                setValues(visualElement, definition);\n            });\n        },\n        stop: function () {\n            subscribers.forEach(function (visualElement) {\n                stopAnimation(visualElement);\n            });\n        },\n        mount: function () {\n            hasMounted = true;\n            pendingAnimations.forEach(function (_a) {\n                var animation = _a.animation, resolve = _a.resolve;\n                controls.start.apply(controls, tslib.__spreadArray([], tslib.__read(animation))).then(resolve);\n            });\n            return function () {\n                hasMounted = false;\n                controls.stop();\n            };\n        },\n    };\n    return controls;\n}\n\n/**\n * Creates `AnimationControls`, which can be used to manually start, stop\n * and sequence animations on one or more components.\n *\n * The returned `AnimationControls` should be passed to the `animate` property\n * of the components you want to animate.\n *\n * These components can then be animated with the `start` method.\n *\n * @library\n *\n * ```jsx\n * import * as React from 'react'\n * import { Frame, useAnimation } from 'framer'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <Frame animate={controls} />\n * }\n * ```\n *\n * @motion\n *\n * ```jsx\n * import * as React from 'react'\n * import { motion, useAnimation } from 'framer-motion'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <motion.div animate={controls} />\n * }\n * ```\n *\n * @returns Animation controller with `start` and `stop` methods\n *\n * @public\n */\nfunction useAnimation() {\n    var controls = useConstant(animationControls);\n    React.useEffect(controls.mount, []);\n    return controls;\n}\n\n/**\n * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.\n *\n * @library\n *\n * ```jsx\n * import * as React from \"react\"\n * import { Frame, useCycle } from \"framer\"\n *\n * export function MyComponent() {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <Frame\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @motion\n *\n * An index value can be passed to the returned `cycle` function to cycle to a specific index.\n *\n * ```jsx\n * import * as React from \"react\"\n * import { motion, useCycle } from \"framer-motion\"\n *\n * export const MyComponent = () => {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <motion.div\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @param items - items to cycle through\n * @returns [currentState, cycleState]\n *\n * @public\n */\nfunction useCycle() {\n    var items = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        items[_i] = arguments[_i];\n    }\n    var index = React.useRef(0);\n    var _a = tslib.__read(React.useState(items[index.current]), 2), item = _a[0], setItem = _a[1];\n    return [\n        item,\n        function (next) {\n            index.current =\n                typeof next !== \"number\"\n                    ? popmotion.wrap(0, items.length, index.current + 1)\n                    : next;\n            setItem(items[index.current]);\n        },\n    ];\n}\n\n/**\n * Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.\n *\n * @library\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <Frame onTapStart={startDrag} />\n *     <Frame drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @motion\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\nvar DragControls = /** @class */ (function () {\n    function DragControls() {\n        this.componentControls = new Set();\n    }\n    /**\n     * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.\n     *\n     * @internal\n     */\n    DragControls.prototype.subscribe = function (controls) {\n        var _this = this;\n        this.componentControls.add(controls);\n        return function () { return _this.componentControls.delete(controls); };\n    };\n    /**\n     * Start a drag gesture on every `motion` component that has this set of drag controls\n     * passed into it via the `dragControls` prop.\n     *\n     * ```jsx\n     * dragControls.start(e, {\n     *   snapToCursor: true\n     * })\n     * ```\n     *\n     * @param event - PointerEvent\n     * @param options - Options\n     *\n     * @public\n     */\n    DragControls.prototype.start = function (event, options) {\n        this.componentControls.forEach(function (controls) {\n            controls.start(event.nativeEvent || event, options);\n        });\n    };\n    DragControls.prototype.updateConstraints = function (flush) {\n        if (flush === void 0) { flush = true; }\n        this.componentControls.forEach(function (controls) {\n            controls.updateConstraints();\n        });\n        flush && flushLayout();\n    };\n    return DragControls;\n}());\nvar createDragControls = function () { return new DragControls(); };\n/**\n * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop\n * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we\n * might want to initiate that dragging from a different component than the draggable one.\n *\n * By creating a `dragControls` using the `useDragControls` hook, we can pass this into\n * the draggable component's `dragControls` prop. It exposes a `start` method\n * that can start dragging from pointer events on other components.\n *\n * @library\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <Frame onTapStart={startDrag} />\n *     <Frame drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @motion\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\nfunction useDragControls() {\n    return useConstant(createDragControls);\n}\n\nvar createObject = function () { return ({}); };\nvar stateVisualElement = visualElement({\n    build: function () { },\n    measureViewportBox: axisBox,\n    resetTransform: function () { },\n    restoreTransform: function () { },\n    removeValueFromRenderState: function () { },\n    render: function () { },\n    scrapeMotionValuesFromProps: createObject,\n    readValueFromInstance: function (_state, key, options) {\n        return options.initialState[key] || 0;\n    },\n    makeTargetAnimatable: function (element, _a) {\n        var transition = _a.transition, transitionEnd = _a.transitionEnd, target = tslib.__rest(_a, [\"transition\", \"transitionEnd\"]);\n        var origin = getOrigin(target, transition || {}, element);\n        checkTargetForNewValues(element, target, origin);\n        return tslib.__assign({ transition: transition, transitionEnd: transitionEnd }, target);\n    },\n});\nvar useVisualState = makeUseVisualState({\n    scrapeMotionValuesFromProps: createObject,\n    createRenderState: createObject,\n});\n/**\n * This is not an officially supported API and may be removed\n * on any version.\n * @internal\n */\nfunction useAnimatedState(initialState) {\n    var _a = tslib.__read(React.useState(initialState), 2), animationState = _a[0], setAnimationState = _a[1];\n    var visualState = useVisualState({}, false);\n    var element = useConstant(function () {\n        return stateVisualElement({ props: {}, visualState: visualState }, { initialState: initialState });\n    });\n    React.useEffect(function () {\n        element.mount({});\n        return element.unmount();\n    }, []);\n    React.useEffect(function () {\n        element.setProps({\n            onUpdate: function (v) { return setAnimationState(tslib.__assign({}, v)); },\n        });\n    });\n    var startAnimation = useConstant(function () { return function (animationDefinition) {\n        return animateVisualElement(element, animationDefinition);\n    }; });\n    return [animationState, startAnimation];\n}\n\n// Keep things reasonable and avoid scale: Infinity. In practise we might need\n// to add another value, opacity, that could interpolate scaleX/Y [0,0.01] => [0,1]\n// to simply hide content at unreasonable scales.\nvar maxScale = 100000;\nvar invertScale = function (scale) {\n    return scale > 0.001 ? 1 / scale : maxScale;\n};\nvar hasWarned = false;\n/**\n * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse\n * of their respective parent scales.\n *\n * This is useful for undoing the distortion of content when scaling a parent component.\n *\n * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.\n * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output\n * of those instead.\n *\n * @motion\n *\n * ```jsx\n * const MyComponent = () => {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <motion.div style={{ scaleX, scaleY }} />\n * }\n * ```\n *\n * @library\n *\n * ```jsx\n * function MyComponent() {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <Frame scaleX={scaleX} scaleY={scaleY} />\n * }\n * ```\n *\n * @deprecated\n * @internal\n */\nfunction useInvertedScale(scale) {\n    var parentScaleX = useMotionValue(1);\n    var parentScaleY = useMotionValue(1);\n    var visualElement = useVisualElementContext();\n    heyListen.invariant(!!(scale || visualElement), \"If no scale values are provided, useInvertedScale must be used within a child of another motion component.\");\n    heyListen.warning(hasWarned, \"useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.\");\n    hasWarned = true;\n    if (scale) {\n        parentScaleX = scale.scaleX || parentScaleX;\n        parentScaleY = scale.scaleY || parentScaleY;\n    }\n    else if (visualElement) {\n        parentScaleX = visualElement.getValue(\"scaleX\", 1);\n        parentScaleY = visualElement.getValue(\"scaleY\", 1);\n    }\n    var scaleX = useTransform(parentScaleX, invertScale);\n    var scaleY = useTransform(parentScaleY, invertScale);\n    return { scaleX: scaleX, scaleY: scaleY };\n}\n\nexports.AnimatePresence = AnimatePresence;\nexports.AnimateSharedLayout = AnimateSharedLayout;\nexports.DragControls = DragControls;\nexports.FlatTree = FlatTree;\nexports.FramerTreeLayoutContext = FramerTreeLayoutContext;\nexports.LayoutGroupContext = LayoutGroupContext;\nexports.LazyMotion = LazyMotion;\nexports.MotionConfig = MotionConfig;\nexports.MotionConfigContext = MotionConfigContext;\nexports.MotionValue = MotionValue;\nexports.PresenceContext = PresenceContext;\nexports.SharedLayoutContext = SharedLayoutContext;\nexports.addScaleCorrection = addScaleCorrection;\nexports.animate = animate;\nexports.animateVisualElement = animateVisualElement;\nexports.animationControls = animationControls;\nexports.batchLayout = batchLayout;\nexports.createBatcher = createBatcher;\nexports.createCrossfader = createCrossfader;\nexports.createDomMotionComponent = createDomMotionComponent;\nexports.createMotionComponent = createMotionComponent;\nexports.domAnimation = domAnimation;\nexports.domMax = domMax;\nexports.flushLayout = flushLayout;\nexports.isValidMotionProp = isValidMotionProp;\nexports.m = m;\nexports.motion = motion;\nexports.motionValue = motionValue;\nexports.resolveMotionValue = resolveMotionValue;\nexports.snapshotViewportBox = snapshotViewportBox;\nexports.transform = transform;\nexports.useAnimation = useAnimation;\nexports.useCycle = useCycle;\nexports.useDeprecatedAnimatedState = useAnimatedState;\nexports.useDeprecatedInvertedScale = useInvertedScale;\nexports.useDomEvent = useDomEvent;\nexports.useDragControls = useDragControls;\nexports.useElementScroll = useElementScroll;\nexports.useIsPresent = useIsPresent;\nexports.useMotionTemplate = useMotionTemplate;\nexports.useMotionValue = useMotionValue;\nexports.usePresence = usePresence;\nexports.useReducedMotion = useReducedMotion;\nexports.useSpring = useSpring;\nexports.useTransform = useTransform;\nexports.useVelocity = useVelocity;\nexports.useViewportScroll = useViewportScroll;\nexports.visualElement = visualElement;\n"],"mappings":"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I,CAACtI,IAAI,GAAG,IAAI,CAACxb,OAAO,GAAGH,IAAI;IAC/B,IAAI,CAACwjB,gBAAgB,GAAGR,OAAO,CAAC,IAAI,CAAC7iB,OAAO,CAAC;EACjD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI+iB,WAAW,CAACvgB,SAAS,CAACuhB,QAAQ,GAAG,UAAUC,YAAY,EAAE;IACrD,OAAO,IAAI,CAACd,iBAAiB,CAACZ,GAAG,CAAC0B,YAAY,CAAC;EACnD,CAAC;EACDjB,WAAW,CAACvgB,SAAS,CAACyhB,cAAc,GAAG,YAAY;IAC/C,IAAI,CAACf,iBAAiB,CAACN,KAAK,EAAE;EAClC,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIG,WAAW,CAACvgB,SAAS,CAAC0hB,eAAe,GAAG,UAAUF,YAAY,EAAE;IAC5D;IACAA,YAAY,CAAC,IAAI,CAAC1nB,GAAG,EAAE,CAAC;IACxB,OAAO,IAAI,CAAC8mB,iBAAiB,CAACd,GAAG,CAAC0B,YAAY,CAAC;EACnD,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIjB,WAAW,CAACvgB,SAAS,CAAC2hB,MAAM,GAAG,UAAUC,aAAa,EAAE;IACpD,IAAI,CAACA,aAAa,GAAGA,aAAa;EACtC,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIrB,WAAW,CAACvgB,SAAS,CAAC0D,GAAG,GAAG,UAAUhD,CAAC,EAAEqgB,MAAM,EAAE;IAC7C,IAAIA,MAAM,KAAK,KAAK,CAAC,EAAE;MAAEA,MAAM,GAAG,IAAI;IAAE;IACxC,IAAI,CAACA,MAAM,IAAI,CAAC,IAAI,CAACa,aAAa,EAAE;MAChC,IAAI,CAACd,eAAe,CAACpgB,CAAC,EAAEqgB,MAAM,CAAC;IACnC,CAAC,MACI;MACD,IAAI,CAACa,aAAa,CAAClhB,CAAC,EAAE,IAAI,CAACogB,eAAe,CAAC;IAC/C;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIP,WAAW,CAACvgB,SAAS,CAAClG,GAAG,GAAG,YAAY;IACpC,OAAO,IAAI,CAAC0D,OAAO;EACvB,CAAC;EACD;AACJ;AACA;EACI+iB,WAAW,CAACvgB,SAAS,CAAC6hB,WAAW,GAAG,YAAY;IAC5C,OAAO,IAAI,CAAC7I,IAAI;EACpB,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIuH,WAAW,CAACvgB,SAAS,CAACkB,WAAW,GAAG,YAAY;IAC5C;IACA,OAAO,IAAI,CAAC2f,gBAAgB;IACtB;IACE5nB,SAAS,CAAC6oB,iBAAiB,CAAChD,UAAU,CAAC,IAAI,CAACthB,OAAO,CAAC,GAChDshB,UAAU,CAAC,IAAI,CAAC9F,IAAI,CAAC,EAAE,IAAI,CAACwH,SAAS,CAAC,GAC5C,CAAC;EACX,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACID,WAAW,CAACvgB,SAAS,CAAC6B,KAAK,GAAG,UAAUjH,SAAS,EAAE;IAC/C,IAAImlB,KAAK,GAAG,IAAI;IAChB,IAAI,CAAClB,IAAI,EAAE;IACX,OAAO,IAAIkD,OAAO,CAAC,UAAUC,OAAO,EAAE;MAClCjC,KAAK,CAACuB,WAAW,GAAG,IAAI;MACxBvB,KAAK,CAACkC,aAAa,GAAGrnB,SAAS,CAAConB,OAAO,CAAC;IAC5C,CAAC,CAAC,CAACE,IAAI,CAAC,YAAY;MAAE,OAAOnC,KAAK,CAACoC,cAAc,EAAE;IAAE,CAAC,CAAC;EAC3D,CAAC;EACD;AACJ;AACA;AACA;AACA;EACI5B,WAAW,CAACvgB,SAAS,CAAC6e,IAAI,GAAG,YAAY;IACrC,IAAI,IAAI,CAACoD,aAAa,EAClB,IAAI,CAACA,aAAa,EAAE;IACxB,IAAI,CAACE,cAAc,EAAE;EACzB,CAAC;EACD;AACJ;AACA;AACA;AACA;EACI5B,WAAW,CAACvgB,SAAS,CAACoiB,WAAW,GAAG,YAAY;IAC5C,OAAO,CAAC,CAAC,IAAI,CAACH,aAAa;EAC/B,CAAC;EACD1B,WAAW,CAACvgB,SAAS,CAACmiB,cAAc,GAAG,YAAY;IAC/C,IAAI,CAACF,aAAa,GAAG,IAAI;EAC7B,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI1B,WAAW,CAACvgB,SAAS,CAACqiB,OAAO,GAAG,YAAY;IACxC,IAAI,CAAC3B,iBAAiB,CAACN,KAAK,EAAE;IAC9B,IAAI,CAACQ,iBAAiB,CAACR,KAAK,EAAE;IAC9B,IAAI,CAACvB,IAAI,EAAE;EACf,CAAC;EACD,OAAO0B,WAAW;AACtB,CAAC,EAAG;AACJ;AACA;AACA;AACA,SAAS+B,WAAWA,CAACjlB,IAAI,EAAE;EACvB,OAAO,IAAIkjB,WAAW,CAACljB,IAAI,CAAC;AAChC;;AAEA;AACA;AACA;AACA,IAAIklB,aAAa,GAAG,SAAAA,CAAU7hB,CAAC,EAAE;EAAE,OAAO,UAAUoG,IAAI,EAAE;IAAE,OAAOA,IAAI,CAAC/C,IAAI,CAACrD,CAAC,CAAC;EAAE,CAAC;AAAE,CAAC;;AAErF;AACA;AACA;AACA,IAAI8hB,IAAI,GAAG;EACPze,IAAI,EAAE,SAAAA,CAAUrD,CAAC,EAAE;IAAE,OAAOA,CAAC,KAAK,MAAM;EAAE,CAAC;EAC3C+hB,KAAK,EAAE,SAAAA,CAAU/hB,CAAC,EAAE;IAAE,OAAOA,CAAC;EAAE;AACpC,CAAC;;AAED;AACA;AACA;AACA,IAAIgiB,mBAAmB,GAAG,CAAC1pB,eAAe,CAACgO,MAAM,EAAEhO,eAAe,CAACqO,EAAE,EAAErO,eAAe,CAAC2pB,OAAO,EAAE3pB,eAAe,CAACoQ,OAAO,EAAEpQ,eAAe,CAAC4pB,EAAE,EAAE5pB,eAAe,CAAC6pB,EAAE,EAAEL,IAAI,CAAC;AACtK;AACA;AACA;AACA,IAAIM,sBAAsB,GAAG,SAAAA,CAAUpiB,CAAC,EAAE;EACtC,OAAOgiB,mBAAmB,CAACK,IAAI,CAACR,aAAa,CAAC7hB,CAAC,CAAC,CAAC;AACrD,CAAC;;AAED;AACA;AACA;AACA,IAAIsiB,UAAU,GAAGpqB,KAAK,CAACulB,aAAa,CAACvlB,KAAK,CAACulB,aAAa,CAAC,EAAE,EAAEvlB,KAAK,CAACwhB,MAAM,CAACsI,mBAAmB,CAAC,CAAC,EAAE,CAAC1pB,eAAe,CAAC2iB,KAAK,EAAE3iB,eAAe,CAAC6hB,OAAO,CAAC,CAAC;AAClJ;AACA;AACA;AACA,IAAIoI,aAAa,GAAG,SAAAA,CAAUviB,CAAC,EAAE;EAAE,OAAOsiB,UAAU,CAACD,IAAI,CAACR,aAAa,CAAC7hB,CAAC,CAAC,CAAC;AAAE,CAAC;;AAE9E;AACA;AACA;AACA;AACA,SAASwiB,cAAcA,CAACnnB,aAAa,EAAET,GAAG,EAAE3C,KAAK,EAAE;EAC/C,IAAIoD,aAAa,CAAConB,QAAQ,CAAC7nB,GAAG,CAAC,EAAE;IAC7BS,aAAa,CAACqnB,QAAQ,CAAC9nB,GAAG,CAAC,CAACoI,GAAG,CAAC/K,KAAK,CAAC;EAC1C,CAAC,MACI;IACDoD,aAAa,CAACsnB,QAAQ,CAAC/nB,GAAG,EAAEgnB,WAAW,CAAC3pB,KAAK,CAAC,CAAC;EACnD;AACJ;AACA,SAAS2qB,SAASA,CAACvnB,aAAa,EAAEqF,UAAU,EAAE;EAC1C,IAAI6Q,QAAQ,GAAGxQ,cAAc,CAAC1F,aAAa,EAAEqF,UAAU,CAAC;EACxD,IAAI3E,EAAE,GAAGwV,QAAQ,GACXlW,aAAa,CAACwnB,oBAAoB,CAACtR,QAAQ,EAAE,KAAK,CAAC,GACnD,CAAC,CAAC;IAAExM,EAAE,GAAGhJ,EAAE,CAACyV,aAAa;IAAEA,aAAa,GAAGzM,EAAE,KAAK,KAAK,CAAC,GAAG,CAAC,CAAC,GAAGA,EAAE;EAAEhJ,EAAE,CAAC0V,UAAU;EAAE,IAAI/F,MAAM,GAAGxT,KAAK,CAACsW,MAAM,CAACzS,EAAE,EAAE,CAAC,eAAe,EAAE,YAAY,CAAC,CAAC;EACvJ2P,MAAM,GAAGxT,KAAK,CAACgE,QAAQ,CAAChE,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAEwP,MAAM,CAAC,EAAE8F,aAAa,CAAC;EAClE,KAAK,IAAI5W,GAAG,IAAI8Q,MAAM,EAAE;IACpB,IAAIzT,KAAK,GAAGuY,4BAA4B,CAAC9E,MAAM,CAAC9Q,GAAG,CAAC,CAAC;IACrD4nB,cAAc,CAACnnB,aAAa,EAAET,GAAG,EAAE3C,KAAK,CAAC;EAC7C;AACJ;AACA,SAAS6qB,WAAWA,CAACznB,aAAa,EAAE0nB,aAAa,EAAE;EAC/C,IAAIC,cAAc,GAAG9qB,KAAK,CAACulB,aAAa,CAAC,EAAE,EAAEvlB,KAAK,CAACwhB,MAAM,CAACqJ,aAAa,CAAC,CAAC,CAACE,OAAO,EAAE;EACnFD,cAAc,CAAChqB,OAAO,CAAC,UAAU4B,GAAG,EAAE;IAClC,IAAImB,EAAE;IACN,IAAImnB,OAAO,GAAG7nB,aAAa,CAAC8nB,UAAU,CAACvoB,GAAG,CAAC;IAC3CsoB,OAAO,IAAIN,SAAS,CAACvnB,aAAa,EAAE6nB,OAAO,CAAC;IAC5C,CAACnnB,EAAE,GAAGV,aAAa,CAAC+nB,eAAe,MAAM,IAAI,IAAIrnB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC/C,OAAO,CAAC,UAAU+d,KAAK,EAAE;MAClG+L,WAAW,CAAC/L,KAAK,EAAEgM,aAAa,CAAC;IACrC,CAAC,CAAC;EACN,CAAC,CAAC;AACN;AACA,SAASM,SAASA,CAAChoB,aAAa,EAAEqF,UAAU,EAAE;EAC1C,IAAIT,KAAK,CAACC,OAAO,CAACQ,UAAU,CAAC,EAAE;IAC3B,OAAOoiB,WAAW,CAACznB,aAAa,EAAEqF,UAAU,CAAC;EACjD,CAAC,MACI,IAAI,OAAOA,UAAU,KAAK,QAAQ,EAAE;IACrC,OAAOoiB,WAAW,CAACznB,aAAa,EAAE,CAACqF,UAAU,CAAC,CAAC;EACnD,CAAC,MACI;IACDkiB,SAAS,CAACvnB,aAAa,EAAEqF,UAAU,CAAC;EACxC;AACJ;AACA,SAAS4iB,uBAAuBA,CAACjoB,aAAa,EAAEqQ,MAAM,EAAEuB,MAAM,EAAE;EAC5D,IAAIlR,EAAE,EAAEgJ,EAAE,EAAEK,EAAE;EACd,IAAIE,EAAE;EACN,IAAIie,YAAY,GAAGzrB,MAAM,CAACiB,IAAI,CAAC2S,MAAM,CAAC,CAACoQ,MAAM,CAAC,UAAUlhB,GAAG,EAAE;IAAE,OAAO,CAACS,aAAa,CAAConB,QAAQ,CAAC7nB,GAAG,CAAC;EAAE,CAAC,CAAC;EACtG,IAAI4oB,YAAY,GAAGD,YAAY,CAACpoB,MAAM;EACtC,IAAI,CAACqoB,YAAY,EACb;EACJ,KAAK,IAAI3nB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2nB,YAAY,EAAE3nB,CAAC,EAAE,EAAE;IACnC,IAAIjB,GAAG,GAAG2oB,YAAY,CAAC1nB,CAAC,CAAC;IACzB,IAAI4nB,WAAW,GAAG/X,MAAM,CAAC9Q,GAAG,CAAC;IAC7B,IAAI3C,KAAK,GAAG,IAAI;IAChB;AACR;AACA;AACA;IACQ,IAAIgI,KAAK,CAACC,OAAO,CAACujB,WAAW,CAAC,EAAE;MAC5BxrB,KAAK,GAAGwrB,WAAW,CAAC,CAAC,CAAC;IAC1B;IACA;AACR;AACA;AACA;AACA;IACQ,IAAIxrB,KAAK,KAAK,IAAI,EAAE;MAChBA,KAAK,GAAG,CAAC8M,EAAE,GAAG,CAAChJ,EAAE,GAAGkR,MAAM,CAACrS,GAAG,CAAC,MAAM,IAAI,IAAImB,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAGV,aAAa,CAACqoB,SAAS,CAAC9oB,GAAG,CAAC,MAAM,IAAI,IAAImK,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG2G,MAAM,CAAC9Q,GAAG,CAAC;IAChJ;IACA;AACR;AACA;AACA;IACQ,IAAI3C,KAAK,KAAKkG,SAAS,IAAIlG,KAAK,KAAK,IAAI,EACrC;IACJ,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAI0mB,iBAAiB,CAAC1mB,KAAK,CAAC,EAAE;MACvD;MACAA,KAAK,GAAGmmB,UAAU,CAACnmB,KAAK,CAAC;IAC7B,CAAC,MACI,IAAI,CAACsqB,aAAa,CAACtqB,KAAK,CAAC,IAAIK,eAAe,CAAC6hB,OAAO,CAAC9W,IAAI,CAACogB,WAAW,CAAC,EAAE;MACzExrB,KAAK,GAAGgkB,iBAAiB,CAACrhB,GAAG,EAAE6oB,WAAW,CAAC;IAC/C;IACApoB,aAAa,CAACsnB,QAAQ,CAAC/nB,GAAG,EAAEgnB,WAAW,CAAC3pB,KAAK,CAAC,CAAC;IAC/C,CAACmN,EAAE,GAAG,CAACE,EAAE,GAAG2H,MAAM,EAAErS,GAAG,CAAC,MAAM,IAAI,IAAIwK,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAIE,EAAE,CAAC1K,GAAG,CAAC,GAAG3C,KAAM;IAC5EoD,aAAa,CAACsoB,aAAa,CAAC/oB,GAAG,EAAE3C,KAAK,CAAC;EAC3C;AACJ;AACA,SAAS2rB,uBAAuBA,CAAChpB,GAAG,EAAE6W,UAAU,EAAE;EAC9C,IAAI,CAACA,UAAU,EACX;EACJ,IAAI6L,eAAe,GAAG7L,UAAU,CAAC7W,GAAG,CAAC,IAAI6W,UAAU,CAAC,SAAS,CAAC,IAAIA,UAAU;EAC5E,OAAO6L,eAAe,CAACV,IAAI;AAC/B;AACA,SAASiH,SAASA,CAACnY,MAAM,EAAE+F,UAAU,EAAEpW,aAAa,EAAE;EAClD,IAAIU,EAAE,EAAEgJ,EAAE;EACV,IAAIkI,MAAM,GAAG,CAAC,CAAC;EACf,KAAK,IAAIrS,GAAG,IAAI8Q,MAAM,EAAE;IACpBuB,MAAM,CAACrS,GAAG,CAAC,GACP,CAACmB,EAAE,GAAG6nB,uBAAuB,CAAChpB,GAAG,EAAE6W,UAAU,CAAC,MAAM,IAAI,IAAI1V,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,CAACgJ,EAAE,GAAG1J,aAAa,CAACqnB,QAAQ,CAAC9nB,GAAG,CAAC,MAAM,IAAI,IAAImK,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC3L,GAAG,EAAE;EACzK;EACA,OAAO6T,MAAM;AACjB;;AAEA;AACA;AACA;AACA,SAAS6W,oBAAoBA,CAACzoB,aAAa,EAAEqF,UAAU,EAAE4J,OAAO,EAAE;EAC9D,IAAIA,OAAO,KAAK,KAAK,CAAC,EAAE;IAAEA,OAAO,GAAG,CAAC,CAAC;EAAE;EACxCjP,aAAa,CAAC0oB,oBAAoB,EAAE;EACpC,IAAI7pB,SAAS;EACb,IAAI+F,KAAK,CAACC,OAAO,CAACQ,UAAU,CAAC,EAAE;IAC3B,IAAIsjB,UAAU,GAAGtjB,UAAU,CAACyc,GAAG,CAAC,UAAU+F,OAAO,EAAE;MAC/C,OAAOe,cAAc,CAAC5oB,aAAa,EAAE6nB,OAAO,EAAE5Y,OAAO,CAAC;IAC1D,CAAC,CAAC;IACFpQ,SAAS,GAAGmnB,OAAO,CAAC6C,GAAG,CAACF,UAAU,CAAC;EACvC,CAAC,MACI,IAAI,OAAOtjB,UAAU,KAAK,QAAQ,EAAE;IACrCxG,SAAS,GAAG+pB,cAAc,CAAC5oB,aAAa,EAAEqF,UAAU,EAAE4J,OAAO,CAAC;EAClE,CAAC,MACI;IACD,IAAI6Z,kBAAkB,GAAG,OAAOzjB,UAAU,KAAK,UAAU,GACnDK,cAAc,CAAC1F,aAAa,EAAEqF,UAAU,EAAE4J,OAAO,CAAC3J,MAAM,CAAC,GACzDD,UAAU;IAChBxG,SAAS,GAAGkqB,aAAa,CAAC/oB,aAAa,EAAE8oB,kBAAkB,EAAE7Z,OAAO,CAAC;EACzE;EACA,OAAOpQ,SAAS,CAACsnB,IAAI,CAAC,YAAY;IAC9B,OAAOnmB,aAAa,CAACgpB,uBAAuB,CAAC3jB,UAAU,CAAC;EAC5D,CAAC,CAAC;AACN;AACA,SAASujB,cAAcA,CAAC5oB,aAAa,EAAE6nB,OAAO,EAAE5Y,OAAO,EAAE;EACrD,IAAIvO,EAAE;EACN,IAAIuO,OAAO,KAAK,KAAK,CAAC,EAAE;IAAEA,OAAO,GAAG,CAAC,CAAC;EAAE;EACxC,IAAIiH,QAAQ,GAAGxQ,cAAc,CAAC1F,aAAa,EAAE6nB,OAAO,EAAE5Y,OAAO,CAAC3J,MAAM,CAAC;EACrE,IAAIoE,EAAE,GAAG,CAACwM,QAAQ,IAAI,CAAC,CAAC,EAAEE,UAAU;IAAEA,UAAU,GAAG1M,EAAE,KAAK,KAAK,CAAC,GAAG1J,aAAa,CAAC6f,oBAAoB,EAAE,IAAI,CAAC,CAAC,GAAGnW,EAAE;EAClH,IAAIuF,OAAO,CAACga,kBAAkB,EAAE;IAC5B7S,UAAU,GAAGnH,OAAO,CAACga,kBAAkB;EAC3C;EACA;AACJ;AACA;AACA;EACI,IAAI3G,YAAY,GAAGpM,QAAQ,GACrB,YAAY;IAAE,OAAO6S,aAAa,CAAC/oB,aAAa,EAAEkW,QAAQ,EAAEjH,OAAO,CAAC;EAAE,CAAC,GACvE,YAAY;IAAE,OAAO+W,OAAO,CAACC,OAAO,EAAE;EAAE,CAAC;EAC/C;AACJ;AACA;AACA;EACI,IAAIiD,kBAAkB,GAAG,CAAC,CAACxoB,EAAE,GAAGV,aAAa,CAAC+nB,eAAe,MAAM,IAAI,IAAIrnB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC2L,IAAI,IACrG,UAAU8c,YAAY,EAAE;IACtB,IAAIA,YAAY,KAAK,KAAK,CAAC,EAAE;MAAEA,YAAY,GAAG,CAAC;IAAE;IACjD,IAAIzoB,EAAE,GAAG0V,UAAU,CAAC6K,aAAa;MAAEA,aAAa,GAAGvgB,EAAE,KAAK,KAAK,CAAC,GAAG,CAAC,GAAGA,EAAE;MAAEwgB,eAAe,GAAG9K,UAAU,CAAC8K,eAAe;MAAEC,gBAAgB,GAAG/K,UAAU,CAAC+K,gBAAgB;IACvK,OAAOiI,eAAe,CAACppB,aAAa,EAAE6nB,OAAO,EAAE5G,aAAa,GAAGkI,YAAY,EAAEjI,eAAe,EAAEC,gBAAgB,EAAElS,OAAO,CAAC;EAC5H,CAAC,GACC,YAAY;IAAE,OAAO+W,OAAO,CAACC,OAAO,EAAE;EAAE,CAAC;EAC/C;AACJ;AACA;AACA;EACI,IAAIlF,IAAI,GAAG3K,UAAU,CAAC2K,IAAI;EAC1B,IAAIA,IAAI,EAAE;IACN,IAAIhX,EAAE,GAAGlN,KAAK,CAACwhB,MAAM,CAAC0C,IAAI,KAAK,gBAAgB,GACzC,CAACuB,YAAY,EAAE4G,kBAAkB,CAAC,GAClC,CAACA,kBAAkB,EAAE5G,YAAY,CAAC,EAAE,CAAC,CAAC;MAAE+G,KAAK,GAAGtf,EAAE,CAAC,CAAC,CAAC;MAAEuf,IAAI,GAAGvf,EAAE,CAAC,CAAC,CAAC;IACzE,OAAOsf,KAAK,EAAE,CAAClD,IAAI,CAACmD,IAAI,CAAC;EAC7B,CAAC,MACI;IACD,OAAOtD,OAAO,CAAC6C,GAAG,CAAC,CAACvG,YAAY,EAAE,EAAE4G,kBAAkB,CAACja,OAAO,CAAC+R,KAAK,CAAC,CAAC,CAAC;EAC3E;AACJ;AACA;AACA;AACA;AACA,SAAS+H,aAAaA,CAAC/oB,aAAa,EAAEqF,UAAU,EAAE3E,EAAE,EAAE;EAClD,IAAIgJ,EAAE;EACN,IAAIK,EAAE,GAAGrJ,EAAE,KAAK,KAAK,CAAC,GAAG,CAAC,CAAC,GAAGA,EAAE;IAAEuJ,EAAE,GAAGF,EAAE,CAACiX,KAAK;IAAEA,KAAK,GAAG/W,EAAE,KAAK,KAAK,CAAC,GAAG,CAAC,GAAGA,EAAE;IAAEgf,kBAAkB,GAAGlf,EAAE,CAACkf,kBAAkB;IAAEle,IAAI,GAAGhB,EAAE,CAACgB,IAAI;EAC3I,IAAIwe,EAAE,GAAGvpB,aAAa,CAACwnB,oBAAoB,CAACniB,UAAU,CAAC;IAAEmkB,EAAE,GAAGD,EAAE,CAACnT,UAAU;IAAEA,UAAU,GAAGoT,EAAE,KAAK,KAAK,CAAC,GAAGxpB,aAAa,CAAC6f,oBAAoB,EAAE,GAAG2J,EAAE;IAAErT,aAAa,GAAGoT,EAAE,CAACpT,aAAa;IAAE9F,MAAM,GAAGxT,KAAK,CAACsW,MAAM,CAACoW,EAAE,EAAE,CAAC,YAAY,EAAE,eAAe,CAAC,CAAC;EACjP,IAAIN,kBAAkB,EAClB7S,UAAU,GAAG6S,kBAAkB;EACnC,IAAIN,UAAU,GAAG,EAAE;EACnB,IAAIc,kBAAkB,GAAG1e,IAAI,KAAK,CAACrB,EAAE,GAAG1J,aAAa,CAAC6D,cAAc,MAAM,IAAI,IAAI6F,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACggB,QAAQ,EAAE,CAAC3e,IAAI,CAAC,CAAC;EAC/H,KAAK,IAAIxL,GAAG,IAAI8Q,MAAM,EAAE;IACpB,IAAIzT,KAAK,GAAGoD,aAAa,CAACqnB,QAAQ,CAAC9nB,GAAG,CAAC;IACvC,IAAIoqB,WAAW,GAAGtZ,MAAM,CAAC9Q,GAAG,CAAC;IAC7B,IAAI,CAAC3C,KAAK,IACN+sB,WAAW,KAAK7mB,SAAS,IACxB2mB,kBAAkB,IACfG,oBAAoB,CAACH,kBAAkB,EAAElqB,GAAG,CAAE,EAAE;MACpD;IACJ;IACA,IAAIV,SAAS,GAAGokB,cAAc,CAAC1jB,GAAG,EAAE3C,KAAK,EAAE+sB,WAAW,EAAE9sB,KAAK,CAACgE,QAAQ,CAAC;MAAEmgB,KAAK,EAAEA;IAAM,CAAC,EAAE5K,UAAU,CAAC,CAAC;IACrGuS,UAAU,CAAChoB,IAAI,CAAC9B,SAAS,CAAC;EAC9B;EACA,OAAOmnB,OAAO,CAAC6C,GAAG,CAACF,UAAU,CAAC,CAACxC,IAAI,CAAC,YAAY;IAC5ChQ,aAAa,IAAIoR,SAAS,CAACvnB,aAAa,EAAEmW,aAAa,CAAC;EAC5D,CAAC,CAAC;AACN;AACA,SAASiT,eAAeA,CAACppB,aAAa,EAAE6nB,OAAO,EAAE5G,aAAa,EAAEC,eAAe,EAAEC,gBAAgB,EAAElS,OAAO,EAAE;EACxG,IAAIgS,aAAa,KAAK,KAAK,CAAC,EAAE;IAAEA,aAAa,GAAG,CAAC;EAAE;EACnD,IAAIC,eAAe,KAAK,KAAK,CAAC,EAAE;IAAEA,eAAe,GAAG,CAAC;EAAE;EACvD,IAAIC,gBAAgB,KAAK,KAAK,CAAC,EAAE;IAAEA,gBAAgB,GAAG,CAAC;EAAE;EACzD,IAAIwH,UAAU,GAAG,EAAE;EACnB,IAAIkB,kBAAkB,GAAG,CAAC7pB,aAAa,CAAC+nB,eAAe,CAAC1b,IAAI,GAAG,CAAC,IAAI6U,eAAe;EACnF,IAAI4I,uBAAuB,GAAG3I,gBAAgB,KAAK,CAAC,GAC9C,UAAU3gB,CAAC,EAAE;IACX,IAAIA,CAAC,KAAK,KAAK,CAAC,EAAE;MAAEA,CAAC,GAAG,CAAC;IAAE;IAC3B,OAAOA,CAAC,GAAG0gB,eAAe;EAC9B,CAAC,GACC,UAAU1gB,CAAC,EAAE;IACX,IAAIA,CAAC,KAAK,KAAK,CAAC,EAAE;MAAEA,CAAC,GAAG,CAAC;IAAE;IAC3B,OAAOqpB,kBAAkB,GAAGrpB,CAAC,GAAG0gB,eAAe;EACnD,CAAC;EACLtc,KAAK,CAAC2c,IAAI,CAACvhB,aAAa,CAAC+nB,eAAe,CAAC,CACpC3d,IAAI,CAAC2f,eAAe,CAAC,CACrBpsB,OAAO,CAAC,UAAU+d,KAAK,EAAElb,CAAC,EAAE;IAC7BmoB,UAAU,CAAChoB,IAAI,CAACioB,cAAc,CAAClN,KAAK,EAAEmM,OAAO,EAAEhrB,KAAK,CAACgE,QAAQ,CAAChE,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAEoO,OAAO,CAAC,EAAE;MAAE+R,KAAK,EAAEC,aAAa,GAAG6I,uBAAuB,CAACtpB,CAAC;IAAE,CAAC,CAAC,CAAC,CAAC2lB,IAAI,CAAC,YAAY;MAAE,OAAOzK,KAAK,CAACsN,uBAAuB,CAACnB,OAAO,CAAC;IAAE,CAAC,CAAC,CAAC;EAC5N,CAAC,CAAC;EACF,OAAO7B,OAAO,CAAC6C,GAAG,CAACF,UAAU,CAAC;AAClC;AACA,SAASzC,aAAaA,CAAClmB,aAAa,EAAE;EAClCA,aAAa,CAACgF,YAAY,CAAC,UAAUpI,KAAK,EAAE;IAAE,OAAOA,KAAK,CAACkmB,IAAI,EAAE;EAAE,CAAC,CAAC;AACzE;AACA,SAASiH,eAAeA,CAACrhB,CAAC,EAAEC,CAAC,EAAE;EAC3B,OAAOD,CAAC,CAACshB,gBAAgB,CAACrhB,CAAC,CAAC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASihB,oBAAoBA,CAAClpB,EAAE,EAAEnB,GAAG,EAAE;EACnC,IAAI0qB,aAAa,GAAGvpB,EAAE,CAACupB,aAAa;IAAEC,cAAc,GAAGxpB,EAAE,CAACwpB,cAAc;EACxE,IAAIC,WAAW,GAAGF,aAAa,CAAC/lB,cAAc,CAAC3E,GAAG,CAAC,IAAI2qB,cAAc,CAAC3qB,GAAG,CAAC,KAAK,IAAI;EACnF2qB,cAAc,CAAC3qB,GAAG,CAAC,GAAG,KAAK;EAC3B,OAAO4qB,WAAW;AACtB;AAEA,IAAIC,oBAAoB,GAAG,CACvBtT,aAAa,CAACuT,OAAO,EACrBvT,aAAa,CAACuE,KAAK,EACnBvE,aAAa,CAACwF,GAAG,EACjBxF,aAAa,CAACwT,IAAI,EAClBxT,aAAa,CAACU,KAAK,EACnBV,aAAa,CAACyT,IAAI,CACrB;AACD,IAAIC,oBAAoB,GAAG3tB,KAAK,CAACulB,aAAa,CAAC,EAAE,EAAEvlB,KAAK,CAACwhB,MAAM,CAAC+L,oBAAoB,CAAC,CAAC,CAACxC,OAAO,EAAE;AAChG,IAAI6C,iBAAiB,GAAGL,oBAAoB,CAACtqB,MAAM;AACnD,SAAS4qB,WAAWA,CAAC1qB,aAAa,EAAE;EAChC,OAAO,UAAU2oB,UAAU,EAAE;IACzB,OAAO3C,OAAO,CAAC6C,GAAG,CAACF,UAAU,CAAC7G,GAAG,CAAC,UAAUphB,EAAE,EAAE;MAC5C,IAAI7B,SAAS,GAAG6B,EAAE,CAAC7B,SAAS;QAAEoQ,OAAO,GAAGvO,EAAE,CAACuO,OAAO;MAClD,OAAOwZ,oBAAoB,CAACzoB,aAAa,EAAEnB,SAAS,EAAEoQ,OAAO,CAAC;IAClE,CAAC,CAAC,CAAC;EACP,CAAC;AACL;AACA,SAAS0b,oBAAoBA,CAAC3qB,aAAa,EAAE;EACzC,IAAI6F,OAAO,GAAG6kB,WAAW,CAAC1qB,aAAa,CAAC;EACxC,IAAI6O,KAAK,GAAG+b,WAAW,EAAE;EACzB,IAAIC,eAAe,GAAG,CAAC,CAAC;EACxB,IAAIC,eAAe,GAAG,IAAI;EAC1B;AACJ;AACA;AACA;EACI,IAAIC,uBAAuB,GAAG,SAAAA,CAAUC,GAAG,EAAE3lB,UAAU,EAAE;IACrD,IAAI6Q,QAAQ,GAAGxQ,cAAc,CAAC1F,aAAa,EAAEqF,UAAU,CAAC;IACxD,IAAI6Q,QAAQ,EAAE;MACVA,QAAQ,CAACE,UAAU;MAAE,IAAID,aAAa,GAAGD,QAAQ,CAACC,aAAa;QAAE9F,MAAM,GAAGxT,KAAK,CAACsW,MAAM,CAAC+C,QAAQ,EAAE,CAAC,YAAY,EAAE,eAAe,CAAC,CAAC;MACjI8U,GAAG,GAAGnuB,KAAK,CAACgE,QAAQ,CAAChE,KAAK,CAACgE,QAAQ,CAAChE,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAEmqB,GAAG,CAAC,EAAE3a,MAAM,CAAC,EAAE8F,aAAa,CAAC;IACxF;IACA,OAAO6U,GAAG;EACd,CAAC;EACD,SAASC,UAAUA,CAAC1rB,GAAG,EAAE;IACrB,OAAOsrB,eAAe,CAACtrB,GAAG,CAAC,KAAKuD,SAAS;EAC7C;EACA;AACJ;AACA;AACA;EACI,SAASooB,kBAAkBA,CAACC,YAAY,EAAE;IACtCtlB,OAAO,GAAGslB,YAAY,CAACnrB,aAAa,CAAC;EACzC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAAS8D,cAAcA,CAACmL,OAAO,EAAEmc,iBAAiB,EAAE;IAChD,IAAI1qB,EAAE;IACN,IAAIlC,KAAK,GAAGwB,aAAa,CAAC2F,QAAQ,EAAE;IACpC,IAAIhE,OAAO,GAAG3B,aAAa,CAACqrB,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACzD;AACR;AACA;AACA;IACQ,IAAI1C,UAAU,GAAG,EAAE;IACnB;AACR;AACA;AACA;IACQ,IAAI2C,WAAW,GAAG,IAAIziB,GAAG,EAAE;IAC3B;AACR;AACA;AACA;AACA;IACQ,IAAI0iB,eAAe,GAAG,CAAC,CAAC;IACxB;AACR;AACA;AACA;IACQ,IAAIC,mBAAmB,GAAGC,QAAQ;IAClC,IAAIC,OAAO,GAAG,SAAAA,CAAUlrB,CAAC,EAAE;MACvB,IAAIuK,IAAI,GAAGyf,oBAAoB,CAAChqB,CAAC,CAAC;MAClC,IAAImrB,SAAS,GAAG9c,KAAK,CAAC9D,IAAI,CAAC;MAC3B,IAAIrE,IAAI,GAAG,CAAChG,EAAE,GAAGlC,KAAK,CAACuM,IAAI,CAAC,MAAM,IAAI,IAAIrK,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAGiB,OAAO,CAACoJ,IAAI,CAAC;MAC5E,IAAI6gB,aAAa,GAAG9mB,cAAc,CAAC4B,IAAI,CAAC;MACxC;AACZ;AACA;AACA;MACY,IAAImlB,WAAW,GAAG9gB,IAAI,KAAKqgB,iBAAiB,GAAGO,SAAS,CAACzQ,QAAQ,GAAG,IAAI;MACxE,IAAI2Q,WAAW,KAAK,KAAK,EACrBL,mBAAmB,GAAGhrB,CAAC;MAC3B;AACZ;AACA;AACA;AACA;AACA;MACY,IAAIsrB,WAAW,GAAGplB,IAAI,KAAK/E,OAAO,CAACoJ,IAAI,CAAC,IAAIrE,IAAI,KAAKlI,KAAK,CAACuM,IAAI,CAAC,IAAI6gB,aAAa;MACjF;AACZ;AACA;MACY,IAAIE,WAAW,IACXhB,eAAe,IACf9qB,aAAa,CAAC+rB,sBAAsB,EAAE;QACtCD,WAAW,GAAG,KAAK;MACvB;MACA;AACZ;AACA;AACA;MACYH,SAAS,CAAC1B,aAAa,GAAGptB,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAE0qB,eAAe,CAAC;MAC7D;MACA;MACA;MACC,CAACI,SAAS,CAACzQ,QAAQ,IAAI2Q,WAAW,KAAK,IAAI;MACxC;MACC,CAACnlB,IAAI,IAAI,CAACilB,SAAS,CAACK,QAAS;MAC9B;MACAlX,mBAAmB,CAACpO,IAAI,CAAC,IACzB,OAAOA,IAAI,KAAK,SAAS,EAAE;QAC3B,OAAO,UAAU;MACrB;MACA;AACZ;AACA;AACA;AACA;MACY,IAAIulB,iBAAiB,GAAGC,mBAAmB,CAACP,SAAS,CAACK,QAAQ,EAAEtlB,IAAI,CAAC;MACjE;MACCqE,IAAI,KAAKqgB,iBAAiB,IACvBO,SAAS,CAACzQ,QAAQ,IAClB,CAAC4Q,WAAW,IACZF,aAAc;MAClB;MACCprB,CAAC,GAAGgrB,mBAAmB,IAAII,aAAc;MAC9C;AACZ;AACA;AACA;MACY,IAAIO,cAAc,GAAGvnB,KAAK,CAACC,OAAO,CAAC6B,IAAI,CAAC,GAAGA,IAAI,GAAG,CAACA,IAAI,CAAC;MACxD;AACZ;AACA;AACA;MACY,IAAI0lB,cAAc,GAAGD,cAAc,CAACE,MAAM,CAACtB,uBAAuB,EAAE,CAAC,CAAC,CAAC;MACvE,IAAIc,WAAW,KAAK,KAAK,EACrBO,cAAc,GAAG,CAAC,CAAC;MACvB;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACY,IAAI1iB,EAAE,GAAGiiB,SAAS,CAACW,kBAAkB;QAAEA,kBAAkB,GAAG5iB,EAAE,KAAK,KAAK,CAAC,GAAG,CAAC,CAAC,GAAGA,EAAE;MACnF,IAAI6iB,OAAO,GAAG1vB,KAAK,CAACgE,QAAQ,CAAChE,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAEyrB,kBAAkB,CAAC,EAAEF,cAAc,CAAC;MACpF,IAAII,aAAa,GAAG,SAAAA,CAAUjtB,GAAG,EAAE;QAC/B0sB,iBAAiB,GAAG,IAAI;QACxBX,WAAW,CAACmB,MAAM,CAACltB,GAAG,CAAC;QACvBosB,SAAS,CAACzB,cAAc,CAAC3qB,GAAG,CAAC,GAAG,IAAI;MACxC,CAAC;MACD,KAAK,IAAIA,GAAG,IAAIgtB,OAAO,EAAE;QACrB,IAAIvP,IAAI,GAAGoP,cAAc,CAAC7sB,GAAG,CAAC;QAC9B,IAAI0d,IAAI,GAAGqP,kBAAkB,CAAC/sB,GAAG,CAAC;QAClC;QACA,IAAIgsB,eAAe,CAACrnB,cAAc,CAAC3E,GAAG,CAAC,EACnC;QACJ;AAChB;AACA;QACgB,IAAIyd,IAAI,KAAKC,IAAI,EAAE;UACf;AACpB;AACA;AACA;UACoB,IAAIlI,iBAAiB,CAACiI,IAAI,CAAC,IAAIjI,iBAAiB,CAACkI,IAAI,CAAC,EAAE;YACpD,IAAI,CAACF,cAAc,CAACC,IAAI,EAAEC,IAAI,CAAC,EAAE;cAC7BuP,aAAa,CAACjtB,GAAG,CAAC;YACtB,CAAC,MACI;cACD;AAC5B;AACA;AACA;cAC4BosB,SAAS,CAAC1B,aAAa,CAAC1qB,GAAG,CAAC,GAAG,IAAI;YACvC;UACJ,CAAC,MACI,IAAIyd,IAAI,KAAKla,SAAS,EAAE;YACzB;YACA0pB,aAAa,CAACjtB,GAAG,CAAC;UACtB,CAAC,MACI;YACD;YACA+rB,WAAW,CAACvH,GAAG,CAACxkB,GAAG,CAAC;UACxB;QACJ,CAAC,MACI,IAAIyd,IAAI,KAAKla,SAAS,IAAIwoB,WAAW,CAAC5jB,GAAG,CAACnI,GAAG,CAAC,EAAE;UACjD;AACpB;AACA;AACA;UACoBitB,aAAa,CAACjtB,GAAG,CAAC;QACtB,CAAC,MACI;UACD;AACpB;AACA;AACA;UACoBosB,SAAS,CAAC1B,aAAa,CAAC1qB,GAAG,CAAC,GAAG,IAAI;QACvC;MACJ;MACA;AACZ;AACA;AACA;MACYosB,SAAS,CAACK,QAAQ,GAAGtlB,IAAI;MACzBilB,SAAS,CAACW,kBAAkB,GAAGF,cAAc;MAC7C;AACZ;AACA;MACY,IAAIT,SAAS,CAACzQ,QAAQ,EAAE;QACpBqQ,eAAe,GAAG1uB,KAAK,CAACgE,QAAQ,CAAChE,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAE0qB,eAAe,CAAC,EAAEa,cAAc,CAAC;MACzF;MACA,IAAItB,eAAe,IAAI9qB,aAAa,CAACwD,qBAAqB,EAAE;QACxDyoB,iBAAiB,GAAG,KAAK;MAC7B;MACA;AACZ;AACA;AACA;AACA;MACY,IAAIA,iBAAiB,IAAI,CAACH,WAAW,EAAE;QACnCnD,UAAU,CAAChoB,IAAI,CAAC+rB,KAAK,CAAC/D,UAAU,EAAE9rB,KAAK,CAACulB,aAAa,CAAC,EAAE,EAAEvlB,KAAK,CAACwhB,MAAM,CAAC8N,cAAc,CAACrK,GAAG,CAAC,UAAUjjB,SAAS,EAAE;UAAE,OAAQ;YACrHA,SAAS,EAAEA,SAAS;YACpBoQ,OAAO,EAAEpS,KAAK,CAACgE,QAAQ,CAAC;cAAEkK,IAAI,EAAEA;YAAK,CAAC,EAAEkE,OAAO;UACnD,CAAC;QAAG,CAAC,CAAC,CAAC,CAAC,CAAC;MACb;IACJ,CAAC;IACD;AACR;AACA;AACA;AACA;AACA;IACQ,KAAK,IAAIzO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiqB,iBAAiB,EAAEjqB,CAAC,EAAE,EAAE;MACxCkrB,OAAO,CAAClrB,CAAC,CAAC;IACd;IACAqqB,eAAe,GAAGhuB,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAE0qB,eAAe,CAAC;IACrD;AACR;AACA;AACA;AACA;IACQ,IAAID,WAAW,CAACjf,IAAI,EAAE;MAClB,IAAIsgB,mBAAmB,GAAG,CAAC,CAAC;MAC5BrB,WAAW,CAAC3tB,OAAO,CAAC,UAAU4B,GAAG,EAAE;QAC/B,IAAIqtB,cAAc,GAAG5sB,aAAa,CAAC6sB,aAAa,CAACttB,GAAG,CAAC;QACrD,IAAIqtB,cAAc,KAAK9pB,SAAS,EAAE;UAC9B6pB,mBAAmB,CAACptB,GAAG,CAAC,GAAGqtB,cAAc;QAC7C;MACJ,CAAC,CAAC;MACFjE,UAAU,CAAChoB,IAAI,CAAC;QAAE9B,SAAS,EAAE8tB;MAAoB,CAAC,CAAC;IACvD;IACA,IAAIG,aAAa,GAAG1mB,OAAO,CAACuiB,UAAU,CAAC7oB,MAAM,CAAC;IAC9C,IAAIgrB,eAAe,IACftsB,KAAK,CAACiF,OAAO,KAAK,KAAK,IACvB,CAACzD,aAAa,CAAC+rB,sBAAsB,EAAE;MACvCe,aAAa,GAAG,KAAK;IACzB;IACAhC,eAAe,GAAG,KAAK;IACvB,OAAOgC,aAAa,GAAGjnB,OAAO,CAAC8iB,UAAU,CAAC,GAAG3C,OAAO,CAACC,OAAO,EAAE;EAClE;EACA;AACJ;AACA;EACI,SAAS1O,SAASA,CAACxM,IAAI,EAAEmQ,QAAQ,EAAEjM,OAAO,EAAE;IACxC,IAAIvO,EAAE;IACN;IACA,IAAImO,KAAK,CAAC9D,IAAI,CAAC,CAACmQ,QAAQ,KAAKA,QAAQ,EACjC,OAAO8K,OAAO,CAACC,OAAO,EAAE;IAC5B;IACA,CAACvlB,EAAE,GAAGV,aAAa,CAAC+nB,eAAe,MAAM,IAAI,IAAIrnB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC/C,OAAO,CAAC,UAAU+d,KAAK,EAAE;MAAE,IAAIhb,EAAE;MAAE,OAAO,CAACA,EAAE,GAAGgb,KAAK,CAAC7X,cAAc,MAAM,IAAI,IAAInD,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC6W,SAAS,CAACxM,IAAI,EAAEmQ,QAAQ,CAAC;IAAE,CAAC,CAAC;IACxNrM,KAAK,CAAC9D,IAAI,CAAC,CAACmQ,QAAQ,GAAGA,QAAQ;IAC/B,OAAOpX,cAAc,CAACmL,OAAO,EAAElE,IAAI,CAAC;EACxC;EACA,OAAO;IACHkgB,UAAU,EAAEA,UAAU;IACtBnnB,cAAc,EAAEA,cAAc;IAC9ByT,SAAS,EAAEA,SAAS;IACpB2T,kBAAkB,EAAEA,kBAAkB;IACtCxB,QAAQ,EAAE,SAAAA,CAAA,EAAY;MAAE,OAAO7a,KAAK;IAAE;EAC1C,CAAC;AACL;AACA,SAASqd,mBAAmBA,CAACjP,IAAI,EAAED,IAAI,EAAE;EACrC,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;IAC1B,OAAOA,IAAI,KAAKC,IAAI;EACxB,CAAC,MACI,IAAIvY,eAAe,CAACsY,IAAI,CAAC,EAAE;IAC5B,OAAO,CAACD,cAAc,CAACC,IAAI,EAAEC,IAAI,CAAC;EACtC;EACA,OAAO,KAAK;AAChB;AACA,SAAS8P,eAAeA,CAAC7R,QAAQ,EAAE;EAC/B,IAAIA,QAAQ,KAAK,KAAK,CAAC,EAAE;IAAEA,QAAQ,GAAG,KAAK;EAAE;EAC7C,OAAO;IACHA,QAAQ,EAAEA,QAAQ;IAClB+O,aAAa,EAAE,CAAC,CAAC;IACjBC,cAAc,EAAE,CAAC,CAAC;IAClBoC,kBAAkB,EAAE,CAAC;EACzB,CAAC;AACL;AACA,SAAS1B,WAAWA,CAAA,EAAG;EACnB,IAAIlqB,EAAE;EACN,OAAOA,EAAE,GAAG,CAAC,CAAC,EACVA,EAAE,CAACoW,aAAa,CAACuT,OAAO,CAAC,GAAG0C,eAAe,CAAC,IAAI,CAAC,EACjDrsB,EAAE,CAACoW,aAAa,CAACuE,KAAK,CAAC,GAAG0R,eAAe,EAAE,EAC3CrsB,EAAE,CAACoW,aAAa,CAACwF,GAAG,CAAC,GAAGyQ,eAAe,EAAE,EACzCrsB,EAAE,CAACoW,aAAa,CAACwT,IAAI,CAAC,GAAGyC,eAAe,EAAE,EAC1CrsB,EAAE,CAACoW,aAAa,CAACU,KAAK,CAAC,GAAGuV,eAAe,EAAE,EAC3CrsB,EAAE,CAACoW,aAAa,CAACyT,IAAI,CAAC,GAAGwC,eAAe,EAAE,EAC1CrsB,EAAE;AACV;AAEA,IAAIioB,UAAU,GAAG;EACb9pB,SAAS,EAAE+d,uBAAuB,CAAC,UAAUlc,EAAE,EAAE;IAC7C,IAAIV,aAAa,GAAGU,EAAE,CAACV,aAAa;MAAE6F,OAAO,GAAGnF,EAAE,CAACmF,OAAO;IAC1D;AACR;AACA;AACA;AACA;IACQ7F,aAAa,CAAC6D,cAAc,KAAK7D,aAAa,CAAC6D,cAAc,GAAG8mB,oBAAoB,CAAC3qB,aAAa,CAAC,CAAC;IACpG;AACR;AACA;IACQ,IAAI8U,mBAAmB,CAACjP,OAAO,CAAC,EAAE;MAC9B9I,KAAK,CAACkF,SAAS,CAAC,YAAY;QAAE,OAAO4D,OAAO,CAACmnB,SAAS,CAAChtB,aAAa,CAAC;MAAE,CAAC,EAAE,CAAC6F,OAAO,CAAC,CAAC;IACxF;EACJ,CAAC,CAAC;EACF/G,IAAI,EAAE8d,uBAAuB,CAAC,UAAUpe,KAAK,EAAE;IAC3C,IAAI8G,MAAM,GAAG9G,KAAK,CAAC8G,MAAM;MAAEtF,aAAa,GAAGxB,KAAK,CAACwB,aAAa;IAC9D,IAAIU,EAAE,GAAG7D,KAAK,CAACwhB,MAAM,CAAC3c,WAAW,EAAE,EAAE,CAAC,CAAC;MAAEE,SAAS,GAAGlB,EAAE,CAAC,CAAC,CAAC;MAAEmB,cAAc,GAAGnB,EAAE,CAAC,CAAC,CAAC;IAClF,IAAI0C,eAAe,GAAGrG,KAAK,CAACoD,UAAU,CAACiB,eAAe,CAAC;IACvDrE,KAAK,CAACkF,SAAS,CAAC,YAAY;MACxB,IAAIvB,EAAE,EAAEgJ,EAAE;MACV,IAAI7K,SAAS,GAAG,CAAC6B,EAAE,GAAGV,aAAa,CAAC6D,cAAc,MAAM,IAAI,IAAInD,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC6W,SAAS,CAACT,aAAa,CAACyT,IAAI,EAAE,CAAC3oB,SAAS,EAAE;QAAE0D,MAAM,EAAE,CAACoE,EAAE,GAAGtG,eAAe,KAAK,IAAI,IAAIA,eAAe,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,eAAe,CAACkC,MAAM,MAAM,IAAI,IAAIoE,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAGpE;MAAO,CAAC,CAAC;MAC1R,CAAC1D,SAAS,KAAK/C,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,SAAS,CAACsnB,IAAI,CAACtkB,cAAc,CAAC,CAAC;IACxG,CAAC,EAAE,CAACD,SAAS,CAAC,CAAC;EACnB,CAAC;AACL,CAAC;;AAED;AACA;AACA;AACA,IAAIqrB,UAAU,GAAG,aAAe,YAAY;EACxC,SAASA,UAAUA,CAACtV,KAAK,EAAEuV,QAAQ,EAAExsB,EAAE,EAAE;IACrC,IAAIsjB,KAAK,GAAG,IAAI;IAChB,IAAIta,EAAE,GAAGhJ,EAAE,KAAK,KAAK,CAAC,GAAG,CAAC,CAAC,GAAGA,EAAE;MAAEK,kBAAkB,GAAG2I,EAAE,CAAC3I,kBAAkB;IAC5E;AACR;AACA;IACQ,IAAI,CAACosB,UAAU,GAAG,IAAI;IACtB;AACR;AACA;IACQ,IAAI,CAACC,aAAa,GAAG,IAAI;IACzB;AACR;AACA;IACQ,IAAI,CAACC,iBAAiB,GAAG,IAAI;IAC7B;AACR;AACA;IACQ,IAAI,CAACH,QAAQ,GAAG,CAAC,CAAC;IAClB,IAAI,CAACI,WAAW,GAAG,YAAY;MAC3B,IAAI,EAAEtJ,KAAK,CAACoJ,aAAa,IAAIpJ,KAAK,CAACqJ,iBAAiB,CAAC,EACjD;MACJ,IAAIjS,IAAI,GAAGmS,UAAU,CAACvJ,KAAK,CAACqJ,iBAAiB,EAAErJ,KAAK,CAACwJ,OAAO,CAAC;MAC7D,IAAIC,YAAY,GAAGzJ,KAAK,CAACmJ,UAAU,KAAK,IAAI;MAC5C;MACA;MACA;MACA,IAAIO,uBAAuB,GAAGxwB,SAAS,CAAC8Q,QAAQ,CAACoN,IAAI,CAACvJ,MAAM,EAAE;QAAExI,CAAC,EAAE,CAAC;QAAEC,CAAC,EAAE;MAAE,CAAC,CAAC,IAAI,CAAC;MAClF,IAAI,CAACmkB,YAAY,IAAI,CAACC,uBAAuB,EACzC;MACJ,IAAI7U,KAAK,GAAGuC,IAAI,CAACvC,KAAK;MACtB,IAAIsM,SAAS,GAAGhoB,IAAI,CAAC8nB,YAAY,EAAE,CAACE,SAAS;MAC7CnB,KAAK,CAACwJ,OAAO,CAAC7sB,IAAI,CAAC9D,KAAK,CAACgE,QAAQ,CAAChE,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAEgY,KAAK,CAAC,EAAE;QAAEsM,SAAS,EAAEA;MAAU,CAAC,CAAC,CAAC;MACvF,IAAIzkB,EAAE,GAAGsjB,KAAK,CAACkJ,QAAQ;QAAES,OAAO,GAAGjtB,EAAE,CAACitB,OAAO;QAAEC,MAAM,GAAGltB,EAAE,CAACktB,MAAM;MACjE,IAAI,CAACH,YAAY,EAAE;QACfE,OAAO,IAAIA,OAAO,CAAC3J,KAAK,CAACoJ,aAAa,EAAEhS,IAAI,CAAC;QAC7C4I,KAAK,CAACmJ,UAAU,GAAGnJ,KAAK,CAACoJ,aAAa;MAC1C;MACAQ,MAAM,IAAIA,MAAM,CAAC5J,KAAK,CAACoJ,aAAa,EAAEhS,IAAI,CAAC;IAC/C,CAAC;IACD,IAAI,CAACyS,iBAAiB,GAAG,UAAUlW,KAAK,EAAEyD,IAAI,EAAE;MAC5C4I,KAAK,CAACoJ,aAAa,GAAGzV,KAAK;MAC3BqM,KAAK,CAACqJ,iBAAiB,GAAGS,cAAc,CAAC1S,IAAI,EAAE4I,KAAK,CAACjjB,kBAAkB,CAAC;MACxE;MACA,IAAI2W,YAAY,CAACC,KAAK,CAAC,IAAIA,KAAK,CAACoW,OAAO,KAAK,CAAC,EAAE;QAC5C/J,KAAK,CAACgK,eAAe,CAACrW,KAAK,EAAEyD,IAAI,CAAC;QAClC;MACJ;MACA;MACAhd,aAAa,CAAC,SAAS,CAAC,CAAC6vB,MAAM,CAACjK,KAAK,CAACsJ,WAAW,EAAE,IAAI,CAAC;IAC5D,CAAC;IACD,IAAI,CAACU,eAAe,GAAG,UAAUrW,KAAK,EAAEyD,IAAI,EAAE;MAC1C4I,KAAK,CAACkK,GAAG,EAAE;MACX,IAAIxtB,EAAE,GAAGsjB,KAAK,CAACkJ,QAAQ;QAAEiB,KAAK,GAAGztB,EAAE,CAACytB,KAAK;QAAEC,YAAY,GAAG1tB,EAAE,CAAC0tB,YAAY;MACzE,IAAIC,OAAO,GAAGd,UAAU,CAACO,cAAc,CAAC1S,IAAI,EAAE4I,KAAK,CAACjjB,kBAAkB,CAAC,EAAEijB,KAAK,CAACwJ,OAAO,CAAC;MACvF,IAAIxJ,KAAK,CAACmJ,UAAU,IAAIgB,KAAK,EAAE;QAC3BA,KAAK,CAACxW,KAAK,EAAE0W,OAAO,CAAC;MACzB;MACAD,YAAY,IAAIA,YAAY,CAACzW,KAAK,EAAE0W,OAAO,CAAC;IAChD,CAAC;IACD;IACA,IAAItW,YAAY,CAACJ,KAAK,CAAC,IAAIA,KAAK,CAACM,OAAO,CAACnY,MAAM,GAAG,CAAC,EAC/C;IACJ,IAAI,CAACotB,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACnsB,kBAAkB,GAAGA,kBAAkB;IAC5C,IAAIqa,IAAI,GAAGrC,gBAAgB,CAACpB,KAAK,CAAC;IAClC,IAAI2W,WAAW,GAAGR,cAAc,CAAC1S,IAAI,EAAE,IAAI,CAACra,kBAAkB,CAAC;IAC/D,IAAI8X,KAAK,GAAGyV,WAAW,CAACzV,KAAK;IAC7B,IAAIsM,SAAS,GAAGhoB,IAAI,CAAC8nB,YAAY,EAAE,CAACE,SAAS;IAC7C,IAAI,CAACqI,OAAO,GAAG,CAAC3wB,KAAK,CAACgE,QAAQ,CAAChE,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAEgY,KAAK,CAAC,EAAE;MAAEsM,SAAS,EAAEA;IAAU,CAAC,CAAC,CAAC;IACpF,IAAIoJ,cAAc,GAAGrB,QAAQ,CAACqB,cAAc;IAC5CA,cAAc,IACVA,cAAc,CAAC5W,KAAK,EAAE4V,UAAU,CAACe,WAAW,EAAE,IAAI,CAACd,OAAO,CAAC,CAAC;IAChE,IAAI,CAACgB,eAAe,GAAGtxB,SAAS,CAACyf,IAAI,CAACtC,eAAe,CAAC7X,MAAM,EAAE,aAAa,EAAE,IAAI,CAACqrB,iBAAiB,CAAC,EAAExT,eAAe,CAAC7X,MAAM,EAAE,WAAW,EAAE,IAAI,CAACwrB,eAAe,CAAC,EAAE3T,eAAe,CAAC7X,MAAM,EAAE,eAAe,EAAE,IAAI,CAACwrB,eAAe,CAAC,CAAC;EACrO;EACAf,UAAU,CAAChpB,SAAS,CAACwqB,cAAc,GAAG,UAAUvB,QAAQ,EAAE;IACtD,IAAI,CAACA,QAAQ,GAAGA,QAAQ;EAC5B,CAAC;EACDD,UAAU,CAAChpB,SAAS,CAACiqB,GAAG,GAAG,YAAY;IACnC,IAAI,CAACM,eAAe,IAAI,IAAI,CAACA,eAAe,EAAE;IAC9CrxB,IAAI,CAACuxB,UAAU,CAACT,MAAM,CAAC,IAAI,CAACX,WAAW,CAAC;EAC5C,CAAC;EACD,OAAOL,UAAU;AACrB,CAAC,EAAG;AACJ,SAASa,cAAcA,CAAC1S,IAAI,EAAEra,kBAAkB,EAAE;EAC9C,OAAOA,kBAAkB,GAAG;IAAE8X,KAAK,EAAE9X,kBAAkB,CAACqa,IAAI,CAACvC,KAAK;EAAE,CAAC,GAAGuC,IAAI;AAChF;AACA,SAASuT,aAAaA,CAACjmB,CAAC,EAAEC,CAAC,EAAE;EACzB,OAAO;IAAEU,CAAC,EAAEX,CAAC,CAACW,CAAC,GAAGV,CAAC,CAACU,CAAC;IAAEC,CAAC,EAAEZ,CAAC,CAACY,CAAC,GAAGX,CAAC,CAACW;EAAE,CAAC;AACzC;AACA,SAASikB,UAAUA,CAAC7sB,EAAE,EAAE8sB,OAAO,EAAE;EAC7B,IAAI3U,KAAK,GAAGnY,EAAE,CAACmY,KAAK;EACpB,OAAO;IACHA,KAAK,EAAEA,KAAK;IACZqM,KAAK,EAAEyJ,aAAa,CAAC9V,KAAK,EAAE+V,eAAe,CAACpB,OAAO,CAAC,CAAC;IACrD3b,MAAM,EAAE8c,aAAa,CAAC9V,KAAK,EAAEgW,gBAAgB,CAACrB,OAAO,CAAC,CAAC;IACvDtoB,QAAQ,EAAEC,WAAW,CAACqoB,OAAO,EAAE,GAAG;EACtC,CAAC;AACL;AACA,SAASqB,gBAAgBA,CAACrB,OAAO,EAAE;EAC/B,OAAOA,OAAO,CAAC,CAAC,CAAC;AACrB;AACA,SAASoB,eAAeA,CAACpB,OAAO,EAAE;EAC9B,OAAOA,OAAO,CAACA,OAAO,CAAC1tB,MAAM,GAAG,CAAC,CAAC;AACtC;AACA,SAASqF,WAAWA,CAACqoB,OAAO,EAAE/I,SAAS,EAAE;EACrC,IAAI+I,OAAO,CAAC1tB,MAAM,GAAG,CAAC,EAAE;IACpB,OAAO;MAAEuJ,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE;IAAE,CAAC;EACzB;EACA,IAAI9I,CAAC,GAAGgtB,OAAO,CAAC1tB,MAAM,GAAG,CAAC;EAC1B,IAAIgvB,gBAAgB,GAAG,IAAI;EAC3B,IAAIC,SAAS,GAAGH,eAAe,CAACpB,OAAO,CAAC;EACxC,OAAOhtB,CAAC,IAAI,CAAC,EAAE;IACXsuB,gBAAgB,GAAGtB,OAAO,CAAChtB,CAAC,CAAC;IAC7B,IAAIuuB,SAAS,CAAC5J,SAAS,GAAG2J,gBAAgB,CAAC3J,SAAS,GAChDhI,qBAAqB,CAACsH,SAAS,CAAC,EAAE;MAClC;IACJ;IACAjkB,CAAC,EAAE;EACP;EACA,IAAI,CAACsuB,gBAAgB,EAAE;IACnB,OAAO;MAAEzlB,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE;IAAE,CAAC;EACzB;EACA,IAAI0lB,IAAI,GAAG,CAACD,SAAS,CAAC5J,SAAS,GAAG2J,gBAAgB,CAAC3J,SAAS,IAAI,IAAI;EACpE,IAAI6J,IAAI,KAAK,CAAC,EAAE;IACZ,OAAO;MAAE3lB,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE;IAAE,CAAC;EACzB;EACA,IAAI9D,eAAe,GAAG;IAClB6D,CAAC,EAAE,CAAC0lB,SAAS,CAAC1lB,CAAC,GAAGylB,gBAAgB,CAACzlB,CAAC,IAAI2lB,IAAI;IAC5C1lB,CAAC,EAAE,CAACylB,SAAS,CAACzlB,CAAC,GAAGwlB,gBAAgB,CAACxlB,CAAC,IAAI0lB;EAC5C,CAAC;EACD,IAAIxpB,eAAe,CAAC6D,CAAC,KAAKoiB,QAAQ,EAAE;IAChCjmB,eAAe,CAAC6D,CAAC,GAAG,CAAC;EACzB;EACA,IAAI7D,eAAe,CAAC8D,CAAC,KAAKmiB,QAAQ,EAAE;IAChCjmB,eAAe,CAAC8D,CAAC,GAAG,CAAC;EACzB;EACA,OAAO9D,eAAe;AAC1B;AAEA,SAASypB,IAAIA,CAACC,GAAG,EAAE;EACf,OAAOA,GAAG;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASC,2BAA2BA,CAACzuB,EAAE,EAAE;EACrC,IAAI4L,GAAG,GAAG5L,EAAE,CAAC4L,GAAG;IAAEG,IAAI,GAAG/L,EAAE,CAAC+L,IAAI;IAAEF,KAAK,GAAG7L,EAAE,CAAC6L,KAAK;IAAEC,MAAM,GAAG9L,EAAE,CAAC8L,MAAM;EACtE,OAAO;IACHnD,CAAC,EAAE;MAAE+lB,GAAG,EAAE3iB,IAAI;MAAE4iB,GAAG,EAAE9iB;IAAM,CAAC;IAC5BjD,CAAC,EAAE;MAAE8lB,GAAG,EAAE9iB,GAAG;MAAE+iB,GAAG,EAAE7iB;IAAO;EAC/B,CAAC;AACL;AACA,SAAS8iB,2BAA2BA,CAAC5uB,EAAE,EAAE;EACrC,IAAI2I,CAAC,GAAG3I,EAAE,CAAC2I,CAAC;IAAEC,CAAC,GAAG5I,EAAE,CAAC4I,CAAC;EACtB,OAAO;IACHgD,GAAG,EAAEhD,CAAC,CAAC8lB,GAAG;IACV5iB,MAAM,EAAElD,CAAC,CAAC+lB,GAAG;IACb5iB,IAAI,EAAEpD,CAAC,CAAC+lB,GAAG;IACX7iB,KAAK,EAAElD,CAAC,CAACgmB;EACb,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,oBAAoBA,CAAC7uB,EAAE,EAAEotB,cAAc,EAAE;EAC9C,IAAIxhB,GAAG,GAAG5L,EAAE,CAAC4L,GAAG;IAAEG,IAAI,GAAG/L,EAAE,CAAC+L,IAAI;IAAED,MAAM,GAAG9L,EAAE,CAAC8L,MAAM;IAAED,KAAK,GAAG7L,EAAE,CAAC6L,KAAK;EACtE,IAAIuhB,cAAc,KAAK,KAAK,CAAC,EAAE;IAAEA,cAAc,GAAGmB,IAAI;EAAE;EACxD,IAAIO,OAAO,GAAG1B,cAAc,CAAC;IAAEzkB,CAAC,EAAEoD,IAAI;IAAEnD,CAAC,EAAEgD;EAAI,CAAC,CAAC;EACjD,IAAImjB,WAAW,GAAG3B,cAAc,CAAC;IAAEzkB,CAAC,EAAEkD,KAAK;IAAEjD,CAAC,EAAEkD;EAAO,CAAC,CAAC;EACzD,OAAO;IACHF,GAAG,EAAEkjB,OAAO,CAAClmB,CAAC;IACdmD,IAAI,EAAE+iB,OAAO,CAACnmB,CAAC;IACfmD,MAAM,EAAEijB,WAAW,CAACnmB,CAAC;IACrBiD,KAAK,EAAEkjB,WAAW,CAACpmB;EACvB,CAAC;AACL;AACA;AACA;AACA;AACA,SAASqmB,OAAOA,CAAA,EAAG;EACf,OAAO;IAAErmB,CAAC,EAAE;MAAE+lB,GAAG,EAAE,CAAC;MAAEC,GAAG,EAAE;IAAE,CAAC;IAAE/lB,CAAC,EAAE;MAAE8lB,GAAG,EAAE,CAAC;MAAEC,GAAG,EAAE;IAAE;EAAE,CAAC;AAC3D;AACA,SAASM,WAAWA,CAACC,GAAG,EAAE;EACtB,OAAO;IACHvmB,CAAC,EAAExM,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAE+uB,GAAG,CAACvmB,CAAC,CAAC;IAC5BC,CAAC,EAAEzM,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAE+uB,GAAG,CAACtmB,CAAC;EAC/B,CAAC;AACL;AACA;AACA;AACA;AACA,IAAIumB,SAAS,GAAG;EACZC,SAAS,EAAE,CAAC;EACZriB,KAAK,EAAE,CAAC;EACRmE,MAAM,EAAE,CAAC;EACTme,WAAW,EAAE;AACjB,CAAC;AACD,SAAS7K,KAAKA,CAAA,EAAG;EACb,OAAO;IACH7b,CAAC,EAAExM,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAEgvB,SAAS,CAAC;IAChCvmB,CAAC,EAAEzM,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAEgvB,SAAS;EACnC,CAAC;AACL;;AAEA;AACA,SAASG,QAAQA,CAAC/Y,OAAO,EAAE;EACvB,OAAO,CAACA,OAAO,CAAC,GAAG,CAAC,EAAEA,OAAO,CAAC,GAAG,CAAC,CAAC;AACvC;AAEA,IAAIgZ,aAAa,GAAG,SAAAA,CAAUtrB,CAAC,EAAE;EAAE,OAAOzH,SAAS,CAACgzB,KAAK,CAAC,CAAC,EAAE,CAAC,EAAEvrB,CAAC,CAAC;AAAE,CAAC;AACrE;AACA;AACA;AACA,SAASwrB,MAAMA,CAACvzB,KAAK,EAAEyT,MAAM,EAAE+f,WAAW,EAAE;EACxC,IAAI/f,MAAM,KAAK,KAAK,CAAC,EAAE;IAAEA,MAAM,GAAG,CAAC;EAAE;EACrC,IAAI+f,WAAW,KAAK,KAAK,CAAC,EAAE;IAAEA,WAAW,GAAG,IAAI;EAAE;EAClD,OAAOlzB,SAAS,CAAC8Q,QAAQ,CAACpR,KAAK,EAAEyT,MAAM,CAAC,GAAG+f,WAAW;AAC1D;AACA,SAASC,UAAUA,CAACC,IAAI,EAAE;EACtB,OAAOA,IAAI,CAACjB,GAAG,GAAGiB,IAAI,CAAClB,GAAG;AAC9B;AACA;AACA;AACA;AACA;AACA,SAASmB,UAAUA,CAACjgB,MAAM,EAAED,MAAM,EAAE;EAChC,IAAIuB,MAAM,GAAG,GAAG;EAChB,IAAI4e,YAAY,GAAGH,UAAU,CAAC/f,MAAM,CAAC;EACrC,IAAImgB,YAAY,GAAGJ,UAAU,CAAChgB,MAAM,CAAC;EACrC,IAAIogB,YAAY,GAAGD,YAAY,EAAE;IAC7B5e,MAAM,GAAG1U,SAAS,CAACiV,QAAQ,CAAC9B,MAAM,CAAC+e,GAAG,EAAE/e,MAAM,CAACgf,GAAG,GAAGmB,YAAY,EAAElgB,MAAM,CAAC8e,GAAG,CAAC;EAClF,CAAC,MACI,IAAIoB,YAAY,GAAGC,YAAY,EAAE;IAClC7e,MAAM,GAAG1U,SAAS,CAACiV,QAAQ,CAAC7B,MAAM,CAAC8e,GAAG,EAAE9e,MAAM,CAAC+e,GAAG,GAAGoB,YAAY,EAAEpgB,MAAM,CAAC+e,GAAG,CAAC;EAClF;EACA,OAAOa,aAAa,CAACre,MAAM,CAAC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS8e,eAAeA,CAACxL,KAAK,EAAE5U,MAAM,EAAED,MAAM,EAAEuB,MAAM,EAAE;EACpD,IAAIA,MAAM,KAAK,KAAK,CAAC,EAAE;IAAEA,MAAM,GAAG,GAAG;EAAE;EACvCsT,KAAK,CAACtT,MAAM,GAAGA,MAAM;EACrBsT,KAAK,CAAC6K,WAAW,GAAG7yB,SAAS,CAAC+X,GAAG,CAAC3E,MAAM,CAAC8e,GAAG,EAAE9e,MAAM,CAAC+e,GAAG,EAAEnK,KAAK,CAACtT,MAAM,CAAC;EACvEsT,KAAK,CAACzX,KAAK,GAAG4iB,UAAU,CAAChgB,MAAM,CAAC,GAAGggB,UAAU,CAAC/f,MAAM,CAAC;EACrD,IAAI6f,MAAM,CAACjL,KAAK,CAACzX,KAAK,EAAE,CAAC,EAAE,MAAM,CAAC,EAC9ByX,KAAK,CAACzX,KAAK,GAAG,CAAC;EACnByX,KAAK,CAAC4K,SAAS,GACX5yB,SAAS,CAAC+X,GAAG,CAAC5E,MAAM,CAAC+e,GAAG,EAAE/e,MAAM,CAACgf,GAAG,EAAEnK,KAAK,CAACtT,MAAM,CAAC,GAAGsT,KAAK,CAAC6K,WAAW;EAC3E,IAAII,MAAM,CAACjL,KAAK,CAAC4K,SAAS,CAAC,EACvB5K,KAAK,CAAC4K,SAAS,GAAG,CAAC;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASa,cAAcA,CAACzL,KAAK,EAAE5U,MAAM,EAAED,MAAM,EAAEuB,MAAM,EAAE;EACnD8e,eAAe,CAACxL,KAAK,CAAC7b,CAAC,EAAEiH,MAAM,CAACjH,CAAC,EAAEgH,MAAM,CAAChH,CAAC,EAAEunB,aAAa,CAAChf,MAAM,CAACnH,OAAO,CAAC,CAAC;EAC3EimB,eAAe,CAACxL,KAAK,CAAC5b,CAAC,EAAEgH,MAAM,CAAChH,CAAC,EAAE+G,MAAM,CAAC/G,CAAC,EAAEsnB,aAAa,CAAChf,MAAM,CAAClH,OAAO,CAAC,CAAC;AAC/E;AACA;AACA;AACA;AACA;AACA,SAASkmB,aAAaA,CAAChf,MAAM,EAAE;EAC3B,OAAO,OAAOA,MAAM,KAAK,QAAQ,GAAGA,MAAM,GAAG,GAAG;AACpD;AACA,SAASif,gBAAgBA,CAACxgB,MAAM,EAAEygB,QAAQ,EAAE3tB,MAAM,EAAE;EAChDkN,MAAM,CAAC+e,GAAG,GAAGjsB,MAAM,CAACisB,GAAG,GAAG0B,QAAQ,CAAC1B,GAAG;EACtC/e,MAAM,CAACgf,GAAG,GAAGhf,MAAM,CAAC+e,GAAG,GAAGiB,UAAU,CAACS,QAAQ,CAAC;AAClD;AACA,SAASC,eAAeA,CAAChiB,UAAU,EAAEiiB,gBAAgB,EAAE;EACnDH,gBAAgB,CAAC9hB,UAAU,CAACsB,MAAM,CAAChH,CAAC,EAAE0F,UAAU,CAACkiB,cAAc,CAAC5nB,CAAC,EAAE2nB,gBAAgB,CAAC3gB,MAAM,CAAChH,CAAC,CAAC;EAC7FwnB,gBAAgB,CAAC9hB,UAAU,CAACsB,MAAM,CAAC/G,CAAC,EAAEyF,UAAU,CAACkiB,cAAc,CAAC3nB,CAAC,EAAE0nB,gBAAgB,CAAC3gB,MAAM,CAAC/G,CAAC,CAAC;AACjG;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS4nB,gBAAgBA,CAACrY,KAAK,EAAEnY,EAAE,EAAEywB,OAAO,EAAE;EAC1C,IAAI/B,GAAG,GAAG1uB,EAAE,CAAC0uB,GAAG;IAAEC,GAAG,GAAG3uB,EAAE,CAAC2uB,GAAG;EAC9B,IAAID,GAAG,KAAKtsB,SAAS,IAAI+V,KAAK,GAAGuW,GAAG,EAAE;IAClC;IACAvW,KAAK,GAAGsY,OAAO,GAAGj0B,SAAS,CAAC+X,GAAG,CAACma,GAAG,EAAEvW,KAAK,EAAEsY,OAAO,CAAC/B,GAAG,CAAC,GAAGlkB,IAAI,CAACmkB,GAAG,CAACxW,KAAK,EAAEuW,GAAG,CAAC;EACnF,CAAC,MACI,IAAIC,GAAG,KAAKvsB,SAAS,IAAI+V,KAAK,GAAGwW,GAAG,EAAE;IACvC;IACAxW,KAAK,GAAGsY,OAAO,GAAGj0B,SAAS,CAAC+X,GAAG,CAACoa,GAAG,EAAExW,KAAK,EAAEsY,OAAO,CAAC9B,GAAG,CAAC,GAAGnkB,IAAI,CAACkkB,GAAG,CAACvW,KAAK,EAAEwW,GAAG,CAAC;EACnF;EACA,OAAOxW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASuY,uBAAuBA,CAACvY,KAAK,EAAE/Y,MAAM,EAAEqS,QAAQ,EAAEkf,WAAW,EAAEF,OAAO,EAAE;EAC5E;EACA,IAAI/B,GAAG,GAAGvW,KAAK,GAAG/Y,MAAM,GAAGqS,QAAQ;EACnC,OAAOkf,WAAW,GAAGH,gBAAgB,CAAC9B,GAAG,EAAEiC,WAAW,EAAEF,OAAO,CAAC,GAAG/B,GAAG;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,SAASkC,2BAA2BA,CAAChB,IAAI,EAAElB,GAAG,EAAEC,GAAG,EAAE;EACjD,OAAO;IACHD,GAAG,EAAEA,GAAG,KAAKtsB,SAAS,GAAGwtB,IAAI,CAAClB,GAAG,GAAGA,GAAG,GAAGtsB,SAAS;IACnDusB,GAAG,EAAEA,GAAG,KAAKvsB,SAAS,GAChBwtB,IAAI,CAACjB,GAAG,GAAGA,GAAG,IAAIiB,IAAI,CAACjB,GAAG,GAAGiB,IAAI,CAAClB,GAAG,CAAC,GACtCtsB;EACV,CAAC;AACL;AACA;AACA;AACA;AACA;AACA,SAASyuB,uBAAuBA,CAACC,SAAS,EAAE9wB,EAAE,EAAE;EAC5C,IAAI4L,GAAG,GAAG5L,EAAE,CAAC4L,GAAG;IAAEG,IAAI,GAAG/L,EAAE,CAAC+L,IAAI;IAAED,MAAM,GAAG9L,EAAE,CAAC8L,MAAM;IAAED,KAAK,GAAG7L,EAAE,CAAC6L,KAAK;EACtE,OAAO;IACHlD,CAAC,EAAEioB,2BAA2B,CAACE,SAAS,CAACnoB,CAAC,EAAEoD,IAAI,EAAEF,KAAK,CAAC;IACxDjD,CAAC,EAAEgoB,2BAA2B,CAACE,SAAS,CAACloB,CAAC,EAAEgD,GAAG,EAAEE,MAAM;EAC3D,CAAC;AACL;AACA;AACA;AACA;AACA,SAASilB,2BAA2BA,CAACC,UAAU,EAAEC,eAAe,EAAE;EAC9D,IAAIjxB,EAAE;EACN,IAAI0uB,GAAG,GAAGuC,eAAe,CAACvC,GAAG,GAAGsC,UAAU,CAACtC,GAAG;EAC9C,IAAIC,GAAG,GAAGsC,eAAe,CAACtC,GAAG,GAAGqC,UAAU,CAACrC,GAAG;EAC9C;EACA;EACA,IAAIsC,eAAe,CAACtC,GAAG,GAAGsC,eAAe,CAACvC,GAAG,GACzCsC,UAAU,CAACrC,GAAG,GAAGqC,UAAU,CAACtC,GAAG,EAAE;IACjC1uB,EAAE,GAAG7D,KAAK,CAACwhB,MAAM,CAAC,CAACgR,GAAG,EAAED,GAAG,CAAC,EAAE,CAAC,CAAC,EAAEA,GAAG,GAAG1uB,EAAE,CAAC,CAAC,CAAC,EAAE2uB,GAAG,GAAG3uB,EAAE,CAAC,CAAC,CAAC;EAC9D;EACA,OAAO;IACH0uB,GAAG,EAAEsC,UAAU,CAACtC,GAAG,GAAGA,GAAG;IACzBC,GAAG,EAAEqC,UAAU,CAACtC,GAAG,GAAGC;EAC1B,CAAC;AACL;AACA;AACA;AACA;AACA,SAASuC,uBAAuBA,CAACJ,SAAS,EAAEK,cAAc,EAAE;EACxD,OAAO;IACHxoB,CAAC,EAAEooB,2BAA2B,CAACD,SAAS,CAACnoB,CAAC,EAAEwoB,cAAc,CAACxoB,CAAC,CAAC;IAC7DC,CAAC,EAAEmoB,2BAA2B,CAACD,SAAS,CAACloB,CAAC,EAAEuoB,cAAc,CAACvoB,CAAC;EAChE,CAAC;AACL;AACA;AACA;AACA;AACA,SAASwoB,wBAAwBA,CAACxB,IAAI,EAAEe,WAAW,EAAElf,QAAQ,EAAE;EAC3D,IAAI4f,UAAU,GAAGzB,IAAI,CAACjB,GAAG,GAAGiB,IAAI,CAAClB,GAAG;EACpC,IAAIA,GAAG,GAAGlyB,SAAS,CAAC+X,GAAG,CAACoc,WAAW,CAACjC,GAAG,EAAEiC,WAAW,CAAChC,GAAG,GAAG0C,UAAU,EAAE5f,QAAQ,CAAC;EAChF,OAAO;IAAEid,GAAG,EAAEA,GAAG;IAAEC,GAAG,EAAED,GAAG,GAAG2C;EAAW,CAAC;AAC9C;AACA;AACA;AACA;AACA,SAASC,qBAAqBA,CAAC9oB,MAAM,EAAEmoB,WAAW,EAAE;EAChD,IAAIY,mBAAmB,GAAG,CAAC,CAAC;EAC5B,IAAIZ,WAAW,CAACjC,GAAG,KAAKtsB,SAAS,EAAE;IAC/BmvB,mBAAmB,CAAC7C,GAAG,GAAGiC,WAAW,CAACjC,GAAG,GAAGlmB,MAAM,CAACkmB,GAAG;EAC1D;EACA,IAAIiC,WAAW,CAAChC,GAAG,KAAKvsB,SAAS,EAAE;IAC/BmvB,mBAAmB,CAAC5C,GAAG,GAAGgC,WAAW,CAAChC,GAAG,GAAGnmB,MAAM,CAACkmB,GAAG;EAC1D;EACA,OAAO6C,mBAAmB;AAC9B;AACA,IAAIC,cAAc,GAAG,IAAI;AACzB;AACA;AACA;AACA,SAASC,kBAAkBA,CAACC,WAAW,EAAE;EACrC,IAAIA,WAAW,KAAK,KAAK,EAAE;IACvBA,WAAW,GAAG,CAAC;EACnB,CAAC,MACI,IAAIA,WAAW,KAAK,IAAI,EAAE;IAC3BA,WAAW,GAAGF,cAAc;EAChC;EACA,OAAO;IACH7oB,CAAC,EAAEgpB,kBAAkB,CAACD,WAAW,EAAE,MAAM,EAAE,OAAO,CAAC;IACnD9oB,CAAC,EAAE+oB,kBAAkB,CAACD,WAAW,EAAE,KAAK,EAAE,QAAQ;EACtD,CAAC;AACL;AACA,SAASC,kBAAkBA,CAACD,WAAW,EAAEE,QAAQ,EAAEC,QAAQ,EAAE;EACzD,OAAO;IACHnD,GAAG,EAAEoD,mBAAmB,CAACJ,WAAW,EAAEE,QAAQ,CAAC;IAC/CjD,GAAG,EAAEmD,mBAAmB,CAACJ,WAAW,EAAEG,QAAQ;EAClD,CAAC;AACL;AACA,SAASC,mBAAmBA,CAACJ,WAAW,EAAEK,KAAK,EAAE;EAC7C,IAAI/xB,EAAE;EACN,OAAO,OAAO0xB,WAAW,KAAK,QAAQ,GAChCA,WAAW,GACX,CAAC1xB,EAAE,GAAG0xB,WAAW,CAACK,KAAK,CAAC,MAAM,IAAI,IAAI/xB,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,CAAC;AACtE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASgyB,cAAcA,CAACve,OAAO,EAAEpT,kBAAkB,EAAE;EACjD,IAAI6uB,GAAG,GAAGzb,OAAO,CAACoC,qBAAqB,EAAE;EACzC,OAAO4Y,2BAA2B,CAACI,oBAAoB,CAACK,GAAG,EAAE7uB,kBAAkB,CAAC,CAAC;AACrF;AAEA,IAAI4xB,cAAc,GAAG,SAAAA,CAAUjqB,CAAC,EAAEC,CAAC,EAAE;EACjC,OAAOD,CAAC,CAACkqB,KAAK,GAAGjqB,CAAC,CAACiqB,KAAK;AAC5B,CAAC;AAED,SAASC,YAAYA,CAAC7yB,aAAa,EAAE;EACjC,IAAIzB,SAAS,GAAGyB,aAAa,CAAC+O,UAAU,CAACxQ,SAAS;EAClD,OAAOA,SAAS,IAAIyB,aAAa,CAAC8yB,oBAAoB,EAAE;AAC5D;AACA,SAASC,0BAA0BA,CAAC/yB,aAAa,EAAEgzB,SAAS,EAAE;EAC1D,IAAIA,SAAS,KAAK,KAAK,CAAC,EAAE;IAAEA,SAAS,GAAG,EAAE;EAAE;EAC5C,IAAI7vB,MAAM,GAAGnD,aAAa,CAACmD,MAAM;EACjC,IAAIA,MAAM,EACN4vB,0BAA0B,CAAC5vB,MAAM,EAAE6vB,SAAS,CAAC;EACjD,IAAIH,YAAY,CAAC7yB,aAAa,CAAC,EAC3BgzB,SAAS,CAACryB,IAAI,CAACX,aAAa,CAAC;EACjC,OAAOgzB,SAAS;AACpB;AACA,SAASC,yBAAyBA,CAACjzB,aAAa,EAAE;EAC9C,IAAIkzB,QAAQ,GAAG,EAAE;EACjB,IAAIC,QAAQ,GAAG,SAAAA,CAAUzX,KAAK,EAAE;IAC5B,IAAImX,YAAY,CAACnX,KAAK,CAAC,EACnBwX,QAAQ,CAACvyB,IAAI,CAAC+a,KAAK,CAAC;IACxBA,KAAK,CAACwX,QAAQ,CAACv1B,OAAO,CAACw1B,QAAQ,CAAC;EACpC,CAAC;EACDnzB,aAAa,CAACkzB,QAAQ,CAACv1B,OAAO,CAACw1B,QAAQ,CAAC;EACxC,OAAOD,QAAQ,CAAC9oB,IAAI,CAACuoB,cAAc,CAAC;AACxC;AACA;AACA;AACA;AACA;AACA,SAASS,uBAAuBA,CAACpzB,aAAa,EAAE;EAC5C,IAAIA,aAAa,CAAC8yB,oBAAoB,EAAE,EACpC;EACJ,IAAI9jB,WAAW,GAAGhP,aAAa,CAACqzB,cAAc,EAAE;EAChDrzB,aAAa,CAACszB,yBAAyB,CAACtkB,WAAW,CAAC9F,MAAM,CAAC;EAC3D8F,WAAW,CAACa,UAAU,GAAG,IAAI;EAC7Bb,WAAW,CAAC9F,MAAM,GAAGlJ,aAAa,CAACuzB,kBAAkB,EAAE;EACvDvkB,WAAW,CAACwkB,eAAe,GAAG7D,WAAW,CAAC3gB,WAAW,CAAC9F,MAAM,CAAC;EAC7DlJ,aAAa,CAACyzB,mBAAmB,CAACzkB,WAAW,CAAC9F,MAAM,EAAElJ,aAAa,CAAC0zB,eAAe,IAAI1kB,WAAW,CAAC9F,MAAM,CAAC;EAC1G9K,aAAa,CAAC,SAAS,CAAC,CAAC6vB,MAAM,CAAC,YAAY;IAAE,OAAOjuB,aAAa,CAAC2zB,sBAAsB,EAAE;EAAE,CAAC,CAAC;AACnG;AACA;AACA;AACA;AACA,SAASC,mBAAmBA,CAAC5zB,aAAa,EAAE;EACxC,IAAIA,aAAa,CAAC8yB,oBAAoB,EAAE,EACpC;EACJ9yB,aAAa,CAAC0zB,eAAe,GAAG1zB,aAAa,CAACuzB,kBAAkB,CAAC,KAAK,CAAC;EACvE;AACJ;AACA;AACA;EACIvzB,aAAa,CAAC2zB,sBAAsB,CAAC,KAAK,EAAE3zB,aAAa,CAAC0zB,eAAe,CAAC;AAC9E;AAEA,SAASG,SAASA,CAACxjB,MAAM,EAAE4M,IAAI,EAAED,IAAI,EAAEhc,CAAC,EAAE;EACtCqP,MAAM,CAAC+e,GAAG,GAAGlyB,SAAS,CAAC+X,GAAG,CAACgI,IAAI,CAACmS,GAAG,EAAEpS,IAAI,CAACoS,GAAG,EAAEpuB,CAAC,CAAC;EACjDqP,MAAM,CAACgf,GAAG,GAAGnyB,SAAS,CAAC+X,GAAG,CAACgI,IAAI,CAACoS,GAAG,EAAErS,IAAI,CAACqS,GAAG,EAAEruB,CAAC,CAAC;AACrD;AACA,SAAS8yB,sBAAsBA,CAAC3wB,MAAM,EAAEuY,KAAK,EAAE;EAC3C,OAAO;IACH0T,GAAG,EAAE1T,KAAK,CAAC0T,GAAG,GAAGjsB,MAAM,CAACisB,GAAG;IAC3BC,GAAG,EAAE3T,KAAK,CAAC2T,GAAG,GAAGlsB,MAAM,CAACisB;EAC5B,CAAC;AACL;AACA,SAAS2E,kBAAkBA,CAAC5wB,MAAM,EAAEuY,KAAK,EAAE;EACvC,OAAO;IACHrS,CAAC,EAAEyqB,sBAAsB,CAAC3wB,MAAM,CAACkG,CAAC,EAAEqS,KAAK,CAACrS,CAAC,CAAC;IAC5CC,CAAC,EAAEwqB,sBAAsB,CAAC3wB,MAAM,CAACmG,CAAC,EAAEoS,KAAK,CAACpS,CAAC;EAC/C,CAAC;AACL;AACA,SAAS0qB,uBAAuBA,CAAC/W,IAAI,EAAED,IAAI,EAAE;EACzC,IAAIiX,MAAM,GAAGhX,IAAI,CAACiX,WAAW,EAAE;EAC/B,IAAIC,MAAM,GAAGnX,IAAI,CAACkX,WAAW,EAAE;EAC/B,OAAOD,MAAM,KAAKE,MAAM,IAAKA,MAAM,KAAKrxB,SAAS,IAAIma,IAAI,KAAKD,IAAK;AACvE;AAEA,SAASoX,WAAWA,CAACp0B,aAAa,EAAE;EAChC,IAAIU,EAAE,GAAGV,aAAa,CAAC2F,QAAQ,EAAE;IAAE5G,IAAI,GAAG2B,EAAE,CAAC3B,IAAI;IAAEs1B,MAAM,GAAG3zB,EAAE,CAAC2zB,MAAM;EACrE,OAAOt1B,IAAI,IAAI,CAACs1B,MAAM;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASC,SAASA,CAAChE,IAAI,EAAEiE,UAAU,EAAE;EACjCjE,IAAI,CAAClB,GAAG,GAAGmF,UAAU,CAACnF,GAAG;EACzBkB,IAAI,CAACjB,GAAG,GAAGkF,UAAU,CAAClF,GAAG;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,SAASmF,QAAQA,CAAC5E,GAAG,EAAE6E,SAAS,EAAE;EAC9BH,SAAS,CAAC1E,GAAG,CAACvmB,CAAC,EAAEorB,SAAS,CAACprB,CAAC,CAAC;EAC7BirB,SAAS,CAAC1E,GAAG,CAACtmB,CAAC,EAAEmrB,SAAS,CAACnrB,CAAC,CAAC;AACjC;AACA;AACA;AACA;AACA,SAASorB,UAAUA,CAAC7b,KAAK,EAAEpL,KAAK,EAAEsiB,WAAW,EAAE;EAC3C,IAAI4E,kBAAkB,GAAG9b,KAAK,GAAGkX,WAAW;EAC5C,IAAI6E,MAAM,GAAGnnB,KAAK,GAAGknB,kBAAkB;EACvC,OAAO5E,WAAW,GAAG6E,MAAM;AAC/B;AACA;AACA;AACA;AACA,SAASC,eAAeA,CAAChc,KAAK,EAAEiX,SAAS,EAAEriB,KAAK,EAAEsiB,WAAW,EAAE+E,QAAQ,EAAE;EACrE,IAAIA,QAAQ,KAAKhyB,SAAS,EAAE;IACxB+V,KAAK,GAAG6b,UAAU,CAAC7b,KAAK,EAAEic,QAAQ,EAAE/E,WAAW,CAAC;EACpD;EACA,OAAO2E,UAAU,CAAC7b,KAAK,EAAEpL,KAAK,EAAEsiB,WAAW,CAAC,GAAGD,SAAS;AAC5D;AACA;AACA;AACA;AACA,SAASiF,cAAcA,CAACzE,IAAI,EAAER,SAAS,EAAEriB,KAAK,EAAEsiB,WAAW,EAAE+E,QAAQ,EAAE;EACnE,IAAIhF,SAAS,KAAK,KAAK,CAAC,EAAE;IAAEA,SAAS,GAAG,CAAC;EAAE;EAC3C,IAAIriB,KAAK,KAAK,KAAK,CAAC,EAAE;IAAEA,KAAK,GAAG,CAAC;EAAE;EACnC6iB,IAAI,CAAClB,GAAG,GAAGyF,eAAe,CAACvE,IAAI,CAAClB,GAAG,EAAEU,SAAS,EAAEriB,KAAK,EAAEsiB,WAAW,EAAE+E,QAAQ,CAAC;EAC7ExE,IAAI,CAACjB,GAAG,GAAGwF,eAAe,CAACvE,IAAI,CAACjB,GAAG,EAAES,SAAS,EAAEriB,KAAK,EAAEsiB,WAAW,EAAE+E,QAAQ,CAAC;AACjF;AACA;AACA;AACA;AACA,SAASE,aAAaA,CAACpF,GAAG,EAAElvB,EAAE,EAAE;EAC5B,IAAI2I,CAAC,GAAG3I,EAAE,CAAC2I,CAAC;IAAEC,CAAC,GAAG5I,EAAE,CAAC4I,CAAC;EACtByrB,cAAc,CAACnF,GAAG,CAACvmB,CAAC,EAAEA,CAAC,CAACymB,SAAS,EAAEzmB,CAAC,CAACoE,KAAK,EAAEpE,CAAC,CAAC0mB,WAAW,CAAC;EAC1DgF,cAAc,CAACnF,GAAG,CAACtmB,CAAC,EAAEA,CAAC,CAACwmB,SAAS,EAAExmB,CAAC,CAACmE,KAAK,EAAEnE,CAAC,CAACymB,WAAW,CAAC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,SAASkF,mBAAmBA,CAACC,KAAK,EAAE5E,IAAI,EAAE6E,UAAU,EAAEz0B,EAAE,EAAE;EACtD,IAAIgJ,EAAE,GAAG7M,KAAK,CAACwhB,MAAM,CAAC3d,EAAE,EAAE,CAAC,CAAC;IAAEnB,GAAG,GAAGmK,EAAE,CAAC,CAAC,CAAC;IAAE0rB,QAAQ,GAAG1rB,EAAE,CAAC,CAAC,CAAC;IAAE2rB,SAAS,GAAG3rB,EAAE,CAAC,CAAC,CAAC;EAC9E;EACAwrB,KAAK,CAAC9F,GAAG,GAAGkB,IAAI,CAAClB,GAAG;EACpB8F,KAAK,CAAC7F,GAAG,GAAGiB,IAAI,CAACjB,GAAG;EACpB,IAAIiG,UAAU,GAAGH,UAAU,CAACE,SAAS,CAAC,KAAKvyB,SAAS,GAAGqyB,UAAU,CAACE,SAAS,CAAC,GAAG,GAAG;EAClF,IAAItF,WAAW,GAAG7yB,SAAS,CAAC+X,GAAG,CAACqb,IAAI,CAAClB,GAAG,EAAEkB,IAAI,CAACjB,GAAG,EAAEiG,UAAU,CAAC;EAC/D;EACAP,cAAc,CAACG,KAAK,EAAEC,UAAU,CAAC51B,GAAG,CAAC,EAAE41B,UAAU,CAACC,QAAQ,CAAC,EAAErF,WAAW,EAAEoF,UAAU,CAAC1nB,KAAK,CAAC;AAC/F;AACA;AACA;AACA;AACA,IAAI8nB,KAAK,GAAG,CAAC,GAAG,EAAE,QAAQ,EAAE,SAAS,CAAC;AACtC,IAAIC,KAAK,GAAG,CAAC,GAAG,EAAE,QAAQ,EAAE,SAAS,CAAC;AACtC;AACA;AACA;AACA,SAASC,kBAAkBA,CAACC,QAAQ,EAAE9F,GAAG,EAAEuF,UAAU,EAAE;EACnDF,mBAAmB,CAACS,QAAQ,CAACrsB,CAAC,EAAEumB,GAAG,CAACvmB,CAAC,EAAE8rB,UAAU,EAAEI,KAAK,CAAC;EACzDN,mBAAmB,CAACS,QAAQ,CAACpsB,CAAC,EAAEsmB,GAAG,CAACtmB,CAAC,EAAE6rB,UAAU,EAAEK,KAAK,CAAC;AAC7D;AACA;AACA;AACA;AACA,SAASG,gBAAgBA,CAAC9c,KAAK,EAAEiX,SAAS,EAAEriB,KAAK,EAAEsiB,WAAW,EAAE+E,QAAQ,EAAE;EACtEjc,KAAK,IAAIiX,SAAS;EAClBjX,KAAK,GAAG6b,UAAU,CAAC7b,KAAK,EAAE,CAAC,GAAGpL,KAAK,EAAEsiB,WAAW,CAAC;EACjD,IAAI+E,QAAQ,KAAKhyB,SAAS,EAAE;IACxB+V,KAAK,GAAG6b,UAAU,CAAC7b,KAAK,EAAE,CAAC,GAAGic,QAAQ,EAAE/E,WAAW,CAAC;EACxD;EACA,OAAOlX,KAAK;AAChB;AACA;AACA;AACA;AACA,SAAS+c,eAAeA,CAACtF,IAAI,EAAER,SAAS,EAAEriB,KAAK,EAAEmE,MAAM,EAAEkjB,QAAQ,EAAE;EAC/D,IAAIhF,SAAS,KAAK,KAAK,CAAC,EAAE;IAAEA,SAAS,GAAG,CAAC;EAAE;EAC3C,IAAIriB,KAAK,KAAK,KAAK,CAAC,EAAE;IAAEA,KAAK,GAAG,CAAC;EAAE;EACnC,IAAImE,MAAM,KAAK,KAAK,CAAC,EAAE;IAAEA,MAAM,GAAG,GAAG;EAAE;EACvC,IAAIme,WAAW,GAAG7yB,SAAS,CAAC+X,GAAG,CAACqb,IAAI,CAAClB,GAAG,EAAEkB,IAAI,CAACjB,GAAG,EAAEzd,MAAM,CAAC,GAAGke,SAAS;EACvEQ,IAAI,CAAClB,GAAG,GAAGuG,gBAAgB,CAACrF,IAAI,CAAClB,GAAG,EAAEU,SAAS,EAAEriB,KAAK,EAAEsiB,WAAW,EAAE+E,QAAQ,CAAC;EAC9ExE,IAAI,CAACjB,GAAG,GAAGsG,gBAAgB,CAACrF,IAAI,CAACjB,GAAG,EAAES,SAAS,EAAEriB,KAAK,EAAEsiB,WAAW,EAAE+E,QAAQ,CAAC;AAClF;AACA;AACA;AACA;AACA;AACA,SAASe,oBAAoBA,CAACvF,IAAI,EAAE6E,UAAU,EAAEz0B,EAAE,EAAE;EAChD,IAAIgJ,EAAE,GAAG7M,KAAK,CAACwhB,MAAM,CAAC3d,EAAE,EAAE,CAAC,CAAC;IAAEnB,GAAG,GAAGmK,EAAE,CAAC,CAAC,CAAC;IAAE0rB,QAAQ,GAAG1rB,EAAE,CAAC,CAAC,CAAC;IAAE2rB,SAAS,GAAG3rB,EAAE,CAAC,CAAC,CAAC;EAC9EksB,eAAe,CAACtF,IAAI,EAAE6E,UAAU,CAAC51B,GAAG,CAAC,EAAE41B,UAAU,CAACC,QAAQ,CAAC,EAAED,UAAU,CAACE,SAAS,CAAC,EAAEF,UAAU,CAAC1nB,KAAK,CAAC;AACzG;AACA;AACA;AACA;AACA;AACA,SAASqoB,mBAAmBA,CAAClG,GAAG,EAAEuF,UAAU,EAAE;EAC1CU,oBAAoB,CAACjG,GAAG,CAACvmB,CAAC,EAAE8rB,UAAU,EAAEI,KAAK,CAAC;EAC9CM,oBAAoB,CAACjG,GAAG,CAACtmB,CAAC,EAAE6rB,UAAU,EAAEK,KAAK,CAAC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASO,eAAeA,CAACnG,GAAG,EAAE1f,SAAS,EAAE8lB,QAAQ,EAAE;EAC/C,IAAIC,UAAU,GAAGD,QAAQ,CAACl2B,MAAM;EAChC,IAAI,CAACm2B,UAAU,EACX;EACJ;EACA/lB,SAAS,CAAC7G,CAAC,GAAG6G,SAAS,CAAC5G,CAAC,GAAG,CAAC;EAC7B,IAAI4sB,IAAI;EACR,IAAIhR,KAAK;EACT,KAAK,IAAI1kB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGy1B,UAAU,EAAEz1B,CAAC,EAAE,EAAE;IACjC01B,IAAI,GAAGF,QAAQ,CAACx1B,CAAC,CAAC;IAClB0kB,KAAK,GAAGgR,IAAI,CAAC7C,cAAc,EAAE,CAACnO,KAAK;IACnC;IACAhV,SAAS,CAAC7G,CAAC,IAAI6b,KAAK,CAAC7b,CAAC,CAACoE,KAAK;IAC5ByC,SAAS,CAAC5G,CAAC,IAAI4b,KAAK,CAAC5b,CAAC,CAACmE,KAAK;IAC5B;IACAunB,aAAa,CAACpF,GAAG,EAAE1K,KAAK,CAAC;IACzB;IACA,IAAIkP,WAAW,CAAC8B,IAAI,CAAC,EAAE;MACnBT,kBAAkB,CAAC7F,GAAG,EAAEA,GAAG,EAAEsG,IAAI,CAACC,eAAe,EAAE,CAAC;IACxD;EACJ;AACJ;;AAEA;AACA;AACA;AACA;AACA,SAASC,2BAA2BA,CAACp2B,aAAa,EAAEq2B,YAAY,EAAE;EAC9D,IAAIA,YAAY,KAAK,KAAK,CAAC,EAAE;IAAEA,YAAY,GAAG,IAAI;EAAE;EACpD,IAAIC,gBAAgB,GAAGt2B,aAAa,CAACu2B,mBAAmB,EAAE;EAC1D,IAAI,CAACD,gBAAgB,EACjB,OAAO,KAAK;EAChB,IAAIzkB,MAAM;EACV,IAAIwkB,YAAY,EAAE;IACdxkB,MAAM,GAAGkiB,kBAAkB,CAACuC,gBAAgB,CAACvnB,UAAU,CAACsB,MAAM,EAAErQ,aAAa,CAAC+O,UAAU,CAACsB,MAAM,CAAC;IAChGylB,mBAAmB,CAACjkB,MAAM,EAAEykB,gBAAgB,CAACH,eAAe,EAAE,CAAC;EACnE,CAAC,MACI;IACDtkB,MAAM,GAAGkiB,kBAAkB,CAACuC,gBAAgB,CAACjD,cAAc,EAAE,CAACnqB,MAAM,EAAElJ,aAAa,CAACqzB,cAAc,EAAE,CAACnqB,MAAM,CAAC;EAChH;EACA8mB,QAAQ,CAAC,UAAUM,IAAI,EAAE;IACrB,OAAOtwB,aAAa,CAACw2B,uBAAuB,CAAClG,IAAI,EAAEze,MAAM,CAACye,IAAI,CAAC,CAAClB,GAAG,EAAEvd,MAAM,CAACye,IAAI,CAAC,CAACjB,GAAG,EAAE,IAAI,CAAC;EAChG,CAAC,CAAC;EACF,OAAO,IAAI;AACf;AAEA,IAAIoH,cAAc,GAAG,IAAI5tB,GAAG,EAAE;AAC9B,SAAS6tB,OAAOA,CAACC,KAAK,EAAEC,GAAG,EAAEC,OAAO,EAAE;EAClC,IAAI,CAACF,KAAK,CAACE,OAAO,CAAC,EACfF,KAAK,CAACE,OAAO,CAAC,GAAG,EAAE;EACvBF,KAAK,CAACE,OAAO,CAAC,CAACl2B,IAAI,CAACi2B,GAAG,CAAC;AAC5B;AACA,SAASE,WAAWA,CAAC3b,QAAQ,EAAE;EAC3Bsb,cAAc,CAAC1S,GAAG,CAAC5I,QAAQ,CAAC;EAC5B,OAAO,YAAY;IAAE,OAAOsb,cAAc,CAAChK,MAAM,CAACtR,QAAQ,CAAC;EAAE,CAAC;AAClE;AACA,SAAS4b,WAAWA,CAAA,EAAG;EACnB,IAAI,CAACN,cAAc,CAACpqB,IAAI,EACpB;EACJ,IAAIwqB,OAAO,GAAG,CAAC;EACf,IAAIG,KAAK,GAAG,CAAC,EAAE,CAAC;EAChB,IAAIC,MAAM,GAAG,EAAE;EACf,IAAIC,OAAO,GAAG,SAAAA,CAAUN,GAAG,EAAE;IAAE,OAAOF,OAAO,CAACM,KAAK,EAAEJ,GAAG,EAAEC,OAAO,CAAC;EAAE,CAAC;EACrE,IAAIM,QAAQ,GAAG,SAAAA,CAAUP,GAAG,EAAE;IAC1BF,OAAO,CAACO,MAAM,EAAEL,GAAG,EAAEC,OAAO,CAAC;IAC7BA,OAAO,EAAE;EACb,CAAC;EACD;AACJ;AACA;EACIJ,cAAc,CAAC94B,OAAO,CAAC,UAAUwd,QAAQ,EAAE;IACvCA,QAAQ,CAAC+b,OAAO,EAAEC,QAAQ,CAAC;IAC3BN,OAAO,GAAG,CAAC;EACf,CAAC,CAAC;EACFJ,cAAc,CAACpS,KAAK,EAAE;EACtB;AACJ;AACA;EACI,IAAI+S,SAAS,GAAGH,MAAM,CAACn3B,MAAM;EAC7B,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI42B,SAAS,EAAE52B,CAAC,EAAE,EAAE;IACjCw2B,KAAK,CAACx2B,CAAC,CAAC,IAAIw2B,KAAK,CAACx2B,CAAC,CAAC,CAAC7C,OAAO,CAAC05B,UAAU,CAAC;IACxCJ,MAAM,CAACz2B,CAAC,CAAC,IAAIy2B,MAAM,CAACz2B,CAAC,CAAC,CAAC7C,OAAO,CAAC05B,UAAU,CAAC;EAC9C;AACJ;AACA,IAAIA,UAAU,GAAG,SAAAA,CAAUT,GAAG,EAAE;EAAE,OAAOA,GAAG,EAAE;AAAE,CAAC;AAEjD,IAAIU,mBAAmB,GAAG,IAAIC,OAAO,EAAE;AACvC;AACA;AACA;AACA,IAAIC,gBAAgB;AACpB,IAAIC,yBAAyB,GAAG,aAAe,YAAY;EACvD,SAASA,yBAAyBA,CAAC/2B,EAAE,EAAE;IACnC,IAAIV,aAAa,GAAGU,EAAE,CAACV,aAAa;IACpC;AACR;AACA;AACA;AACA;IACQ,IAAI,CAAC03B,UAAU,GAAG,KAAK;IACvB;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACC,gBAAgB,GAAG,IAAI;IAC5B;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACtG,WAAW,GAAG,KAAK;IACxB;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACF,OAAO,GAAGzB,OAAO,EAAE;IACxB;AACR;AACA;AACA;AACA;IACQ,IAAI,CAAClxB,KAAK,GAAG,CAAC,CAAC;IACf;AACR;AACA;IACQ,IAAI,CAACo5B,qBAAqB,GAAG,KAAK;IAClC;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,cAAc,GAAG;MAClBxuB,CAAC,EAAE,GAAG;MACNC,CAAC,EAAE;IACP,CAAC;IACD;IACA;IACA,IAAI,CAACymB,WAAW,GAAG,CAAC,CAAC;IACrB;IACA;IACA;IACA,IAAI,CAAC+H,cAAc,GAAG,IAAI;IAC1B;AACR;AACA;IACQ,IAAI,CAACC,UAAU,GAAG,IAAI;IACtB,IAAI,CAAC/3B,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACA,aAAa,CAACg4B,sBAAsB,EAAE;IAC3CV,mBAAmB,CAAC3vB,GAAG,CAAC3H,aAAa,EAAE,IAAI,CAAC;EAChD;EACA;AACJ;AACA;AACA;AACA;EACIy3B,yBAAyB,CAACxzB,SAAS,CAAC6B,KAAK,GAAG,UAAUmyB,WAAW,EAAEv3B,EAAE,EAAE;IACnE,IAAIsjB,KAAK,GAAG,IAAI;IAChB,IAAIta,EAAE,GAAGhJ,EAAE,KAAK,KAAK,CAAC,GAAG,CAAC,CAAC,GAAGA,EAAE;MAAEqJ,EAAE,GAAGL,EAAE,CAACwuB,YAAY;MAAEA,YAAY,GAAGnuB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,GAAGA,EAAE;MAAE8tB,cAAc,GAAGnuB,EAAE,CAACmuB,cAAc;IACrI,IAAItJ,cAAc,GAAG,SAAAA,CAAU5W,KAAK,EAAE;MAClC,IAAIjX,EAAE;MACN;MACA;MACAsjB,KAAK,CAACmU,UAAU,EAAE;MAClB;AACZ;AACA;AACA;AACA;MACY,IAAIC,YAAY,GAAGpf,yBAAyB,CAACrB,KAAK,CAAC,CAACkB,KAAK;MACzD,CAACnY,EAAE,GAAGsjB,KAAK,CAACqU,YAAY,MAAM,IAAI,IAAI33B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACyD,IAAI,CAAC6f,KAAK,CAAC;MAC7EA,KAAK,CAACqU,YAAY,GAAGvB,WAAW,CAAC,UAAUwB,IAAI,EAAEC,KAAK,EAAE;QACpD,IAAIvF,SAAS,GAAGD,0BAA0B,CAAC/O,KAAK,CAAChkB,aAAa,CAAC;QAC/D,IAAIkzB,QAAQ,GAAGD,yBAAyB,CAACjP,KAAK,CAAChkB,aAAa,CAAC;QAC7D,IAAIw4B,IAAI,GAAG37B,KAAK,CAACulB,aAAa,CAACvlB,KAAK,CAACulB,aAAa,CAAC,EAAE,EAAEvlB,KAAK,CAACwhB,MAAM,CAAC2U,SAAS,CAAC,CAAC,EAAEn2B,KAAK,CAACwhB,MAAM,CAAC6U,QAAQ,CAAC,CAAC;QACxG,IAAIuF,0BAA0B,GAAG,KAAK;QACtC;AAChB;AACA;AACA;QACgBzU,KAAK,CAACqS,YAAY,EAAE,IAAIrS,KAAK,CAAChkB,aAAa,CAAC04B,oBAAoB,EAAE;QAClEH,KAAK,CAAC,YAAY;UACdC,IAAI,CAAC76B,OAAO,CAAC,UAAUwW,OAAO,EAAE;YAAE,OAAOA,OAAO,CAACwkB,cAAc,EAAE;UAAE,CAAC,CAAC;QACzE,CAAC,CAAC;QACFL,IAAI,CAAC,YAAY;UACblF,uBAAuB,CAACpP,KAAK,CAAChkB,aAAa,CAAC;UAC5CkzB,QAAQ,CAACv1B,OAAO,CAACy1B,uBAAuB,CAAC;QAC7C,CAAC,CAAC;QACFmF,KAAK,CAAC,YAAY;UACdC,IAAI,CAAC76B,OAAO,CAAC,UAAUwW,OAAO,EAAE;YAAE,OAAOA,OAAO,CAACykB,gBAAgB,EAAE;UAAE,CAAC,CAAC;UACvE,IAAIV,YAAY,EAAE;YACdO,0BAA0B,GAAGzU,KAAK,CAACkU,YAAY,CAACE,YAAY,CAAC;UACjE;QACJ,CAAC,CAAC;QACFE,IAAI,CAAC,YAAY;UACb,IAAIO,cAAc,GAAGzyB,OAAO,CAAC4d,KAAK,CAAC8U,kBAAkB,CAAC,GAAG,CAAC,IAAI,CAAC9U,KAAK,CAAC+U,cAAc,EAAE,CAAC;UACtF,IAAI,CAACF,cAAc,EAAE;YACjB7U,KAAK,CAAChkB,aAAa,CAAC2zB,sBAAsB,CAAC,IAAI,EAAE3P,KAAK,CAAChkB,aAAa,CAACuzB,kBAAkB,CAAC,KAAK,CAAC,CAAC;UACnG;UACAvP,KAAK,CAAChkB,aAAa,CAACg5B,8BAA8B,EAAE;UACpD;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;UACoB,IAAIjqB,UAAU,GAAGiV,KAAK,CAAChkB,aAAa,CAAC+O,UAAU;UAC/CihB,QAAQ,CAAC,UAAUM,IAAI,EAAE;YACrB,IAAI,CAACmI,0BAA0B,EAAE;cAC7B,IAAI/3B,EAAE,GAAGqO,UAAU,CAACsB,MAAM,CAACigB,IAAI,CAAC;gBAAElB,GAAG,GAAG1uB,EAAE,CAAC0uB,GAAG;gBAAEC,GAAG,GAAG3uB,EAAE,CAAC2uB,GAAG;cAC5DrL,KAAK,CAAC6T,cAAc,CAACvH,IAAI,CAAC,GAAGuH,cAAc,GACrCA,cAAc,CAACvH,IAAI,CAAC,GACpBpzB,SAAS,CAACiV,QAAQ,CAACid,GAAG,EAAEC,GAAG,EAAE+I,YAAY,CAAC9H,IAAI,CAAC,CAAC;YAC1D;YACA;AACxB;AACA;AACA;YACwB,IAAI2I,SAAS,GAAGjV,KAAK,CAAC8U,kBAAkB,CAACxI,IAAI,CAAC;YAC9C,IAAI2I,SAAS,EAAE;cACXjV,KAAK,CAAC+L,WAAW,CAACO,IAAI,CAAC,GAAG2I,SAAS,CAACl7B,GAAG,EAAE;YAC7C;UACJ,CAAC,CAAC;QACN,CAAC,CAAC;QACFw6B,KAAK,CAAC,YAAY;UACdp7B,IAAI,CAAC+7B,SAAS,CAACjL,MAAM,EAAE;UACvB9wB,IAAI,CAAC+7B,SAAS,CAACC,SAAS,EAAE;UAC1Bh8B,IAAI,CAAC+7B,SAAS,CAAClU,MAAM,EAAE;UACvB7nB,IAAI,CAAC+7B,SAAS,CAAC9T,UAAU,EAAE;QAC/B,CAAC,CAAC;QACFkT,IAAI,CAAC,YAAY;UAAE,OAAOtU,KAAK,CAACoV,sBAAsB,EAAE;QAAE,CAAC,CAAC;MAChE,CAAC,CAAC;IACN,CAAC;IACD,IAAIzL,OAAO,GAAG,SAAAA,CAAUhW,KAAK,EAAEyD,IAAI,EAAE;MACjC,IAAI1a,EAAE,EAAEgJ,EAAE,EAAEK,EAAE;MACd;MACA,IAAIE,EAAE,GAAG+Z,KAAK,CAACxlB,KAAK;QAAEO,IAAI,GAAGkL,EAAE,CAAClL,IAAI;QAAEs6B,eAAe,GAAGpvB,EAAE,CAACovB,eAAe;MAC1E,IAAIt6B,IAAI,IAAI,CAACs6B,eAAe,EAAE;QAC1B,IAAIrV,KAAK,CAAC8T,cAAc,EACpB9T,KAAK,CAAC8T,cAAc,EAAE;QAC1B9T,KAAK,CAAC8T,cAAc,GAAGld,aAAa,CAAC7b,IAAI,CAAC;QAC1C;QACA,IAAI,CAACilB,KAAK,CAAC8T,cAAc,EACrB;MACR;MACAf,WAAW,EAAE;MACb;MACA/S,KAAK,CAAC0T,UAAU,GAAG,IAAI;MACvB1T,KAAK,CAAC2T,gBAAgB,GAAG,IAAI;MAC7B;MACA,CAACjuB,EAAE,GAAG,CAAChJ,EAAE,GAAGsjB,KAAK,CAACxlB,KAAK,EAAE86B,WAAW,MAAM,IAAI,IAAI5vB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACvF,IAAI,CAACzD,EAAE,EAAEiX,KAAK,EAAEyD,IAAI,CAAC;MACnG,CAACrR,EAAE,GAAGia,KAAK,CAAChkB,aAAa,CAAC6D,cAAc,MAAM,IAAI,IAAIkG,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACwN,SAAS,CAACT,aAAa,CAACwT,IAAI,EAAE,IAAI,CAAC;IACzH,CAAC;IACD,IAAIsD,MAAM,GAAG,SAAAA,CAAUjW,KAAK,EAAEyD,IAAI,EAAE;MAChC,IAAI1a,EAAE,EAAEgJ,EAAE,EAAEK,EAAE,EAAEE,EAAE;MAClB,IAAIsf,EAAE,GAAGvF,KAAK,CAACxlB,KAAK;QAAE66B,eAAe,GAAG9P,EAAE,CAAC8P,eAAe;QAAEE,iBAAiB,GAAGhQ,EAAE,CAACgQ,iBAAiB;MACpG;MACA,IAAI,CAACF,eAAe,IAAI,CAACrV,KAAK,CAAC8T,cAAc,EACzC;MACJ,IAAIjmB,MAAM,GAAGuJ,IAAI,CAACvJ,MAAM;MACxB;MACA,IAAI0nB,iBAAiB,IAAIvV,KAAK,CAAC2T,gBAAgB,KAAK,IAAI,EAAE;QACtD3T,KAAK,CAAC2T,gBAAgB,GAAG6B,mBAAmB,CAAC3nB,MAAM,CAAC;QACpD;QACA,IAAImS,KAAK,CAAC2T,gBAAgB,KAAK,IAAI,EAAE;UACjC,CAACjuB,EAAE,GAAG,CAAChJ,EAAE,GAAGsjB,KAAK,CAACxlB,KAAK,EAAEi7B,eAAe,MAAM,IAAI,IAAI/vB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACvF,IAAI,CAACzD,EAAE,EAAEsjB,KAAK,CAAC2T,gBAAgB,CAAC;QACtH;QACA;MACJ;MACA;MACA3T,KAAK,CAAC0V,UAAU,CAAC,GAAG,EAAEte,IAAI,CAACvC,KAAK,EAAEhH,MAAM,CAAC;MACzCmS,KAAK,CAAC0V,UAAU,CAAC,GAAG,EAAEte,IAAI,CAACvC,KAAK,EAAEhH,MAAM,CAAC;MACzC;MACA,CAAC5H,EAAE,GAAG,CAACF,EAAE,GAAGia,KAAK,CAACxlB,KAAK,EAAEm7B,MAAM,MAAM,IAAI,IAAI1vB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC9F,IAAI,CAAC4F,EAAE,EAAE4N,KAAK,EAAEyD,IAAI,CAAC;MAC9F;MACAoc,gBAAgB,GAAG7f,KAAK;IAC5B,CAAC;IACD,IAAIyW,YAAY,GAAG,SAAAA,CAAUzW,KAAK,EAAEyD,IAAI,EAAE;MACtC,OAAO4I,KAAK,CAAClB,IAAI,CAACnL,KAAK,EAAEyD,IAAI,CAAC;IAClC,CAAC;IACD,IAAIra,kBAAkB,GAAG,IAAI,CAACvC,KAAK,CAACuC,kBAAkB;IACtD,IAAI,CAACg3B,UAAU,GAAG,IAAI9K,UAAU,CAACgL,WAAW,EAAE;MAC1C1J,cAAc,EAAEA,cAAc;MAC9BZ,OAAO,EAAEA,OAAO;MAChBC,MAAM,EAAEA,MAAM;MACdQ,YAAY,EAAEA;IAClB,CAAC,EAAE;MAAErtB,kBAAkB,EAAEA;IAAmB,CAAC,CAAC;EAClD,CAAC;EACD02B,yBAAyB,CAACxzB,SAAS,CAACm1B,sBAAsB,GAAG,YAAY;IACrE,IAAIpV,KAAK,GAAG,IAAI;IAChB,IAAItjB,EAAE,GAAG,IAAI,CAAClC,KAAK;MAAEo7B,eAAe,GAAGl5B,EAAE,CAACk5B,eAAe;MAAExH,WAAW,GAAG1xB,EAAE,CAAC0xB,WAAW;IACvF,IAAIlpB,MAAM,GAAG,IAAI,CAAClJ,aAAa,CAACqzB,cAAc,EAAE,CAACG,eAAe;IAChE,IAAIoG,eAAe,EAAE;MACjB,IAAI,CAACvI,WAAW,GAAGrtB,WAAW,CAAC41B,eAAe,CAAC,GACzC,IAAI,CAACC,qBAAqB,CAAC3wB,MAAM,EAAE0wB,eAAe,CAAC,GACnDrI,uBAAuB,CAACroB,MAAM,EAAE0wB,eAAe,CAAC;IAC1D,CAAC,MACI;MACD,IAAI,CAACvI,WAAW,GAAG,KAAK;IAC5B;IACA,IAAI,CAACF,OAAO,GAAGgB,kBAAkB,CAACC,WAAW,CAAC;IAC9C;AACR;AACA;AACA;IACQ,IAAI,IAAI,CAACf,WAAW,IAAI,CAAC,IAAI,CAACuG,qBAAqB,EAAE;MACjD5H,QAAQ,CAAC,UAAUM,IAAI,EAAE;QACrB,IAAItM,KAAK,CAAC8U,kBAAkB,CAACxI,IAAI,CAAC,EAAE;UAChCtM,KAAK,CAACqN,WAAW,CAACf,IAAI,CAAC,GAAG0B,qBAAqB,CAAC9oB,MAAM,CAAConB,IAAI,CAAC,EAAEtM,KAAK,CAACqN,WAAW,CAACf,IAAI,CAAC,CAAC;QAC1F;MACJ,CAAC,CAAC;IACN;EACJ,CAAC;EACDmH,yBAAyB,CAACxzB,SAAS,CAAC41B,qBAAqB,GAAG,UAAUrI,SAAS,EAAEH,WAAW,EAAE;IAC1F,IAAI3wB,EAAE,GAAG,IAAI,CAAClC,KAAK;MAAEs7B,wBAAwB,GAAGp5B,EAAE,CAACo5B,wBAAwB;MAAE/4B,kBAAkB,GAAGL,EAAE,CAACK,kBAAkB;IACvH,IAAIg5B,kBAAkB,GAAG1I,WAAW,CAAC5vB,OAAO;IAC5CzE,SAAS,CAACuD,SAAS,CAACw5B,kBAAkB,KAAK,IAAI,EAAE,wGAAwG,CAAC;IAC1J,IAAI,CAAClI,cAAc,GAAGa,cAAc,CAACqH,kBAAkB,EAAEh5B,kBAAkB,CAAC;IAC5E,IAAIi5B,mBAAmB,GAAGpI,uBAAuB,CAACJ,SAAS,EAAE,IAAI,CAACK,cAAc,CAAC;IACjF;AACR;AACA;AACA;IACQ,IAAIiI,wBAAwB,EAAE;MAC1B,IAAIG,eAAe,GAAGH,wBAAwB,CAACxK,2BAA2B,CAAC0K,mBAAmB,CAAC,CAAC;MAChG,IAAI,CAACpC,qBAAqB,GAAG,CAAC,CAACqC,eAAe;MAC9C,IAAIA,eAAe,EAAE;QACjBD,mBAAmB,GAAG7K,2BAA2B,CAAC8K,eAAe,CAAC;MACtE;IACJ;IACA,OAAOD,mBAAmB;EAC9B,CAAC;EACDvC,yBAAyB,CAACxzB,SAAS,CAACi2B,UAAU,GAAG,YAAY;IACzD,IAAIx5B,EAAE,EAAEgJ,EAAE;IACV,IAAI,CAAC1J,aAAa,CAACm6B,sBAAsB,EAAE;IAC3C,CAACz5B,EAAE,GAAG,IAAI,CAAC23B,YAAY,MAAM,IAAI,IAAI33B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACyD,IAAI,CAAC,IAAI,CAAC;IAC3E,IAAI,CAACuzB,UAAU,GAAG,KAAK;IACvB,IAAI,CAACK,UAAU,IAAI,IAAI,CAACA,UAAU,CAAC7J,GAAG,EAAE;IACxC,IAAI,CAAC6J,UAAU,GAAG,IAAI;IACtB,IAAI,CAAC,IAAI,CAACv5B,KAAK,CAAC66B,eAAe,IAAI,IAAI,CAACvB,cAAc,EAAE;MACpD,IAAI,CAACA,cAAc,EAAE;MACrB,IAAI,CAACA,cAAc,GAAG,IAAI;IAC9B;IACA,CAACpuB,EAAE,GAAG,IAAI,CAAC1J,aAAa,CAAC6D,cAAc,MAAM,IAAI,IAAI6F,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC6N,SAAS,CAACT,aAAa,CAACwT,IAAI,EAAE,KAAK,CAAC;EACzH,CAAC;EACDmN,yBAAyB,CAACxzB,SAAS,CAAC6e,IAAI,GAAG,UAAUnL,KAAK,EAAEyD,IAAI,EAAE;IAC9D,IAAI1a,EAAE,EAAEgJ,EAAE,EAAEK,EAAE;IACd,CAACrJ,EAAE,GAAG,IAAI,CAACq3B,UAAU,MAAM,IAAI,IAAIr3B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACwtB,GAAG,EAAE;IACpE,IAAI,CAAC6J,UAAU,GAAG,IAAI;IACtB,IAAIL,UAAU,GAAG,IAAI,CAACA,UAAU;IAChC,IAAI,CAACwC,UAAU,EAAE;IACjB,IAAI,CAACxC,UAAU,EACX;IACJ,IAAIxyB,QAAQ,GAAGkW,IAAI,CAAClW,QAAQ;IAC5B,IAAI,CAACk1B,cAAc,CAACl1B,QAAQ,CAAC;IAC7B,CAAC6E,EAAE,GAAG,CAACL,EAAE,GAAG,IAAI,CAAClL,KAAK,EAAE67B,SAAS,MAAM,IAAI,IAAItwB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC5F,IAAI,CAACuF,EAAE,EAAEiO,KAAK,EAAEyD,IAAI,CAAC;EACpG,CAAC;EACDqc,yBAAyB,CAACxzB,SAAS,CAACi0B,YAAY,GAAG,UAAUrf,KAAK,EAAE;IAChE,IAAImL,KAAK,GAAG,IAAI;IAChB,OAAOgM,QAAQ,CAAC,UAAUM,IAAI,EAAE;MAC5B,IAAIvxB,IAAI,GAAGilB,KAAK,CAACxlB,KAAK,CAACO,IAAI;MAC3B;MACA,IAAI,CAACu7B,UAAU,CAAChK,IAAI,EAAEvxB,IAAI,EAAEilB,KAAK,CAAC2T,gBAAgB,CAAC,EAC/C;MACJ,IAAIsB,SAAS,GAAGjV,KAAK,CAAC8U,kBAAkB,CAACxI,IAAI,CAAC;MAC9C,IAAI2I,SAAS,EAAE;QACX,IAAIrJ,GAAG,GAAG5L,KAAK,CAAChkB,aAAa,CAACqzB,cAAc,EAAE,CAACnqB,MAAM;QACrD,IAAIqxB,QAAQ,GAAG3K,GAAG,CAACU,IAAI,CAAC,CAACjB,GAAG,GAAGO,GAAG,CAACU,IAAI,CAAC,CAAClB,GAAG;QAC5C,IAAIoL,MAAM,GAAG5K,GAAG,CAACU,IAAI,CAAC,CAAClB,GAAG,GAAGmL,QAAQ,GAAG,CAAC;QACzC,IAAI1oB,MAAM,GAAGgH,KAAK,CAACyX,IAAI,CAAC,GAAGkK,MAAM;QACjCxW,KAAK,CAAC+L,WAAW,CAACO,IAAI,CAAC,GAAGzX,KAAK,CAACyX,IAAI,CAAC;QACrC2I,SAAS,CAACtxB,GAAG,CAACkK,MAAM,CAAC;MACzB,CAAC,MACI;QACDmS,KAAK,CAAC6T,cAAc,CAACvH,IAAI,CAAC,GAAG,GAAG;QAChC,OAAO,IAAI;MACf;IACJ,CAAC,CAAC,CAACxoB,QAAQ,CAAC,IAAI,CAAC;EACrB,CAAC;EACD;AACJ;AACA;EACI2vB,yBAAyB,CAACxzB,SAAS,CAACy1B,UAAU,GAAG,UAAUpJ,IAAI,EAAEzX,KAAK,EAAEhH,MAAM,EAAE;IAC5E,IAAI9S,IAAI,GAAG,IAAI,CAACP,KAAK,CAACO,IAAI;IAC1B;IACA,IAAI,CAACu7B,UAAU,CAAChK,IAAI,EAAEvxB,IAAI,EAAE,IAAI,CAAC44B,gBAAgB,CAAC,EAC9C;IACJ,OAAO,IAAI,CAACmB,kBAAkB,CAACxI,IAAI,CAAC,GAC9B,IAAI,CAACmK,qBAAqB,CAACnK,IAAI,EAAEze,MAAM,CAAC,GACxC,IAAI,CAAC6oB,uBAAuB,CAACpK,IAAI,EAAEzX,KAAK,CAAC;EACnD,CAAC;EACD4e,yBAAyB,CAACxzB,SAAS,CAACw2B,qBAAqB,GAAG,UAAUnK,IAAI,EAAEze,MAAM,EAAE;IAChF,IAAIonB,SAAS,GAAG,IAAI,CAACH,kBAAkB,CAACxI,IAAI,CAAC;IAC7C,IAAI,CAACze,MAAM,IAAI,CAAConB,SAAS,EACrB;IACJ,IAAI0B,SAAS,GAAG,IAAI,CAAC5K,WAAW,CAACO,IAAI,CAAC,GAAGze,MAAM,CAACye,IAAI,CAAC;IACrD,IAAIrC,MAAM,GAAG,IAAI,CAACoD,WAAW,GACvBH,gBAAgB,CAACyJ,SAAS,EAAE,IAAI,CAACtJ,WAAW,CAACf,IAAI,CAAC,EAAE,IAAI,CAACa,OAAO,CAACb,IAAI,CAAC,CAAC,GACvEqK,SAAS;IACf1B,SAAS,CAACtxB,GAAG,CAACsmB,MAAM,CAAC;EACzB,CAAC;EACDwJ,yBAAyB,CAACxzB,SAAS,CAACy2B,uBAAuB,GAAG,UAAUpK,IAAI,EAAEzX,KAAK,EAAE;IACjF,IAAInY,EAAE;IACN;IACA,IAAIk6B,UAAU,GAAG,IAAI,CAAC56B,aAAa,CAACqzB,cAAc,EAAE,CAACnqB,MAAM,CAAConB,IAAI,CAAC;IACjE;IACA;IACA,IAAIyB,UAAU,GAAG6I,UAAU,CAACvL,GAAG,GAAGuL,UAAU,CAACxL,GAAG;IAChD;IACA,IAAIyL,YAAY,GAAG,IAAI,CAAChD,cAAc,CAACvH,IAAI,CAAC;IAC5C;IACA,IAAIlB,GAAG,GAAGgC,uBAAuB,CAACvY,KAAK,CAACyX,IAAI,CAAC,EAAEyB,UAAU,EAAE8I,YAAY,EAAE,CAACn6B,EAAE,GAAG,IAAI,CAAC2wB,WAAW,MAAM,IAAI,IAAI3wB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC4vB,IAAI,CAAC,EAAE,IAAI,CAACa,OAAO,CAACb,IAAI,CAAC,CAAC;IACnK;IACA,IAAI,CAACtwB,aAAa,CAACw2B,uBAAuB,CAAClG,IAAI,EAAElB,GAAG,EAAEA,GAAG,GAAG2C,UAAU,CAAC;EAC3E,CAAC;EACD0F,yBAAyB,CAACxzB,SAAS,CAACP,QAAQ,GAAG,UAAUhD,EAAE,EAAE;IACzD,IAAIgJ,EAAE,GAAGhJ,EAAE,CAAC3B,IAAI;MAAEA,IAAI,GAAG2K,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,GAAGA,EAAE;MAAEK,EAAE,GAAGrJ,EAAE,CAAC64B,iBAAiB;MAAEA,iBAAiB,GAAGxvB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,GAAGA,EAAE;MAAEE,EAAE,GAAGvJ,EAAE,CAAC24B,eAAe;MAAEA,eAAe,GAAGpvB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,GAAGA,EAAE;MAAEsf,EAAE,GAAG7oB,EAAE,CAACk5B,eAAe;MAAEA,eAAe,GAAGrQ,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,GAAGA,EAAE;MAAEC,EAAE,GAAG9oB,EAAE,CAAC0xB,WAAW;MAAEA,WAAW,GAAG5I,EAAE,KAAK,KAAK,CAAC,GAAG0I,cAAc,GAAG1I,EAAE;MAAEsR,EAAE,GAAGp6B,EAAE,CAACq6B,YAAY;MAAEA,YAAY,GAAGD,EAAE,KAAK,KAAK,CAAC,GAAG,IAAI,GAAGA,EAAE;MAAEE,cAAc,GAAGn+B,KAAK,CAACsW,MAAM,CAACzS,EAAE,EAAE,CAAC,MAAM,EAAE,mBAAmB,EAAE,iBAAiB,EAAE,iBAAiB,EAAE,aAAa,EAAE,cAAc,CAAC,CAAC;IAC3hB,IAAI,CAAClC,KAAK,GAAG3B,KAAK,CAACgE,QAAQ,CAAC;MAAE9B,IAAI,EAAEA,IAAI;MACpCw6B,iBAAiB,EAAEA,iBAAiB;MACpCF,eAAe,EAAEA,eAAe;MAChCO,eAAe,EAAEA,eAAe;MAChCxH,WAAW,EAAEA,WAAW;MACxB2I,YAAY,EAAEA;IAAa,CAAC,EAAEC,cAAc,CAAC;EACrD,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIvD,yBAAyB,CAACxzB,SAAS,CAAC60B,kBAAkB,GAAG,UAAUxI,IAAI,EAAE;IACrE,IAAI5vB,EAAE,GAAG,IAAI,CAAClC,KAAK;MAAE0K,MAAM,GAAGxI,EAAE,CAACwI,MAAM;MAAEtG,QAAQ,GAAGlC,EAAE,CAACkC,QAAQ;IAC/D,IAAIq4B,OAAO,GAAG,OAAO,GAAG3K,IAAI,CAACzb,WAAW,EAAE;IAC1C,IAAI,IAAI,CAACrW,KAAK,CAACy8B,OAAO,CAAC,EAAE;MACrB,OAAO,IAAI,CAACz8B,KAAK,CAACy8B,OAAO,CAAC;IAC9B,CAAC,MACI,IAAI,CAAC/xB,MAAM,IAAItG,QAAQ,KAAKE,SAAS,EAAE;MACxC,OAAO,IAAI,CAAC9C,aAAa,CAACqnB,QAAQ,CAACiJ,IAAI,EAAE,CAAC,CAAC;IAC/C;EACJ,CAAC;EACDmH,yBAAyB,CAACxzB,SAAS,CAACoyB,YAAY,GAAG,YAAY;IAC3D,OAAO,CAAC,IAAI,CAACyC,kBAAkB,CAAC,GAAG,CAAC;EACxC,CAAC;EACDrB,yBAAyB,CAACxzB,SAAS,CAAC80B,cAAc,GAAG,YAAY;IAC7D,IAAIr4B,EAAE,GAAG,IAAI,CAAClC,KAAK;MAAE61B,MAAM,GAAG3zB,EAAE,CAAC2zB,MAAM;MAAE6G,MAAM,GAAGx6B,EAAE,CAACw6B,MAAM;IAC3D,OAAO7G,MAAM,IAAI6G,MAAM;EAC3B,CAAC;EACDzD,yBAAyB,CAACxzB,SAAS,CAACm2B,cAAc,GAAG,UAAUl1B,QAAQ,EAAE;IACrE,IAAI8e,KAAK,GAAG,IAAI;IAChB,IAAItjB,EAAE,GAAG,IAAI,CAAClC,KAAK;MAAEO,IAAI,GAAG2B,EAAE,CAAC3B,IAAI;MAAEg8B,YAAY,GAAGr6B,EAAE,CAACq6B,YAAY;MAAE3I,WAAW,GAAG1xB,EAAE,CAAC0xB,WAAW;MAAE+I,cAAc,GAAGz6B,EAAE,CAACy6B,cAAc;IACrI;AACR;AACA;AACA;IACQ,IAAIC,UAAU,GAAGhF,2BAA2B,CAAC,IAAI,CAACp2B,aAAa,EAAE,IAAI,CAACq2B,YAAY,EAAE,IAAI,CAAC,IAAI,CAAC0C,cAAc,EAAE,CAAC;IAC/G;AACR;AACA;AACA;IACQ,IAAI1H,WAAW,GAAG,IAAI,CAACA,WAAW,IAAI,CAAC,CAAC;IACxC,IAAI+J,UAAU,IACV3+B,MAAM,CAACiB,IAAI,CAAC2zB,WAAW,CAAC,CAACvxB,MAAM,IAC/B,IAAI,CAACu2B,YAAY,EAAE,EAAE;MACrB,IAAIC,gBAAgB,GAAG,IAAI,CAACt2B,aAAa,CAACu2B,mBAAmB,EAAE;MAC/D,IAAID,gBAAgB,EAAE;QAClB,IAAI+E,qBAAqB,GAAGtH,kBAAkB,CAACuC,gBAAgB,CAACvnB,UAAU,CAACusB,WAAW,EAAEjK,WAAW,CAAC;QACpGrB,QAAQ,CAAC,UAAUM,IAAI,EAAE;UACrB,IAAI5vB,EAAE,GAAG26B,qBAAqB,CAAC/K,IAAI,CAAC;YAAElB,GAAG,GAAG1uB,EAAE,CAAC0uB,GAAG;YAAEC,GAAG,GAAG3uB,EAAE,CAAC2uB,GAAG;UAChEgC,WAAW,CAACf,IAAI,CAAC,GAAG;YAChBlB,GAAG,EAAE7K,KAAK,CAAC6K,GAAG,CAAC,GAAGtsB,SAAS,GAAGssB,GAAG;YACjCC,GAAG,EAAE9K,KAAK,CAAC8K,GAAG,CAAC,GAAGvsB,SAAS,GAAGusB;UAClC,CAAC;QACL,CAAC,CAAC;MACN;IACJ;IACA,IAAIkM,kBAAkB,GAAGvL,QAAQ,CAAC,UAAUM,IAAI,EAAE;MAC9C,IAAI5vB,EAAE;MACN,IAAI,CAAC45B,UAAU,CAAChK,IAAI,EAAEvxB,IAAI,EAAEilB,KAAK,CAAC2T,gBAAgB,CAAC,EAAE;QACjD;MACJ;MACA,IAAIvhB,UAAU,GAAG,CAAC1V,EAAE,GAAG2wB,WAAW,KAAK,IAAI,IAAIA,WAAW,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,WAAW,CAACf,IAAI,CAAC,MAAM,IAAI,IAAI5vB,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,CAAC,CAAC;MACvI;AACZ;AACA;AACA;AACA;AACA;MACY,IAAI86B,eAAe,GAAGpJ,WAAW,GAAG,GAAG,GAAG,OAAO;MACjD,IAAIqJ,aAAa,GAAGrJ,WAAW,GAAG,EAAE,GAAG,QAAQ;MAC/C,IAAIvP,OAAO,GAAGhmB,KAAK,CAACgE,QAAQ,CAAChE,KAAK,CAACgE,QAAQ,CAAC;QAAEkK,IAAI,EAAE,SAAS;QAAE7F,QAAQ,EAAE61B,YAAY,GAAG71B,QAAQ,CAACorB,IAAI,CAAC,GAAG,CAAC;QAAEkL,eAAe,EAAEA,eAAe;QACxIC,aAAa,EAAEA,aAAa;QAAEC,YAAY,EAAE,GAAG;QAAExc,SAAS,EAAE,CAAC;QAAEC,SAAS,EAAE;MAAG,CAAC,EAAEgc,cAAc,CAAC,EAAE/kB,UAAU,CAAC;MAChH;MACA;MACA;MACA,OAAO4N,KAAK,CAAC8U,kBAAkB,CAACxI,IAAI,CAAC,GAC/BtM,KAAK,CAAC2X,uBAAuB,CAACrL,IAAI,EAAEzN,OAAO,CAAC,GAC5CmB,KAAK,CAAChkB,aAAa,CAAC47B,oBAAoB,CAACtL,IAAI,EAAEzN,OAAO,EAAEuY,UAAU,CAAC;IAC7E,CAAC,CAAC;IACF;IACA,OAAOpV,OAAO,CAAC6C,GAAG,CAAC0S,kBAAkB,CAAC,CAACpV,IAAI,CAAC,YAAY;MACpD,IAAIzlB,EAAE,EAAEgJ,EAAE;MACV,CAACA,EAAE,GAAG,CAAChJ,EAAE,GAAGsjB,KAAK,CAACxlB,KAAK,EAAEq9B,mBAAmB,MAAM,IAAI,IAAInyB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACvF,IAAI,CAACzD,EAAE,CAAC;IAClG,CAAC,CAAC;EACN,CAAC;EACD+2B,yBAAyB,CAACxzB,SAAS,CAACk0B,UAAU,GAAG,YAAY;IACzD,IAAInU,KAAK,GAAG,IAAI;IAChBgM,QAAQ,CAAC,UAAUM,IAAI,EAAE;MACrB,IAAI2I,SAAS,GAAGjV,KAAK,CAAC8U,kBAAkB,CAACxI,IAAI,CAAC;MAC9C2I,SAAS,GACHA,SAAS,CAACnW,IAAI,EAAE,GAChBkB,KAAK,CAAChkB,aAAa,CAAC87B,mBAAmB,EAAE;IACnD,CAAC,CAAC;EACN,CAAC;EACDrE,yBAAyB,CAACxzB,SAAS,CAAC03B,uBAAuB,GAAG,UAAUrL,IAAI,EAAEla,UAAU,EAAE;IACtF,IAAI6iB,SAAS,GAAG,IAAI,CAACH,kBAAkB,CAACxI,IAAI,CAAC;IAC7C,IAAI,CAAC2I,SAAS,EACV;IACJ,IAAI8C,YAAY,GAAG9C,SAAS,CAACl7B,GAAG,EAAE;IAClCk7B,SAAS,CAACtxB,GAAG,CAACo0B,YAAY,CAAC;IAC3B9C,SAAS,CAACtxB,GAAG,CAACo0B,YAAY,CAAC,CAAC,CAAC;IAC7B,OAAO9Y,cAAc,CAACqN,IAAI,EAAE2I,SAAS,EAAE,CAAC,EAAE7iB,UAAU,CAAC;EACzD,CAAC;EACDqhB,yBAAyB,CAACxzB,SAAS,CAACywB,UAAU,GAAG,YAAY;IACzD,IAAI1Q,KAAK,GAAG,IAAI;IAChB,IAAItjB,EAAE,GAAG,IAAI,CAAClC,KAAK;MAAEO,IAAI,GAAG2B,EAAE,CAAC3B,IAAI;MAAE66B,eAAe,GAAGl5B,EAAE,CAACk5B,eAAe;IACzE,IAAI,CAAC51B,WAAW,CAAC41B,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC/H,cAAc,EACrD;IACJ;IACA,IAAI,CAACsG,UAAU,EAAE;IACjB;IACA,IAAI6D,WAAW,GAAG;MAAE3yB,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE;IAAE,CAAC;IAChC0mB,QAAQ,CAAC,UAAUM,IAAI,EAAE;MACrB0L,WAAW,CAAC1L,IAAI,CAAC,GAAGC,UAAU,CAACvM,KAAK,CAAChkB,aAAa,CAAC+O,UAAU,CAACsB,MAAM,CAACigB,IAAI,CAAC,EAAEtM,KAAK,CAAC6N,cAAc,CAACvB,IAAI,CAAC,CAAC;IAC3G,CAAC,CAAC;IACF;AACR;AACA;AACA;AACA;IACQ,IAAI,CAAC2L,iBAAiB,CAAC,YAAY;MAC/BjM,QAAQ,CAAC,UAAUM,IAAI,EAAE;QACrB,IAAI,CAACgK,UAAU,CAAChK,IAAI,EAAEvxB,IAAI,EAAE,IAAI,CAAC,EAC7B;QACJ;QACA;QACA,IAAI2B,EAAE,GAAGoxB,wBAAwB,CAAC9N,KAAK,CAAChkB,aAAa,CAAC+O,UAAU,CAACsB,MAAM,CAACigB,IAAI,CAAC,EAAEtM,KAAK,CAAC6N,cAAc,CAACvB,IAAI,CAAC,EAAE0L,WAAW,CAAC1L,IAAI,CAAC,CAAC;UAAElB,GAAG,GAAG1uB,EAAE,CAAC0uB,GAAG;UAAEC,GAAG,GAAG3uB,EAAE,CAAC2uB,GAAG;QACzJrL,KAAK,CAAChkB,aAAa,CAACw2B,uBAAuB,CAAClG,IAAI,EAAElB,GAAG,EAAEC,GAAG,CAAC;MAC/D,CAAC,CAAC;IACN,CAAC,CAAC;IACF;AACR;AACA;AACA;IACQjM,UAAU,CAAC2T,WAAW,EAAE,CAAC,CAAC;EAC9B,CAAC;EACDU,yBAAyB,CAACxzB,SAAS,CAACg4B,iBAAiB,GAAG,UAAUC,OAAO,EAAE;IACvE,IAAIlY,KAAK,GAAG,IAAI;IAChB,IAAI,CAACqU,YAAY,GAAGvB,WAAW,CAAC,UAAUwB,IAAI,EAAEC,KAAK,EAAE;MACnD,IAAIvF,SAAS,GAAGD,0BAA0B,CAAC/O,KAAK,CAAChkB,aAAa,CAAC;MAC/Du4B,KAAK,CAAC,YAAY;QACd,OAAOvF,SAAS,CAACr1B,OAAO,CAAC,UAAUwW,OAAO,EAAE;UAAE,OAAOA,OAAO,CAACwkB,cAAc,EAAE;QAAE,CAAC,CAAC;MACrF,CAAC,CAAC;MACFL,IAAI,CAAC,YAAY;QAAE,OAAOlF,uBAAuB,CAACpP,KAAK,CAAChkB,aAAa,CAAC;MAAE,CAAC,CAAC;MAC1Eu4B,KAAK,CAAC,YAAY;QACd,OAAOvF,SAAS,CAACr1B,OAAO,CAAC,UAAUwW,OAAO,EAAE;UAAE,OAAOA,OAAO,CAACykB,gBAAgB,EAAE;QAAE,CAAC,CAAC;MACvF,CAAC,CAAC;MACFN,IAAI,CAAC,YAAY;QACbtU,KAAK,CAACoV,sBAAsB,EAAE;MAClC,CAAC,CAAC;MACF,IAAI8C,OAAO,EACP3D,KAAK,CAAC2D,OAAO,CAAC;IACtB,CAAC,CAAC;EACN,CAAC;EACDzE,yBAAyB,CAACxzB,SAAS,CAACO,KAAK,GAAG,UAAUxE,aAAa,EAAE;IACjE,IAAIgkB,KAAK,GAAG,IAAI;IAChB,IAAI7P,OAAO,GAAGnU,aAAa,CAACwc,WAAW,EAAE;IACzC;AACR;AACA;IACQ,IAAI2f,mBAAmB,GAAG9hB,eAAe,CAAClG,OAAO,EAAE,aAAa,EAAE,UAAUwD,KAAK,EAAE;MAC/E,IAAIjX,EAAE,GAAGsjB,KAAK,CAACxlB,KAAK;QAAEO,IAAI,GAAG2B,EAAE,CAAC3B,IAAI;QAAE2K,EAAE,GAAGhJ,EAAE,CAAC07B,YAAY;QAAEA,YAAY,GAAG1yB,EAAE,KAAK,KAAK,CAAC,GAAG,IAAI,GAAGA,EAAE;MACpG3K,IAAI,IAAIq9B,YAAY,IAAIpY,KAAK,CAACle,KAAK,CAAC6R,KAAK,CAAC;IAC9C,CAAC,CAAC;IACF;AACR;AACA;AACA;IACQ,IAAI0kB,kBAAkB,GAAGtlB,WAAW,CAACvU,MAAM,EAAE,QAAQ,EAAE,YAAY;MAC/DwhB,KAAK,CAAC0Q,UAAU,EAAE;IACtB,CAAC,CAAC;IACF;AACR;AACA;AACA;IACQ,IAAI4H,wBAAwB,GAAGt8B,aAAa,CAACu8B,cAAc,CAAC,YAAY;MACpE,IAAIvY,KAAK,CAAC0T,UAAU,EAAE;QAClB1T,KAAK,CAACoV,sBAAsB,EAAE;MAClC;IACJ,CAAC,CAAC;IACF;AACR;AACA;AACA;IACQ,IAAIoD,cAAc,GAAGx8B,aAAa,CAACw8B,cAAc;IACjD,IAAIA,cAAc,EAAE;MAChB,IAAI,CAAC12B,KAAK,CAAC0xB,gBAAgB,EAAE;QAAEK,cAAc,EAAE2E;MAAe,CAAC,CAAC;IACpE;IACA;AACR;AACA;IACQ,OAAO,YAAY;MACfL,mBAAmB,KAAK,IAAI,IAAIA,mBAAmB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,mBAAmB,EAAE;MAC/FE,kBAAkB,KAAK,IAAI,IAAIA,kBAAkB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,kBAAkB,EAAE;MAC5FC,wBAAwB,KAAK,IAAI,IAAIA,wBAAwB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,wBAAwB,EAAE;MAC9GtY,KAAK,CAACkW,UAAU,EAAE;IACtB,CAAC;EACL,CAAC;EACD,OAAOzC,yBAAyB;AACpC,CAAC,EAAG;AACJ,SAAS6C,UAAUA,CAACmC,SAAS,EAAE19B,IAAI,EAAE44B,gBAAgB,EAAE;EACnD,OAAQ,CAAC54B,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK09B,SAAS,MACvC9E,gBAAgB,KAAK,IAAI,IAAIA,gBAAgB,KAAK8E,SAAS,CAAC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASjD,mBAAmBA,CAAC3nB,MAAM,EAAE6qB,aAAa,EAAE;EAChD,IAAIA,aAAa,KAAK,KAAK,CAAC,EAAE;IAAEA,aAAa,GAAG,EAAE;EAAE;EACpD,IAAID,SAAS,GAAG,IAAI;EACpB,IAAIvxB,IAAI,CAACyxB,GAAG,CAAC9qB,MAAM,CAACvI,CAAC,CAAC,GAAGozB,aAAa,EAAE;IACpCD,SAAS,GAAG,GAAG;EACnB,CAAC,MACI,IAAIvxB,IAAI,CAACyxB,GAAG,CAAC9qB,MAAM,CAACxI,CAAC,CAAC,GAAGqzB,aAAa,EAAE;IACzCD,SAAS,GAAG,GAAG;EACnB;EACA,OAAOA,SAAS;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASG,OAAOA,CAACp+B,KAAK,EAAE;EACpB,IAAIq+B,iBAAiB,GAAGr+B,KAAK,CAACs+B,YAAY;IAAE98B,aAAa,GAAGxB,KAAK,CAACwB,aAAa;EAC/E,IAAIe,kBAAkB,GAAGhE,KAAK,CAACoD,UAAU,CAACW,mBAAmB,CAAC,CAACC,kBAAkB;EACjF,IAAI+7B,YAAY,GAAGz7B,WAAW,CAAC,YAAY;IACvC,OAAO,IAAIo2B,yBAAyB,CAAC;MACjCz3B,aAAa,EAAEA;IACnB,CAAC,CAAC;EACN,CAAC,CAAC;EACF88B,YAAY,CAACp5B,QAAQ,CAAC7G,KAAK,CAACgE,QAAQ,CAAChE,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAErC,KAAK,CAAC,EAAE;IAAEuC,kBAAkB,EAAEA;EAAmB,CAAC,CAAC,CAAC;EAC5G;EACA;EACAhE,KAAK,CAACkF,SAAS,CAAC,YAAY;IAAE,OAAO46B,iBAAiB,IAAIA,iBAAiB,CAAC7P,SAAS,CAAC8P,YAAY,CAAC;EAAE,CAAC,EAAE,CAACA,YAAY,CAAC,CAAC;EACvH;EACA//B,KAAK,CAACkF,SAAS,CAAC,YAAY;IAAE,OAAO66B,YAAY,CAACt4B,KAAK,CAACxE,aAAa,CAAC;EAAE,CAAC,EAAE,EAAE,CAAC;AAClF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS+8B,aAAaA,CAACr8B,EAAE,EAAE;EACvB,IAAIs8B,KAAK,GAAGt8B,EAAE,CAACs8B,KAAK;IAAEC,UAAU,GAAGv8B,EAAE,CAACu8B,UAAU;IAAEC,QAAQ,GAAGx8B,EAAE,CAACw8B,QAAQ;IAAEC,iBAAiB,GAAGz8B,EAAE,CAACy8B,iBAAiB;IAAEn9B,aAAa,GAAGU,EAAE,CAACV,aAAa;EACpJ,IAAIo9B,YAAY,GAAGJ,KAAK,IAAIC,UAAU,IAAIC,QAAQ,IAAIC,iBAAiB;EACvE,IAAIpF,UAAU,GAAGh7B,KAAK,CAACyE,MAAM,CAAC,IAAI,CAAC;EACnC,IAAIT,kBAAkB,GAAGhE,KAAK,CAACoD,UAAU,CAACW,mBAAmB,CAAC,CAACC,kBAAkB;EACjF,IAAImsB,QAAQ,GAAG;IACXqB,cAAc,EAAE4O,iBAAiB;IACjCxP,OAAO,EAAEsP,UAAU;IACnBrP,MAAM,EAAEoP,KAAK;IACb7O,KAAK,EAAE,SAAAA,CAAUxW,KAAK,EAAEyD,IAAI,EAAE;MAC1B2c,UAAU,CAACt2B,OAAO,GAAG,IAAI;MACzBy7B,QAAQ,IAAIA,QAAQ,CAACvlB,KAAK,EAAEyD,IAAI,CAAC;IACrC;EACJ,CAAC;EACDre,KAAK,CAACkF,SAAS,CAAC,YAAY;IACxB,IAAI81B,UAAU,CAACt2B,OAAO,KAAK,IAAI,EAAE;MAC7Bs2B,UAAU,CAACt2B,OAAO,CAACgtB,cAAc,CAACvB,QAAQ,CAAC;IAC/C;EACJ,CAAC,CAAC;EACF,SAASxQ,aAAaA,CAAC/E,KAAK,EAAE;IAC1BogB,UAAU,CAACt2B,OAAO,GAAG,IAAIwrB,UAAU,CAACtV,KAAK,EAAEuV,QAAQ,EAAE;MACjDnsB,kBAAkB,EAAEA;IACxB,CAAC,CAAC;EACN;EACAuZ,eAAe,CAACta,aAAa,EAAE,aAAa,EAAEo9B,YAAY,IAAI1gB,aAAa,CAAC;EAC5Ed,gBAAgB,CAAC,YAAY;IAAE,OAAOmc,UAAU,CAACt2B,OAAO,IAAIs2B,UAAU,CAACt2B,OAAO,CAACysB,GAAG,EAAE;EAAE,CAAC,CAAC;AAC5F;AAEA,IAAInvB,IAAI,GAAG;EACPI,GAAG,EAAEyd,uBAAuB,CAACmgB,aAAa,CAAC;EAC3Ch+B,IAAI,EAAE6d,uBAAuB,CAACggB,OAAO;AACzC,CAAC;;AAED;AACA;AACA;AACA,IAAIS,QAAQ;AACZ,CAAC,UAAUA,QAAQ,EAAE;EACjBA,QAAQ,CAACA,QAAQ,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;EAC/CA,QAAQ,CAACA,QAAQ,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;EAC7CA,QAAQ,CAACA,QAAQ,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;AACjD,CAAC,EAAEA,QAAQ,KAAKA,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAC;AAC/B;AACA;AACA;AACA1gC,OAAO,CAAC2gC,gBAAgB,GAAG,KAAK,CAAC;AACjC,CAAC,UAAUA,gBAAgB,EAAE;EACzBA,gBAAgB,CAACA,gBAAgB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;EACvDA,gBAAgB,CAACA,gBAAgB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;AAC3D,CAAC,EAAE3gC,OAAO,CAAC2gC,gBAAgB,KAAK3gC,OAAO,CAAC2gC,gBAAgB,GAAG,CAAC,CAAC,CAAC,CAAC;AAE/D,SAASC,aAAaA,CAAC3gC,KAAK,EAAE;EAC1B,OAAO,OAAOA,KAAK,KAAK,QAAQ,IAAIA,KAAK,CAACiO,UAAU,CAAC,QAAQ,CAAC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI2yB,gBAAgB,GAAG,sDAAsD;AAC7E,SAASC,gBAAgBA,CAACh8B,OAAO,EAAE;EAC/B,IAAIi8B,KAAK,GAAGF,gBAAgB,CAACG,IAAI,CAACl8B,OAAO,CAAC;EAC1C,IAAI,CAACi8B,KAAK,EACN,OAAO,GAAG;EACd,IAAIh9B,EAAE,GAAG7D,KAAK,CAACwhB,MAAM,CAACqf,KAAK,EAAE,CAAC,CAAC;IAAEE,KAAK,GAAGl9B,EAAE,CAAC,CAAC,CAAC;IAAEm9B,QAAQ,GAAGn9B,EAAE,CAAC,CAAC,CAAC;EAChE,OAAO,CAACk9B,KAAK,EAAEC,QAAQ,CAAC;AAC5B;AACA,IAAIC,QAAQ,GAAG,CAAC;AAChB,SAASC,gBAAgBA,CAACt8B,OAAO,EAAE0S,OAAO,EAAEye,KAAK,EAAE;EAC/C,IAAIA,KAAK,KAAK,KAAK,CAAC,EAAE;IAAEA,KAAK,GAAG,CAAC;EAAE;EACnC51B,SAAS,CAACuD,SAAS,CAACqyB,KAAK,IAAIkL,QAAQ,EAAE,yDAAyD,GAAGr8B,OAAO,GAAG,uDAAuD,CAAC;EACrK,IAAIf,EAAE,GAAG7D,KAAK,CAACwhB,MAAM,CAACof,gBAAgB,CAACh8B,OAAO,CAAC,EAAE,CAAC,CAAC;IAAEm8B,KAAK,GAAGl9B,EAAE,CAAC,CAAC,CAAC;IAAEm9B,QAAQ,GAAGn9B,EAAE,CAAC,CAAC,CAAC;EACpF;EACA,IAAI,CAACk9B,KAAK,EACN;EACJ;EACA,IAAI1nB,QAAQ,GAAG1T,MAAM,CAACw7B,gBAAgB,CAAC7pB,OAAO,CAAC,CAAC8pB,gBAAgB,CAACL,KAAK,CAAC;EACvE,IAAI1nB,QAAQ,EAAE;IACV,OAAOA,QAAQ,CAAC3L,IAAI,EAAE;EAC1B,CAAC,MACI,IAAIgzB,aAAa,CAACM,QAAQ,CAAC,EAAE;IAC9B;IACA,OAAOE,gBAAgB,CAACF,QAAQ,EAAE1pB,OAAO,EAAEye,KAAK,GAAG,CAAC,CAAC;EACzD,CAAC,MACI;IACD,OAAOiL,QAAQ;EACnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,SAASK,mBAAmBA,CAACl+B,aAAa,EAAEU,EAAE,EAAEyV,aAAa,EAAE;EAC3D,IAAIzM,EAAE;EACN,IAAI2G,MAAM,GAAGxT,KAAK,CAACsW,MAAM,CAACzS,EAAE,EAAE,EAAE,CAAC;EACjC,IAAIyT,OAAO,GAAGnU,aAAa,CAACwc,WAAW,EAAE;EACzC,IAAI,EAAErI,OAAO,YAAYgqB,WAAW,CAAC,EACjC,OAAO;IAAE9tB,MAAM,EAAEA,MAAM;IAAE8F,aAAa,EAAEA;EAAc,CAAC;EAC3D;EACA;EACA,IAAIA,aAAa,EAAE;IACfA,aAAa,GAAGtZ,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAEsV,aAAa,CAAC;EACrD;EACA;EACAnW,aAAa,CAACgF,YAAY,CAAC,UAAUpI,KAAK,EAAE;IACxC,IAAI6E,OAAO,GAAG7E,KAAK,CAACmB,GAAG,EAAE;IACzB,IAAI,CAACw/B,aAAa,CAAC97B,OAAO,CAAC,EACvB;IACJ,IAAIyU,QAAQ,GAAG6nB,gBAAgB,CAACt8B,OAAO,EAAE0S,OAAO,CAAC;IACjD,IAAI+B,QAAQ,EACRtZ,KAAK,CAAC+K,GAAG,CAACuO,QAAQ,CAAC;EAC3B,CAAC,CAAC;EACF;EACA;EACA,KAAK,IAAI3W,GAAG,IAAI8Q,MAAM,EAAE;IACpB,IAAI5O,OAAO,GAAG4O,MAAM,CAAC9Q,GAAG,CAAC;IACzB,IAAI,CAACg+B,aAAa,CAAC97B,OAAO,CAAC,EACvB;IACJ,IAAIyU,QAAQ,GAAG6nB,gBAAgB,CAACt8B,OAAO,EAAE0S,OAAO,CAAC;IACjD,IAAI,CAAC+B,QAAQ,EACT;IACJ;IACA7F,MAAM,CAAC9Q,GAAG,CAAC,GAAG2W,QAAQ;IACtB;IACA;IACA;IACA,IAAIC,aAAa,EACb,CAACzM,EAAE,GAAGyM,aAAa,CAAC5W,GAAG,CAAC,MAAM,IAAI,IAAImK,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAIyM,aAAa,CAAC5W,GAAG,CAAC,GAAGkC,OAAQ;EACjG;EACA,OAAO;IAAE4O,MAAM,EAAEA,MAAM;IAAE8F,aAAa,EAAEA;EAAc,CAAC;AAC3D;AAEA,SAASioB,eAAeA,CAACC,MAAM,EAAE/N,IAAI,EAAE;EACnC,OAAQ+N,MAAM,IAAI/N,IAAI,CAACjB,GAAG,GAAGiB,IAAI,CAAClB,GAAG,CAAC,GAAI,GAAG;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASkP,mBAAmBA,CAACprB,MAAM,EAAEqrB,YAAY,EAAE79B,EAAE,EAAE;EACnD,IAAI2P,MAAM,GAAG3P,EAAE,CAAC2P,MAAM;EACtB;AACJ;AACA;AACA;EACI,IAAI,OAAO6C,MAAM,KAAK,QAAQ,EAAE;IAC5B,IAAIjW,eAAe,CAACqO,EAAE,CAACtD,IAAI,CAACkL,MAAM,CAAC,EAAE;MACjCA,MAAM,GAAG6P,UAAU,CAAC7P,MAAM,CAAC;IAC/B,CAAC,MACI;MACD,OAAOA,MAAM;IACjB;EACJ;EACA;AACJ;AACA;AACA;EACI,IAAI7J,CAAC,GAAG+0B,eAAe,CAAClrB,MAAM,EAAE7C,MAAM,CAAChH,CAAC,CAAC;EACzC,IAAIC,CAAC,GAAG80B,eAAe,CAAClrB,MAAM,EAAE7C,MAAM,CAAC/G,CAAC,CAAC;EACzC,OAAOD,CAAC,GAAG,IAAI,GAAGC,CAAC,GAAG,GAAG;AAC7B;AACA,IAAIk1B,QAAQ,GAAG,OAAO;AACtB,SAASC,gBAAgBA,CAACvrB,MAAM,EAAExS,EAAE,EAAE;EAClC,IAAIwkB,KAAK,GAAGxkB,EAAE,CAACwkB,KAAK;IAAEhV,SAAS,GAAGxP,EAAE,CAACwP,SAAS;EAC9C,IAAIwuB,QAAQ,GAAGxrB,MAAM;EACrB;AACJ;AACA;EACI,IAAIyrB,oBAAoB,GAAGzrB,MAAM,CAACpL,QAAQ,CAAC,MAAM,CAAC;EAClD,IAAI82B,YAAY,GAAG,EAAE;EACrB,IAAID,oBAAoB,EAAE;IACtBzrB,MAAM,GAAGA,MAAM,CAACc,OAAO,CAACwpB,gBAAgB,EAAE,UAAUE,KAAK,EAAE;MACvDkB,YAAY,CAACj+B,IAAI,CAAC+8B,KAAK,CAAC;MACxB,OAAOc,QAAQ;IACnB,CAAC,CAAC;EACN;EACA,IAAIK,MAAM,GAAG5hC,eAAe,CAAC6hB,OAAO,CAAC4H,KAAK,CAACxT,MAAM,CAAC;EAClD;EACA,IAAI2rB,MAAM,CAAC/+B,MAAM,GAAG,CAAC,EACjB,OAAO4+B,QAAQ;EACnB,IAAII,QAAQ,GAAG7hC,eAAe,CAAC6hB,OAAO,CAACigB,iBAAiB,CAAC7rB,MAAM,CAAC;EAChE,IAAIrB,MAAM,GAAG,OAAOgtB,MAAM,CAAC,CAAC,CAAC,KAAK,QAAQ,GAAG,CAAC,GAAG,CAAC;EAClD;EACA,IAAIG,MAAM,GAAG9Z,KAAK,CAAC7b,CAAC,CAACoE,KAAK,GAAGyC,SAAS,CAAC7G,CAAC;EACxC,IAAI41B,MAAM,GAAG/Z,KAAK,CAAC5b,CAAC,CAACmE,KAAK,GAAGyC,SAAS,CAAC5G,CAAC;EACxCu1B,MAAM,CAAC,CAAC,GAAGhtB,MAAM,CAAC,IAAImtB,MAAM;EAC5BH,MAAM,CAAC,CAAC,GAAGhtB,MAAM,CAAC,IAAIotB,MAAM;EAC5B;AACJ;AACA;AACA;AACA;AACA;EACI,IAAIC,YAAY,GAAGhiC,SAAS,CAAC+X,GAAG,CAAC+pB,MAAM,EAAEC,MAAM,EAAE,GAAG,CAAC;EACrD;EACA,IAAI,OAAOJ,MAAM,CAAC,CAAC,GAAGhtB,MAAM,CAAC,KAAK,QAAQ,EACtCgtB,MAAM,CAAC,CAAC,GAAGhtB,MAAM,CAAC,IAAIqtB,YAAY;EACtC;EACA,IAAI,OAAOL,MAAM,CAAC,CAAC,GAAGhtB,MAAM,CAAC,KAAK,QAAQ,EACtCgtB,MAAM,CAAC,CAAC,GAAGhtB,MAAM,CAAC,IAAIqtB,YAAY;EACtC,IAAIC,MAAM,GAAGL,QAAQ,CAACD,MAAM,CAAC;EAC7B,IAAIF,oBAAoB,EAAE;IACtB,IAAIS,GAAG,GAAG,CAAC;IACXD,MAAM,GAAGA,MAAM,CAACnrB,OAAO,CAACwqB,QAAQ,EAAE,YAAY;MAC1C,IAAIa,WAAW,GAAGT,YAAY,CAACQ,GAAG,CAAC;MACnCA,GAAG,EAAE;MACL,OAAOC,WAAW;IACtB,CAAC,CAAC;EACN;EACA,OAAOF,MAAM;AACjB;AACA,IAAIG,0BAA0B,GAAG;EAC7Bl/B,OAAO,EAAEk+B;AACb,CAAC;AACD,IAAIiB,sBAAsB,GAAG;EACzB5zB,YAAY,EAAE9O,KAAK,CAACgE,QAAQ,CAAChE,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAEy+B,0BAA0B,CAAC,EAAE;IAAEvvB,OAAO,EAAE,CAChF,qBAAqB,EACrB,sBAAsB,EACtB,wBAAwB,EACxB,yBAAyB;EAC3B,CAAC,CAAC;EACRlE,mBAAmB,EAAEyzB,0BAA0B;EAC/CxzB,oBAAoB,EAAEwzB,0BAA0B;EAChDtzB,sBAAsB,EAAEszB,0BAA0B;EAClDvzB,uBAAuB,EAAEuzB,0BAA0B;EACnDE,SAAS,EAAE;IACPp/B,OAAO,EAAEq+B;EACb;AACJ,CAAC;AAED,IAAIgB,cAAc,GAAG,IAAI;AACzB,IAAIpV,OAAO,GAAG,aAAe,UAAUqV,MAAM,EAAE;EAC3C7iC,KAAK,CAAC8iC,SAAS,CAACtV,OAAO,EAAEqV,MAAM,CAAC;EAChC,SAASrV,OAAOA,CAAA,EAAG;IACf,IAAIrG,KAAK,GAAG0b,MAAM,KAAK,IAAI,IAAIA,MAAM,CAAChT,KAAK,CAAC,IAAI,EAAEkT,SAAS,CAAC,IAAI,IAAI;IACpE;AACR;AACA;AACA;IACQ5b,KAAK,CAAC6b,WAAW,GAAGnQ,OAAO,EAAE;IAC7B;AACR;AACA;AACA;IACQ1L,KAAK,CAAC8b,sBAAsB,GAAGpQ,OAAO,EAAE;IACxC;AACR;AACA;IACQ1L,KAAK,CAACqC,WAAW,GAAG;MAChBhd,CAAC,EAAE,KAAK;MACRC,CAAC,EAAE;IACP,CAAC;IACD0a,KAAK,CAAC+b,iBAAiB,GAAG;MACtB12B,CAAC,EAAEvG,SAAS;MACZwG,CAAC,EAAExG;IACP,CAAC;IACDkhB,KAAK,CAACgc,eAAe,GAAG,KAAK;IAC7Bhc,KAAK,CAACne,OAAO,GAAG,UAAUwK,MAAM,EAAEuB,MAAM,EAAElR,EAAE,EAAE;MAC1C,IAAIA,EAAE,KAAK,KAAK,CAAC,EAAE;QAAEA,EAAE,GAAG,CAAC,CAAC;MAAE;MAC9B,IAAI+zB,SAAS,GAAG/zB,EAAE,CAAC+zB,SAAS;QAAEwL,SAAS,GAAGv/B,EAAE,CAACu/B,SAAS;QAAEC,gBAAgB,GAAGx/B,EAAE,CAACw/B,gBAAgB;QAAEC,kBAAkB,GAAGz/B,EAAE,CAACy/B,kBAAkB;QAAE5d,UAAU,GAAG7hB,EAAE,CAAC6hB,UAAU;QAAE6d,UAAU,GAAG1/B,EAAE,CAAC0/B,UAAU;QAAEl9B,MAAM,GAAGrG,KAAK,CAACsW,MAAM,CAACzS,EAAE,EAAE,CAAC,WAAW,EAAE,WAAW,EAAE,kBAAkB,EAAE,oBAAoB,EAAE,YAAY,EAAE,YAAY,CAAC,CAAC;MAC/T,IAAIgJ,EAAE,GAAGsa,KAAK,CAACxlB,KAAK;QAAEwB,aAAa,GAAG0J,EAAE,CAAC1J,aAAa;QAAEkJ,MAAM,GAAGQ,EAAE,CAACR,MAAM;MAC1E;AACZ;AACA;MACY,IAAIi3B,kBAAkB,KAAK,KAAK,EAAE;QAC9Bnc,KAAK,CAACgc,eAAe,GAAG,KAAK;QAC7B,OAAOhc,KAAK,CAAC9hB,YAAY,EAAE;MAC/B;MACA;AACZ;AACA;MACY,IAAI8hB,KAAK,CAACgc,eAAe,IAAIG,kBAAkB,KAAK,IAAI,EAAE;QACtD;MACJ,CAAC,MACI,IAAIA,kBAAkB,EAAE;QACzBnc,KAAK,CAACgc,eAAe,GAAG,IAAI;MAChC;MACA;AACZ;AACA;AACA;MACYpuB,MAAM,GAAG6iB,SAAS,IAAI7iB,MAAM;MAC5BvB,MAAM,GAAG4vB,SAAS,IAAI5vB,MAAM;MAC5B;AACZ;AACA;AACA;AACA;MACY,IAAI+qB,UAAU,GAAG,KAAK;MACtB,IAAI9E,gBAAgB,GAAGt2B,aAAa,CAACu2B,mBAAmB,EAAE;MAC1D,IAAID,gBAAgB,EAAE;QAClB,IAAI+J,qBAAqB,GAAG/J,gBAAgB,CAAC5C,eAAe;QAC5D,IAAI4M,YAAY,GAAGhK,gBAAgB,CAACjD,cAAc,EAAE,CAACnqB,MAAM;QAC3D;AAChB;AACA;QACgB,IAAIk3B,UAAU,EAAE;UACZ;AACpB;AACA;AACA;AACA;UACoB,IAAIH,SAAS,EAAE;YACXK,YAAY,GAAGF,UAAU,CAAC/M,cAAc,EAAE,CAACnqB,MAAM;UACrD;UACA;AACpB;AACA;AACA;AACA;UACoB,IAAIurB,SAAS,IACT,CAACT,uBAAuB,CAACoM,UAAU,EAAE9J,gBAAgB,CAAC,IACtD8J,UAAU,CAAC1M,eAAe,EAAE;YAC5B2M,qBAAqB,GAAGD,UAAU,CAAC1M,eAAe;UACtD;QACJ;QACA,IAAI2M,qBAAqB,IACrBE,4CAA4C,CAACH,UAAU,EAAE3L,SAAS,EAAEwL,SAAS,CAAC,EAAE;UAChF7E,UAAU,GAAG,IAAI;UACjBxpB,MAAM,GAAGmiB,kBAAkB,CAACsM,qBAAqB,EAAEzuB,MAAM,CAAC;UAC1DvB,MAAM,GAAG0jB,kBAAkB,CAACuM,YAAY,EAAEjwB,MAAM,CAAC;QACrD;MACJ;MACA,IAAImwB,WAAW,GAAGC,QAAQ,CAAC7uB,MAAM,EAAEvB,MAAM,CAAC;MAC1C,IAAIsY,UAAU,GAAGqH,QAAQ,CAAC,UAAUM,IAAI,EAAE;QACtC,IAAI5vB,EAAE,EAAEgJ,EAAE;QACV;AAChB;AACA;AACA;QACgB,IAAIR,MAAM,KAAK,UAAU,EAAE;UACvB,IAAIunB,YAAY,GAAGpgB,MAAM,CAACigB,IAAI,CAAC,CAACjB,GAAG,GAAGhf,MAAM,CAACigB,IAAI,CAAC,CAAClB,GAAG;UACtDxd,MAAM,CAAC0e,IAAI,CAAC,CAACjB,GAAG,GAAGzd,MAAM,CAAC0e,IAAI,CAAC,CAAClB,GAAG,GAAGqB,YAAY;QACtD;QACA,IAAIzwB,aAAa,CAAC+O,UAAU,CAAC2xB,cAAc,EAAE;UACzC;QACJ,CAAC,MACI,IAAIR,gBAAgB,KAAKp9B,SAAS,EAAE;UACrC9C,aAAa,CAAC2gC,aAAa,CAACT,gBAAgB,KAAKvjC,OAAO,CAAC2gC,gBAAgB,CAACsD,IAAI,CAAC;QACnF,CAAC,MACI,IAAIJ,WAAW,EAAE;UAClB;UACA;UACA,OAAOxc,KAAK,CAAC6c,WAAW,CAACvQ,IAAI,EAAEjgB,MAAM,CAACigB,IAAI,CAAC,EAAE1e,MAAM,CAAC0e,IAAI,CAAC,EAAEzzB,KAAK,CAACgE,QAAQ,CAAChE,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAEqC,MAAM,CAAC,EAAE;YAAEk4B,UAAU,EAAEA;UAAW,CAAC,CAAC,CAAC;QACtI,CAAC,MACI;UACD,CAAC1xB,EAAE,GAAG,CAAChJ,EAAE,GAAGsjB,KAAK,CAAC+b,iBAAiB,EAAEzP,IAAI,CAAC,MAAM,IAAI,IAAI5mB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACvF,IAAI,CAACzD,EAAE,CAAC;UAC5F;UACA;UACA,OAAOV,aAAa,CAACw2B,uBAAuB,CAAClG,IAAI,EAAEjgB,MAAM,CAACigB,IAAI,CAAC,CAAClB,GAAG,EAAE/e,MAAM,CAACigB,IAAI,CAAC,CAACjB,GAAG,EAAE+L,UAAU,CAAC;QACtG;MACJ,CAAC,CAAC;MACF;MACAp7B,aAAa,CAAC4D,UAAU,EAAE;MAC1B;AACZ;AACA;AACA;AACA;MACY,OAAOoiB,OAAO,CAAC6C,GAAG,CAACF,UAAU,CAAC,CAACxC,IAAI,CAAC,YAAY;QAC5CnC,KAAK,CAACgc,eAAe,GAAG,KAAK;QAC7Bzd,UAAU,IAAIA,UAAU,EAAE;QAC1BviB,aAAa,CAAC8gC,6BAA6B,EAAE;MACjD,CAAC,CAAC;IACN,CAAC;IACD,OAAO9c,KAAK;EAChB;EACAqG,OAAO,CAACpmB,SAAS,CAAC88B,iBAAiB,GAAG,YAAY;IAC9C,IAAI/c,KAAK,GAAG,IAAI;IAChB,IAAIhkB,aAAa,GAAG,IAAI,CAACxB,KAAK,CAACwB,aAAa;IAC5CA,aAAa,CAACghC,kBAAkB,GAAG/d,cAAc;IACjDjjB,aAAa,CAACg4B,sBAAsB,EAAE;IACtC,IAAI,CAACiJ,gBAAgB,GAAGjhC,aAAa,CAACu8B,cAAc,CAAC,IAAI,CAAC12B,OAAO,CAAC;IAClE7F,aAAa,CAACkhC,kBAAkB,GAAG,YAAY;MAAE,OAAOld,KAAK,CAAC9hB,YAAY,EAAE;IAAE,CAAC;IAC/EgG,kBAAkB,CAACq3B,sBAAsB,CAAC;EAC9C,CAAC;EACDlV,OAAO,CAACpmB,SAAS,CAACk9B,oBAAoB,GAAG,YAAY;IACjD,IAAInd,KAAK,GAAG,IAAI;IAChB,IAAI,CAACid,gBAAgB,EAAE;IACvBjR,QAAQ,CAAC,UAAUM,IAAI,EAAE;MAAE,IAAI5vB,EAAE,EAAEgJ,EAAE;MAAE,OAAO,CAACA,EAAE,GAAG,CAAChJ,EAAE,GAAGsjB,KAAK,CAAC+b,iBAAiB,EAAEzP,IAAI,CAAC,MAAM,IAAI,IAAI5mB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACvF,IAAI,CAACzD,EAAE,CAAC;IAAE,CAAC,CAAC;EAClJ,CAAC;EACD;AACJ;AACA;AACA;AACA;EACI2pB,OAAO,CAACpmB,SAAS,CAAC48B,WAAW,GAAG,UAAUvQ,IAAI,EAAEjgB,MAAM,EAAEuB,MAAM,EAAElR,EAAE,EAAE;IAChE,IAAIsjB,KAAK,GAAG,IAAI;IAChB,IAAIta,EAAE,EAAEK,EAAE;IACV,IAAIE,EAAE,GAAGvJ,EAAE,KAAK,KAAK,CAAC,GAAG,CAAC,CAAC,GAAGA,EAAE;MAAE0V,UAAU,GAAGnM,EAAE,CAACmM,UAAU;MAAEglB,UAAU,GAAGnxB,EAAE,CAACmxB,UAAU;IACxF;AACR;AACA;IACQ,IAAI,IAAI,CAAC/U,WAAW,CAACiK,IAAI,CAAC,IACtB8Q,WAAW,CAAC/wB,MAAM,EAAE,IAAI,CAACyvB,sBAAsB,CAACxP,IAAI,CAAC,CAAC,EAAE;MACxD;IACJ;IACA,CAACvmB,EAAE,GAAG,CAACL,EAAE,GAAG,IAAI,CAACq2B,iBAAiB,EAAEzP,IAAI,CAAC,MAAM,IAAI,IAAIvmB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC5F,IAAI,CAACuF,EAAE,CAAC;IAC3F,IAAI,CAAC2c,WAAW,CAACiK,IAAI,CAAC,GAAG,IAAI;IAC7B,IAAItwB,aAAa,GAAG,IAAI,CAACxB,KAAK,CAACwB,aAAa;IAC5C,IAAI6/B,WAAW,GAAG,IAAI,CAACA,WAAW,CAACvP,IAAI,CAAC;IACxC,IAAI+Q,cAAc,GAAGrhC,aAAa,CAACshC,8BAA8B,EAAE,CAAChR,IAAI,CAAC;IACzE;AACR;AACA;AACA;IACQ+Q,cAAc,CAAC3b,cAAc,EAAE;IAC/B2b,cAAc,CAAC15B,GAAG,CAAC,CAAC,CAAC;IACrB05B,cAAc,CAAC15B,GAAG,CAAC,CAAC,CAAC;IACrB;AACR;AACA;AACA;IACQ,IAAI45B,KAAK,GAAG,SAAAA,CAAA,EAAY;MACpB;MACA,IAAIvgC,CAAC,GAAGqgC,cAAc,CAACtjC,GAAG,EAAE,GAAG0hC,cAAc;MAC7C;MACA5L,SAAS,CAACgM,WAAW,EAAEjuB,MAAM,EAAEvB,MAAM,EAAErP,CAAC,CAAC;MACzChB,aAAa,CAACw2B,uBAAuB,CAAClG,IAAI,EAAEuP,WAAW,CAACzQ,GAAG,EAAEyQ,WAAW,CAACxQ,GAAG,EAAE+L,UAAU,CAAC;IAC7F,CAAC;IACD;IACAmG,KAAK,EAAE;IACP;IACA,IAAIC,mBAAmB,GAAGH,cAAc,CAAC7b,QAAQ,CAAC+b,KAAK,CAAC;IACxD,IAAI,CAACxB,iBAAiB,CAACzP,IAAI,CAAC,GAAG,YAAY;MACvCtM,KAAK,CAACqC,WAAW,CAACiK,IAAI,CAAC,GAAG,KAAK;MAC/B+Q,cAAc,CAACve,IAAI,EAAE;MACrB0e,mBAAmB,EAAE;IACzB,CAAC;IACD,IAAI,CAAC1B,sBAAsB,CAACxP,IAAI,CAAC,GAAGjgB,MAAM;IAC1C,IAAIoxB,gBAAgB,GAAGrrB,UAAU,IAC7BpW,aAAa,CAAC6f,oBAAoB,EAAE,IACpC6hB,uBAAuB;IAC3B;IACA,IAAI7iC,SAAS,GAAGokB,cAAc,CAACqN,IAAI,KAAK,GAAG,GAAG,SAAS,GAAG,SAAS,EAAE+Q,cAAc,EAAE5B,cAAc,EAAEgC,gBAAgB,IAAIvf,kBAAkB,CAACuf,gBAAgB,EAAE,QAAQ,CAAC,CAAC,CAACtb,IAAI,CAAC,IAAI,CAAC4Z,iBAAiB,CAACzP,IAAI,CAAC,CAAC;IAC3M,OAAOzxB,SAAS;EACpB,CAAC;EACDwrB,OAAO,CAACpmB,SAAS,CAAC/B,YAAY,GAAG,YAAY;IACzC,IAAIxB,EAAE,EAAEgJ,EAAE;IACV,CAACA,EAAE,GAAG,CAAChJ,EAAE,GAAG,IAAI,CAAClC,KAAK,EAAE0D,YAAY,MAAM,IAAI,IAAIwH,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACvF,IAAI,CAACzD,EAAE,CAAC;EAC1F,CAAC;EACD2pB,OAAO,CAACpmB,SAAS,CAAC+gB,MAAM,GAAG,YAAY;IACnC,OAAO,IAAI;EACf,CAAC;EACD,OAAOqF,OAAO;AAClB,CAAC,CAACnsB,gBAAgB,CAACsB,SAAS,CAAE;AAC9B,SAASmiC,4BAA4BA,CAACnjC,KAAK,EAAE;EACzC,IAAIkC,EAAE,GAAG7D,KAAK,CAACwhB,MAAM,CAAC3c,WAAW,EAAE,EAAE,CAAC,CAAC;IAAEQ,YAAY,GAAGxB,EAAE,CAAC,CAAC,CAAC;EAC7D,OAAOxC,gBAAgB,CAAC0C,aAAa,CAACypB,OAAO,EAAExtB,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAErC,KAAK,EAAE;IAAE0D,YAAY,EAAEA;EAAa,CAAC,CAAC,CAAC;AAC7G;AACA,SAASu+B,QAAQA,CAAC/3B,CAAC,EAAEC,CAAC,EAAE;EACpB,OAAQ,CAACi5B,SAAS,CAACl5B,CAAC,CAAC,IACjB,CAACk5B,SAAS,CAACj5B,CAAC,CAAC,KACZ,CAACy4B,WAAW,CAAC14B,CAAC,CAACW,CAAC,EAAEV,CAAC,CAACU,CAAC,CAAC,IAAI,CAAC+3B,WAAW,CAAC14B,CAAC,CAACY,CAAC,EAAEX,CAAC,CAACW,CAAC,CAAC,CAAC;AAC1D;AACA,IAAIu4B,QAAQ,GAAG;EAAEzS,GAAG,EAAE,CAAC;EAAEC,GAAG,EAAE;AAAE,CAAC;AACjC,SAASuS,SAASA,CAACl5B,CAAC,EAAE;EAClB,OAAO04B,WAAW,CAAC14B,CAAC,CAACW,CAAC,EAAEw4B,QAAQ,CAAC,IAAIT,WAAW,CAAC14B,CAAC,CAACY,CAAC,EAAEu4B,QAAQ,CAAC;AACnE;AACA,SAAST,WAAWA,CAAC14B,CAAC,EAAEC,CAAC,EAAE;EACvB,OAAOD,CAAC,CAAC0mB,GAAG,KAAKzmB,CAAC,CAACymB,GAAG,IAAI1mB,CAAC,CAAC2mB,GAAG,KAAK1mB,CAAC,CAAC0mB,GAAG;AAC7C;AACA,IAAIqS,uBAAuB,GAAG;EAC1BliB,QAAQ,EAAE,IAAI;EACdZ,IAAI,EAAE,CAAC,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC;AACzB,CAAC;AACD,SAAS2hB,4CAA4CA,CAACH,UAAU,EAAE3L,SAAS,EAAEwL,SAAS,EAAE;EACpF,OAAOG,UAAU,IAAK,CAACA,UAAU,IAAI,EAAE3L,SAAS,IAAIwL,SAAS,CAAE;AACnE;;AAEA;AACA;AACA;AACA,IAAI6B,cAAc,GAAG;EACjBC,WAAW,EAAE,SAAAA,CAAUrmB,KAAK,EAAE;IAAE,OAAOA,KAAK,CAACsmB,iBAAiB,EAAE;EAAE;AACtE,CAAC;AACD;AACA;AACA;AACA,SAASC,aAAaA,CAAA,EAAG;EACrB,IAAIC,KAAK,GAAG,IAAIr5B,GAAG,EAAE;EACrB,OAAO;IACHkb,GAAG,EAAE,SAAAA,CAAUrI,KAAK,EAAE;MAAE,OAAOwmB,KAAK,CAACne,GAAG,CAACrI,KAAK,CAAC;IAAE,CAAC;IAClDymB,KAAK,EAAE,SAAAA,CAAUzhC,EAAE,EAAE;MACjB,IAAIgJ,EAAE,GAAGhJ,EAAE,KAAK,KAAK,CAAC,GAAGohC,cAAc,GAAGphC,EAAE;QAAEqhC,WAAW,GAAGr4B,EAAE,CAACq4B,WAAW;QAAE5+B,MAAM,GAAGuG,EAAE,CAACvG,MAAM;MAC9F2zB,WAAW,CAAC,UAAUwB,IAAI,EAAEC,KAAK,EAAE;QAC/B,IAAIlwB,KAAK,GAAGzD,KAAK,CAAC2c,IAAI,CAAC2gB,KAAK,CAAC,CAAC93B,IAAI,CAACuoB,cAAc,CAAC;QAClD,IAAIK,SAAS,GAAG7vB,MAAM,GAChB4vB,0BAA0B,CAAC5vB,MAAM,CAAC,GAClC,EAAE;QACRo1B,KAAK,CAAC,YAAY;UACd,IAAI6J,WAAW,GAAGvlC,KAAK,CAACulB,aAAa,CAACvlB,KAAK,CAACulB,aAAa,CAAC,EAAE,EAAEvlB,KAAK,CAACwhB,MAAM,CAAC2U,SAAS,CAAC,CAAC,EAAEn2B,KAAK,CAACwhB,MAAM,CAAChW,KAAK,CAAC,CAAC;UAC5G+5B,WAAW,CAACzkC,OAAO,CAAC,UAAUwW,OAAO,EAAE;YAAE,OAAOA,OAAO,CAACwkB,cAAc,EAAE;UAAE,CAAC,CAAC;QAChF,CAAC,CAAC;QACFL,IAAI,CAAC,YAAY;UACbjwB,KAAK,CAAC1K,OAAO,CAACy1B,uBAAuB,CAAC;QAC1C,CAAC,CAAC;QACFmF,KAAK,CAAC,YAAY;UACdvF,SAAS,CAACr1B,OAAO,CAAC,UAAUwW,OAAO,EAAE;YAAE,OAAOA,OAAO,CAACykB,gBAAgB,EAAE;UAAE,CAAC,CAAC;UAC5EvwB,KAAK,CAAC1K,OAAO,CAACokC,WAAW,CAAC;QAC9B,CAAC,CAAC;QACFzJ,IAAI,CAAC,YAAY;UACb;AACpB;AACA;AACA;AACA;AACA;UACoBjwB,KAAK,CAAC1K,OAAO,CAAC,UAAU+d,KAAK,EAAE;YAC3B,IAAIA,KAAK,CAAC9Z,SAAS,EACf8Z,KAAK,CAAC2mB,QAAQ,GAAGhF,QAAQ,CAACiF,OAAO;UACzC,CAAC,CAAC;QACN,CAAC,CAAC;QACF/J,KAAK,CAAC,YAAY;UACd;AACpB;AACA;AACA;AACA;AACA;UACoBp7B,IAAI,CAAC+7B,SAAS,CAACC,SAAS,EAAE;UAC1Bh8B,IAAI,CAAC+7B,SAAS,CAAClU,MAAM,EAAE;QAC3B,CAAC,CAAC;QACFsT,IAAI,CAAC,YAAY;UACb;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;UACoBl6B,aAAa,CAAC,SAAS,CAAC,CAACgnB,UAAU,CAAC,YAAY;YAC5C,OAAO/c,KAAK,CAAC1K,OAAO,CAAC4kC,0BAA0B,CAAC;UACpD,CAAC,CAAC;UACFL,KAAK,CAAC7d,KAAK,EAAE;QACjB,CAAC,CAAC;MACN,CAAC,CAAC;MACF;MACA0S,WAAW,EAAE;IACjB;EACJ,CAAC;AACL;AACA,SAASwL,0BAA0BA,CAAC7mB,KAAK,EAAE;EACvCA,KAAK,CAACgY,eAAe,GAAGhY,KAAK,CAAC3M,UAAU,CAACsB,MAAM;AACnD;AAEA,IAAImyB,mBAAmB,GAAGzlC,KAAK,CAAC2C,aAAa,CAACuiC,aAAa,EAAE,CAAC;AAC9D;AACA;AACA;AACA,IAAIQ,uBAAuB,GAAG1lC,KAAK,CAAC2C,aAAa,CAACuiC,aAAa,EAAE,CAAC;AAClE,SAASS,cAAcA,CAAC/gC,OAAO,EAAE;EAC7B,OAAO,CAAC,CAACA,OAAO,CAACghC,WAAW;AAChC;;AAEA;AACA;AACA;AACA,IAAIC,OAAO,GAAG,aAAe,UAAUlD,MAAM,EAAE;EAC3C7iC,KAAK,CAAC8iC,SAAS,CAACiD,OAAO,EAAElD,MAAM,CAAC;EAChC,SAASkD,OAAOA,CAAA,EAAG;IACf,OAAOlD,MAAM,KAAK,IAAI,IAAIA,MAAM,CAAChT,KAAK,CAAC,IAAI,EAAEkT,SAAS,CAAC,IAAI,IAAI;EACnE;EACA;AACJ;AACA;EACIgD,OAAO,CAAC3+B,SAAS,CAAC88B,iBAAiB,GAAG,YAAY;IAC9C,IAAIrgC,EAAE,GAAG,IAAI,CAAClC,KAAK;MAAEqkC,UAAU,GAAGniC,EAAE,CAACmiC,UAAU;MAAEC,gBAAgB,GAAGpiC,EAAE,CAACoiC,gBAAgB;MAAE9iC,aAAa,GAAGU,EAAE,CAACV,aAAa;IACzH0iC,cAAc,CAACG,UAAU,CAAC,IAAIA,UAAU,CAAC/gC,QAAQ,CAAC9B,aAAa,CAAC;IAChE0iC,cAAc,CAACI,gBAAgB,CAAC,IAC5BA,gBAAgB,CAAChhC,QAAQ,CAAC9B,aAAa,CAAC;IAC5CA,aAAa,CAAC+iC,SAAS,CAAC,YAAY;MAChC,IAAIL,cAAc,CAACG,UAAU,CAAC,EAAE;QAC5BA,UAAU,CAACG,MAAM,CAAChjC,aAAa,CAAC;MACpC;MACA,IAAI0iC,cAAc,CAACI,gBAAgB,CAAC,EAAE;QAClCA,gBAAgB,CAACE,MAAM,CAAChjC,aAAa,CAAC;MAC1C;IACJ,CAAC,CAAC;EACN,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACI4iC,OAAO,CAAC3+B,SAAS,CAACg/B,uBAAuB,GAAG,YAAY;IACpD,IAAIviC,EAAE,GAAG,IAAI,CAAClC,KAAK;MAAEqkC,UAAU,GAAGniC,EAAE,CAACmiC,UAAU;MAAE7iC,aAAa,GAAGU,EAAE,CAACV,aAAa;IACjF,IAAI0iC,cAAc,CAACG,UAAU,CAAC,EAAE;MAC5BA,UAAU,CAACK,UAAU,EAAE;IAC3B,CAAC,MACI;MACDtP,mBAAmB,CAAC5zB,aAAa,CAAC;MAClC6iC,UAAU,CAAC9e,GAAG,CAAC/jB,aAAa,CAAC;IACjC;IACA,OAAO,IAAI;EACf,CAAC;EACD4iC,OAAO,CAAC3+B,SAAS,CAACk/B,kBAAkB,GAAG,YAAY;IAC/C,IAAIN,UAAU,GAAG,IAAI,CAACrkC,KAAK,CAACqkC,UAAU;IACtC,IAAI,CAACH,cAAc,CAACG,UAAU,CAAC,EAC3BA,UAAU,CAACV,KAAK,EAAE;EAC1B,CAAC;EACDS,OAAO,CAAC3+B,SAAS,CAAC+gB,MAAM,GAAG,YAAY;IACnC,OAAO,IAAI;EACf,CAAC;EACD,OAAO4d,OAAO;AAClB,CAAC,CAACzkC,cAAc,CAAC,SAAS,CAAC,CAACqB,SAAS,CAAE;AACvC,SAAS4jC,sBAAsBA,CAAC5kC,KAAK,EAAE;EACnC,IAAIqkC,UAAU,GAAG9lC,KAAK,CAACoD,UAAU,CAACqiC,mBAAmB,CAAC;EACtD,IAAIM,gBAAgB,GAAG/lC,KAAK,CAACoD,UAAU,CAACsiC,uBAAuB,CAAC;EAChE,OAAQtkC,cAAc,CAAC,SAAS,CAAC,CAACyC,aAAa,CAACgiC,OAAO,EAAE/lC,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAErC,KAAK,EAAE;IAAEqkC,UAAU,EAAEA,UAAU;IAAEC,gBAAgB,EAAEA;EAAiB,CAAC,CAAC,CAAC;AACvJ;AAEA,IAAIO,gBAAgB,GAAG;EACnBzkC,aAAa,EAAEwkC,sBAAsB;EACrChkC,eAAe,EAAEuiC;AACrB,CAAC;AAED,IAAI2B,qBAAqB,GAAG,SAAAA,CAAA,EAAY;EAAE,OAAQ;IAC9C/kC,SAAS,EAAE,KAAK;IAChBsR,UAAU,EAAE,KAAK;IACjB6wB,cAAc,EAAE,KAAK;IACrBrwB,MAAM,EAAEqf,OAAO,EAAE;IACjB4L,WAAW,EAAE5L,OAAO;EACxB,CAAC;AAAG,CAAC;AACL,SAAS6T,iBAAiBA,CAAA,EAAG;EACzB,OAAO;IACH1zB,UAAU,EAAE,KAAK;IACjB3G,MAAM,EAAEwmB,OAAO,EAAE;IACjB8D,eAAe,EAAE9D,OAAO,EAAE;IAC1Bxf,SAAS,EAAE;MAAE7G,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE;IAAE,CAAC;IACzB4b,KAAK,EAAEA,KAAK,EAAE;IACdjV,UAAU,EAAEiV,KAAK,EAAE;IACnBse,cAAc,EAAE;EACpB,CAAC;AACL;AACA,IAAIC,UAAU,GAAGF,iBAAiB,EAAE;;AAEpC;AACA;AACA;AACA;AACA,SAASG,8BAA8BA,CAAChjC,EAAE,EAAEwP,SAAS,EAAEyzB,eAAe,EAAE;EACpE,IAAIt6B,CAAC,GAAG3I,EAAE,CAAC2I,CAAC;IAAEC,CAAC,GAAG5I,EAAE,CAAC4I,CAAC;EACtB;AACJ;AACA;AACA;AACA;AACA;EACI,IAAIs6B,UAAU,GAAGv6B,CAAC,CAACymB,SAAS,GAAG5f,SAAS,CAAC7G,CAAC;EAC1C,IAAIw6B,UAAU,GAAGv6B,CAAC,CAACwmB,SAAS,GAAG5f,SAAS,CAAC5G,CAAC;EAC1C,IAAIO,SAAS,GAAG,cAAc,GAAG+5B,UAAU,GAAG,MAAM,GAAGC,UAAU,GAAG,SAAS;EAC7E,IAAIF,eAAe,EAAE;IACjB,IAAIv2B,MAAM,GAAGu2B,eAAe,CAACv2B,MAAM;MAAEE,OAAO,GAAGq2B,eAAe,CAACr2B,OAAO;MAAEC,OAAO,GAAGo2B,eAAe,CAACp2B,OAAO;IACzG,IAAIH,MAAM,EACNvD,SAAS,IAAI,SAAS,GAAGuD,MAAM,GAAG,IAAI;IAC1C,IAAIE,OAAO,EACPzD,SAAS,IAAI,UAAU,GAAGyD,OAAO,GAAG,IAAI;IAC5C,IAAIC,OAAO,EACP1D,SAAS,IAAI,UAAU,GAAG0D,OAAO,GAAG,IAAI;EAChD;EACA1D,SAAS,IAAI,QAAQ,GAAGR,CAAC,CAACoE,KAAK,GAAG,IAAI,GAAGnE,CAAC,CAACmE,KAAK,GAAG,GAAG;EACtD,OAAO,CAACk2B,eAAe,IAAI95B,SAAS,KAAKi6B,kBAAkB,GAAG,EAAE,GAAGj6B,SAAS;AAChF;AACA;AACA;AACA;AACA,SAASk6B,oCAAoCA,CAACrjC,EAAE,EAAE;EAC9C,IAAIuP,UAAU,GAAGvP,EAAE,CAACuP,UAAU;EAC9B,OAAOA,UAAU,CAAC5G,CAAC,CAACuI,MAAM,GAAG,GAAG,GAAG,IAAI,GAAG3B,UAAU,CAAC3G,CAAC,CAACsI,MAAM,GAAG,GAAG,GAAG,KAAK;AAC/E;AACA,IAAIkyB,kBAAkB,GAAGJ,8BAA8B,CAACD,UAAU,CAACve,KAAK,EAAEue,UAAU,CAACvzB,SAAS,EAAE;EAAE7G,CAAC,EAAE,CAAC;EAAEC,CAAC,EAAE;AAAE,CAAC,CAAC;AAE/G,IAAI06B,KAAK,GAAG,CACR,eAAe,EACf,qBAAqB,EACrB,cAAc,EACd,mBAAmB,EACnB,QAAQ,EACR,QAAQ,EACR,mBAAmB,EACnB,yBAAyB,EACzB,gBAAgB,EAChB,eAAe,EACf,SAAS,CACZ;AACD,SAASC,gBAAgBA,CAAA,EAAG;EACxB,IAAIC,QAAQ,GAAGF,KAAK,CAACliB,GAAG,CAAC,YAAY;IAAE,OAAO,IAAI+B,mBAAmB,EAAE;EAAE,CAAC,CAAC;EAC3E,IAAIsgB,iBAAiB,GAAG,CAAC,CAAC;EAC1B,IAAIC,UAAU,GAAG;IACbC,iBAAiB,EAAE,SAAAA,CAAA,EAAY;MAAE,OAAOH,QAAQ,CAACvmC,OAAO,CAAC,UAAU2mC,OAAO,EAAE;QAAE,OAAOA,OAAO,CAACjgB,KAAK,EAAE;MAAE,CAAC,CAAC;IAAE,CAAC;IAC3GkgB,mBAAmB,EAAE,SAAAA,CAAU/lC,KAAK,EAAE;MAClC,OAAOwlC,KAAK,CAACrmC,OAAO,CAAC,UAAUe,IAAI,EAAE;QACjC,IAAIgC,EAAE;QACN,CAACA,EAAE,GAAGyjC,iBAAiB,CAACzlC,IAAI,CAAC,MAAM,IAAI,IAAIgC,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACyD,IAAI,CAACggC,iBAAiB,CAAC;QAC9F,IAAIK,EAAE,GAAG,IAAI,GAAG9lC,IAAI;QACpB,IAAI+lC,YAAY,GAAGjmC,KAAK,CAACgmC,EAAE,CAAC;QAC5B,IAAIC,YAAY,EAAE;UACdN,iBAAiB,CAACzlC,IAAI,CAAC,GAAG0lC,UAAU,CAACI,EAAE,CAAC,CAACC,YAAY,CAAC;QAC1D;MACJ,CAAC,CAAC;IACN;EACJ,CAAC;EACDP,QAAQ,CAACvmC,OAAO,CAAC,UAAU2mC,OAAO,EAAE9jC,CAAC,EAAE;IACnC4jC,UAAU,CAAC,IAAI,GAAGJ,KAAK,CAACxjC,CAAC,CAAC,CAAC,GAAG,UAAUyW,OAAO,EAAE;MAAE,OAAOqtB,OAAO,CAACvgB,GAAG,CAAC9M,OAAO,CAAC;IAAE,CAAC;IACjFmtB,UAAU,CAAC,QAAQ,GAAGJ,KAAK,CAACxjC,CAAC,CAAC,CAAC,GAAG,YAAY;MAC1C,IAAIkkC,IAAI,GAAG,EAAE;MACb,KAAK,IAAIC,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAG/E,SAAS,CAAC9/B,MAAM,EAAE6kC,EAAE,EAAE,EAAE;QAC1CD,IAAI,CAACC,EAAE,CAAC,GAAG/E,SAAS,CAAC+E,EAAE,CAAC;MAC5B;MACA,OAAOL,OAAO,CAACrgB,MAAM,CAACyI,KAAK,CAAC4X,OAAO,EAAEznC,KAAK,CAACulB,aAAa,CAAC,EAAE,EAAEvlB,KAAK,CAACwhB,MAAM,CAACqmB,IAAI,CAAC,CAAC,CAAC;IACrF,CAAC;EACL,CAAC,CAAC;EACF,OAAON,UAAU;AACrB;AAEA,SAASQ,2BAA2BA,CAACzwB,OAAO,EAAE6I,IAAI,EAAEC,IAAI,EAAE;EACtD,IAAIvc,EAAE;EACN,KAAK,IAAInB,GAAG,IAAIyd,IAAI,EAAE;IAClB,IAAI2d,SAAS,GAAG3d,IAAI,CAACzd,GAAG,CAAC;IACzB,IAAIslC,SAAS,GAAG5nB,IAAI,CAAC1d,GAAG,CAAC;IACzB,IAAI4J,aAAa,CAACwxB,SAAS,CAAC,EAAE;MAC1B;AACZ;AACA;AACA;MACYxmB,OAAO,CAACmT,QAAQ,CAAC/nB,GAAG,EAAEo7B,SAAS,CAAC;IACpC,CAAC,MACI,IAAIxxB,aAAa,CAAC07B,SAAS,CAAC,EAAE;MAC/B;AACZ;AACA;AACA;MACY1wB,OAAO,CAACmT,QAAQ,CAAC/nB,GAAG,EAAEgnB,WAAW,CAACoU,SAAS,CAAC,CAAC;IACjD,CAAC,MACI,IAAIkK,SAAS,KAAKlK,SAAS,EAAE;MAC9B;AACZ;AACA;AACA;AACA;MACY,IAAIxmB,OAAO,CAACiT,QAAQ,CAAC7nB,GAAG,CAAC,EAAE;QACvB,IAAIulC,aAAa,GAAG3wB,OAAO,CAACkT,QAAQ,CAAC9nB,GAAG,CAAC;QACzC;QACA,CAACulC,aAAa,CAACvf,WAAW,IAAIuf,aAAa,CAACn9B,GAAG,CAACgzB,SAAS,CAAC;MAC9D,CAAC,MACI;QACDxmB,OAAO,CAACmT,QAAQ,CAAC/nB,GAAG,EAAEgnB,WAAW,CAAC,CAAC7lB,EAAE,GAAGyT,OAAO,CAAC4wB,cAAc,CAACxlC,GAAG,CAAC,MAAM,IAAI,IAAImB,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAGi6B,SAAS,CAAC,CAAC;MACrH;IACJ;EACJ;EACA;EACA,KAAK,IAAIp7B,GAAG,IAAI0d,IAAI,EAAE;IAClB,IAAID,IAAI,CAACzd,GAAG,CAAC,KAAKuD,SAAS,EACvBqR,OAAO,CAAC6wB,WAAW,CAACzlC,GAAG,CAAC;EAChC;EACA,OAAOyd,IAAI;AACf;AAEA,SAASioB,kBAAkBA,CAACvkC,EAAE,EAAEgJ,EAAE,EAAEssB,QAAQ,EAAE1mB,eAAe,EAAE;EAC3D,IAAI4V,KAAK,GAAGxkB,EAAE,CAACwkB,KAAK;IAAEhc,MAAM,GAAGxI,EAAE,CAACwI,MAAM;IAAEsqB,eAAe,GAAG9yB,EAAE,CAAC8yB,eAAe;IAAEtjB,SAAS,GAAGxP,EAAE,CAACwP,SAAS;EACxG,IAAIG,MAAM,GAAG3G,EAAE,CAAC2G,MAAM;EACtB;AACJ;AACA;AACA;EACImkB,QAAQ,CAAChB,eAAe,EAAEtqB,MAAM,CAAC;EACjC;AACJ;AACA;AACA;EACI6sB,eAAe,CAACvC,eAAe,EAAEtjB,SAAS,EAAE8lB,QAAQ,CAAC;EACrD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIrF,cAAc,CAACzL,KAAK,EAAEsO,eAAe,EAAEnjB,MAAM,EAAEf,eAAe,CAAC;AACnE;AAEA,IAAI41B,QAAQ,GAAG,aAAe,YAAY;EACtC,SAASA,QAAQA,CAAA,EAAG;IAChB,IAAI,CAAChS,QAAQ,GAAG,EAAE;IAClB,IAAI,CAACiS,OAAO,GAAG,KAAK;EACxB;EACAD,QAAQ,CAACjhC,SAAS,CAAC8f,GAAG,GAAG,UAAUrI,KAAK,EAAE;IACtC6H,aAAa,CAAC,IAAI,CAAC2P,QAAQ,EAAExX,KAAK,CAAC;IACnC,IAAI,CAACypB,OAAO,GAAG,IAAI;EACvB,CAAC;EACDD,QAAQ,CAACjhC,SAAS,CAAC++B,MAAM,GAAG,UAAUtnB,KAAK,EAAE;IACzCgI,UAAU,CAAC,IAAI,CAACwP,QAAQ,EAAExX,KAAK,CAAC;IAChC,IAAI,CAACypB,OAAO,GAAG,IAAI;EACvB,CAAC;EACDD,QAAQ,CAACjhC,SAAS,CAACtG,OAAO,GAAG,UAAUwd,QAAQ,EAAE;IAC7C,IAAI,CAACgqB,OAAO,IAAI,IAAI,CAACjS,QAAQ,CAAC9oB,IAAI,CAACuoB,cAAc,CAAC;IAClD,IAAI,CAACwS,OAAO,GAAG,KAAK;IACpB,IAAI,CAACjS,QAAQ,CAACv1B,OAAO,CAACwd,QAAQ,CAAC;EACnC,CAAC;EACD,OAAO+pB,QAAQ;AACnB,CAAC,EAAG;AAEJ,SAASE,qBAAqBA,CAACplC,aAAa,EAAE;EAC1C,IAAIs2B,gBAAgB,GAAGt2B,aAAa,CAACu2B,mBAAmB,EAAE;EAC1D,IAAI,CAACD,gBAAgB,EAAE;IACnBt2B,aAAa,CAAC2zB,sBAAsB,EAAE;IACtC;EACJ;EACA,IAAI0R,cAAc,GAAGtR,kBAAkB,CAACuC,gBAAgB,CAACjD,cAAc,EAAE,CAACnqB,MAAM,EAAElJ,aAAa,CAACqzB,cAAc,EAAE,CAACnqB,MAAM,CAAC;EACxH8mB,QAAQ,CAAC,UAAUM,IAAI,EAAE;IACrBtwB,aAAa,CAACw2B,uBAAuB,CAAClG,IAAI,EAAE+U,cAAc,CAAC/U,IAAI,CAAC,CAAClB,GAAG,EAAEiW,cAAc,CAAC/U,IAAI,CAAC,CAACjB,GAAG,EAAE,IAAI,CAAC;EACzG,CAAC,CAAC;AACN;AAEA,IAAIrvB,aAAa,GAAG,SAAAA,CAAUU,EAAE,EAAE;EAC9B,IAAIgJ,EAAE,GAAGhJ,EAAE,CAAC4kC,QAAQ;IAAEA,QAAQ,GAAG57B,EAAE,KAAK,KAAK,CAAC,GAAG,EAAE,GAAGA,EAAE;IAAE67B,KAAK,GAAG7kC,EAAE,CAAC6kC,KAAK;IAAE1Y,aAAa,GAAGnsB,EAAE,CAACmsB,aAAa;IAAErF,oBAAoB,GAAG9mB,EAAE,CAAC8mB,oBAAoB;IAAE+L,kBAAkB,GAAG7yB,EAAE,CAAC6yB,kBAAkB;IAAEiS,cAAc,GAAG9kC,EAAE,CAACskB,MAAM;IAAEygB,qBAAqB,GAAG/kC,EAAE,CAAC+kC,qBAAqB;IAAE9M,cAAc,GAAGj4B,EAAE,CAACi4B,cAAc;IAAEC,gBAAgB,GAAGl4B,EAAE,CAACk4B,gBAAgB;IAAE8M,0BAA0B,GAAGhlC,EAAE,CAACglC,0BAA0B;IAAE1b,gBAAgB,GAAGtpB,EAAE,CAACspB,gBAAgB;IAAErV,2BAA2B,GAAGjU,EAAE,CAACiU,2BAA2B;EACpgB,OAAO,UAAUjU,EAAE,EAAEuO,OAAO,EAAE;IAC1B,IAAI9L,MAAM,GAAGzC,EAAE,CAACyC,MAAM;MAAE3E,KAAK,GAAGkC,EAAE,CAAClC,KAAK;MAAE+E,UAAU,GAAG7C,EAAE,CAAC6C,UAAU;MAAEC,qBAAqB,GAAG9C,EAAE,CAAC8C,qBAAqB;MAAER,WAAW,GAAGtC,EAAE,CAACsC,WAAW;IACpJ,IAAIiM,OAAO,KAAK,KAAK,CAAC,EAAE;MAAEA,OAAO,GAAG,CAAC,CAAC;IAAE;IACxC,IAAIH,YAAY,GAAG9L,WAAW,CAAC8L,YAAY;MAAEyF,WAAW,GAAGvR,WAAW,CAACuR,WAAW;IAClF;AACR;AACA;AACA;AACA;AACA;IACQ,IAAIhQ,QAAQ;IACZ;AACR;AACA;AACA;IACQ,IAAI6/B,UAAU,GAAGH,gBAAgB,EAAE;IACnC;AACR;AACA;IACQ,IAAIl1B,UAAU,GAAGu0B,qBAAqB,EAAE;IACxC;AACR;AACA;AACA;AACA;AACA;IACQ,IAAIhN,gBAAgB;IACpB;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAIqP,cAAc,GAAG52B,UAAU;IAC/B,IAAI62B,gBAAgB,GAAG92B,YAAY;IACnC,IAAI+2B,gCAAgC;IACpC;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI72B,WAAW,GAAGu0B,iBAAiB,EAAE;IACrC;AACR;AACA;IACQ,IAAIuC,UAAU;IACd;AACR;AACA;AACA;IACQ,IAAIC,qBAAqB,GAAG,KAAK;IACjC;AACR;AACA;AACA;AACA;IACQ,IAAInwB,MAAM,GAAG,IAAIrO,GAAG,EAAE;IACtB;AACR;AACA;AACA;IACQ,IAAIy+B,kBAAkB,GAAG,IAAIz+B,GAAG,EAAE;IAClC;AACR;AACA;AACA;AACA;IACQ,IAAI0+B,gBAAgB,GAAG,CAAC,CAAC;IACzB;AACR;AACA;AACA;AACA;AACA;IACQ,IAAIC,wBAAwB;IAC5B;AACR;AACA;AACA;IACQ,IAAIC,UAAU,GAAGtpC,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAEiO,YAAY,CAAC;IACjD;IACA;AACR;AACA;AACA;IACQ,IAAIs3B,qBAAqB;IACzB;AACR;AACA;IACQ,SAASphB,MAAMA,CAAA,EAAG;MACd,IAAI,CAACzgB,QAAQ,EACT;MACJ,IAAI4P,OAAO,CAACkyB,iBAAiB,EAAE,EAAE;QAC7B;AAChB;AACA;AACA;AACA;QACgB5Q,kBAAkB,CAACkQ,cAAc,CAACrK,WAAW,EAAEqK,cAAc,CAACt1B,MAAM,EAAEu1B,gBAAgB,CAAC;QACvF;AAChB;AACA;AACA;AACA;AACA;QACgBjV,cAAc,CAAC3hB,WAAW,CAACiB,UAAU,EAAEjB,WAAW,CAACwkB,eAAe,EAAEmS,cAAc,CAACrK,WAAW,EAAExsB,YAAY,CAAC;MACjH;MACAw3B,YAAY,EAAE;MACdd,cAAc,CAACjhC,QAAQ,EAAEgQ,WAAW,CAAC;IACzC;IACA,SAAS+xB,YAAYA,CAAA,EAAG;MACpB,IAAIC,cAAc,GAAGz3B,YAAY;MACjC,IAAIg3B,UAAU,IAAIA,UAAU,CAAC5qB,QAAQ,EAAE,EAAE;QACrC,IAAIsrB,gBAAgB,GAAGV,UAAU,CAACW,iBAAiB,CAACtyB,OAAO,CAAC;QAC5D,IAAIqyB,gBAAgB,EAChBD,cAAc,GAAGC,gBAAgB;MACzC;MACAjB,KAAK,CAACpxB,OAAO,EAAEI,WAAW,EAAEgyB,cAAc,EAAEZ,cAAc,EAAE32B,WAAW,EAAEC,OAAO,EAAEzQ,KAAK,CAAC;IAC5F;IACA,SAASyvB,MAAMA,CAAA,EAAG;MACdmW,UAAU,CAACsC,YAAY,CAAC53B,YAAY,CAAC;IACzC;IACA,SAAS63B,sBAAsBA,CAAA,EAAG;MAC9B,IAAI,CAACxyB,OAAO,CAACkyB,iBAAiB,EAAE,EAC5B;MACJ,IAAInhB,KAAK,GAAGlW,WAAW,CAACkW,KAAK;QAAEhV,SAAS,GAAGlB,WAAW,CAACkB,SAAS;MAChE,IAAI02B,cAAc,GAAG12B,SAAS,CAAC7G,CAAC;MAChC,IAAIw9B,cAAc,GAAG32B,SAAS,CAAC5G,CAAC;MAChC,IAAIw9B,kBAAkB,GAAG93B,WAAW,CAACw0B,cAAc;MACnDyB,kBAAkB,CAACj2B,WAAW,EAAE22B,cAAc,EAAExxB,OAAO,CAAC4yB,IAAI,EAAEj4B,YAAY,CAAC;MAC3Ei3B,qBAAqB,IACjB5xB,OAAO,CAAC6yB,uBAAuB,CAACrB,cAAc,CAACt1B,MAAM,EAAE6U,KAAK,CAAC;MACjE6gB,qBAAqB,GAAG,KAAK;MAC7B,IAAIvC,cAAc,GAAGE,8BAA8B,CAACxe,KAAK,EAAEhV,SAAS,CAAC;MACrE,IAAIszB,cAAc,KAAKsD,kBAAkB;MACrC;MACAF,cAAc,KAAK12B,SAAS,CAAC7G,CAAC,IAC9Bw9B,cAAc,KAAK32B,SAAS,CAAC5G,CAAC,EAAE;QAChC6K,OAAO,CAAC8yB,cAAc,EAAE;MAC5B;MACAj4B,WAAW,CAACw0B,cAAc,GAAGA,cAAc;IAC/C;IACA,SAAS0D,0BAA0BA,CAAA,EAAG;MAClC/yB,OAAO,CAACgzB,UAAU,CAACxpC,OAAO,CAACypC,0BAA0B,CAAC;IAC1D;IACA;AACR;AACA;IACQ,SAASC,iBAAiBA,CAAC9nC,GAAG,EAAE3C,KAAK,EAAE;MACnC,IAAI0qC,cAAc,GAAG1qC,KAAK,CAAC4oB,QAAQ,CAAC,UAAU+hB,WAAW,EAAE;QACvDz4B,YAAY,CAACvP,GAAG,CAAC,GAAGgoC,WAAW;QAC/B/oC,KAAK,CAACokB,QAAQ,IAAIxkB,aAAa,CAAC,SAAS,CAAC,CAAC6vB,MAAM,CAACA,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC;MAC1E,CAAC,CAAC;MACF,IAAIuZ,qBAAqB,GAAG5qC,KAAK,CAAC+oB,eAAe,CAACxR,OAAO,CAAC8yB,cAAc,CAAC;MACzEjB,kBAAkB,CAACr+B,GAAG,CAACpI,GAAG,EAAE,YAAY;QACpC+nC,cAAc,EAAE;QAChBE,qBAAqB,EAAE;MAC3B,CAAC,CAAC;IACN;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAIC,mBAAmB,GAAG9yB,2BAA2B,CAACnW,KAAK,CAAC;IAC5D,KAAK,IAAIe,GAAG,IAAIkoC,mBAAmB,EAAE;MACjC,IAAI7qC,KAAK,GAAG6qC,mBAAmB,CAACloC,GAAG,CAAC;MACpC,IAAIuP,YAAY,CAACvP,GAAG,CAAC,KAAKuD,SAAS,IAAIqG,aAAa,CAACvM,KAAK,CAAC,EAAE;QACzDA,KAAK,CAAC+K,GAAG,CAACmH,YAAY,CAACvP,GAAG,CAAC,EAAE,KAAK,CAAC;MACvC;IACJ;IACA;AACR;AACA;IACQ,IAAIuW,qBAAqB,GAAGlQ,0BAA0B,CAACpH,KAAK,CAAC;IAC7D,IAAIuX,aAAa,GAAG5P,kBAAkB,CAAC3H,KAAK,CAAC;IAC7C,IAAI2V,OAAO,GAAGtX,KAAK,CAACgE,QAAQ,CAAChE,KAAK,CAACgE,QAAQ,CAAC;MAAEykC,QAAQ,EAAEA,QAAQ;MAC5D;AACZ;AACA;AACA;MACY7jC,OAAO,EAAE,IAAI;MACb;AACZ;AACA;MACYmxB,KAAK,EAAEzvB,MAAM,GAAGA,MAAM,CAACyvB,KAAK,GAAG,CAAC,GAAG,CAAC;MAAEzvB,MAAM,EAAEA,MAAM;MAAE+vB,QAAQ,EAAE,IAAIrqB,GAAG,EAAE;MACzE;AACZ;AACA;AACA;MACYk+B,IAAI,EAAE5jC,MAAM,GAAGtG,KAAK,CAACulB,aAAa,CAACvlB,KAAK,CAACulB,aAAa,CAAC,EAAE,EAAEvlB,KAAK,CAACwhB,MAAM,CAAClb,MAAM,CAAC4jC,IAAI,CAAC,CAAC,EAAE,CAAC5jC,MAAM,CAAC,CAAC,GAAG,EAAE;MAAEgkC,UAAU,EAAEhkC,MAAM,GAAGA,MAAM,CAACgkC,UAAU,GAAG,IAAIjC,QAAQ,EAAE;MAC9J;AACZ;AACA;MACY3hC,UAAU,EAAEA,UAAU;MACtBwL,UAAU,EAAEA,UAAU;MACtB;AACZ;AACA;AACA;AACA;MACYgZ,eAAe,EAAEhS,aAAa,GAAG,IAAIlN,GAAG,EAAE,GAAG/F,SAAS;MACtD;AACZ;AACA;AACA;AACA;AACA;MACY4kC,SAAS,EAAE5kC,SAAS;MACpB;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;MACYipB,sBAAsB,EAAE3lB,OAAO,CAACjD,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAACwkC,SAAS,EAAE,CAAC;MACnG;AACZ;AACA;AACA;MACYnkC,qBAAqB,EAAEA,qBAAqB;MAC5C;AACZ;AACA;AACA;AACA;MACYmkC,SAAS,EAAE,SAAAA,CAAA,EAAY;QAAE,OAAOvhC,OAAO,CAAC7B,QAAQ,CAAC;MAAE,CAAC;MAAEC,KAAK,EAAE,SAAAA,CAAUojC,WAAW,EAAE;QAChFrjC,QAAQ,GAAG4P,OAAO,CAAC1S,OAAO,GAAGmmC,WAAW;QACxCzzB,OAAO,CAAC0zB,OAAO,CAAC1zB,OAAO,CAAC;QACxB,IAAI4B,aAAa,IAAI5S,MAAM,IAAI,CAAC2S,qBAAqB,EAAE;UACnDswB,qBAAqB,GAAGjjC,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAAC2kC,eAAe,CAAC3zB,OAAO,CAAC;QAC3G;QACAhR,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAAC+vB,QAAQ,CAACnP,GAAG,CAAC5P,OAAO,CAAC;MAChF,CAAC;MACD;AACZ;AACA;MACY1P,OAAO,EAAE,SAAAA,CAAA,EAAY;QACjBtH,IAAI,CAACuxB,UAAU,CAACT,MAAM,CAACA,MAAM,CAAC;QAC9B9wB,IAAI,CAACuxB,UAAU,CAAC1J,MAAM,CAACA,MAAM,CAAC;QAC9B7nB,IAAI,CAACuxB,UAAU,CAACyK,SAAS,CAAChlB,OAAO,CAACwyB,sBAAsB,CAAC;QACzDX,kBAAkB,CAACroC,OAAO,CAAC,UAAUqlC,MAAM,EAAE;UAAE,OAAOA,MAAM,EAAE;QAAE,CAAC,CAAC;QAClE7uB,OAAO,CAAC2nB,mBAAmB,EAAE;QAC7B3nB,OAAO,CAACgzB,UAAU,CAACnE,MAAM,CAAC7uB,OAAO,CAAC;QAClCiyB,qBAAqB,KAAK,IAAI,IAAIA,qBAAqB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,qBAAqB,EAAE;QACrGjjC,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAAC+vB,QAAQ,CAACzG,MAAM,CAACtY,OAAO,CAAC;QAC/E0xB,gCAAgC,KAAK,IAAI,IAAIA,gCAAgC,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,gCAAgC,EAAE;QACtIzB,UAAU,CAACC,iBAAiB,EAAE;MAClC,CAAC;MACD;AACZ;AACA;MACYyD,eAAe,EAAE,SAAAA,CAAUpsB,KAAK,EAAE;QAC9B,IAAIhb,EAAE;QACN,IAAIqnC,kBAAkB,GAAG5zB,OAAO,CAAC6zB,qBAAqB,EAAE;QACxD,IAAID,kBAAkB,EAAE;UACpB,CAACrnC,EAAE,GAAGqnC,kBAAkB,CAAChgB,eAAe,MAAM,IAAI,IAAIrnB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACqjB,GAAG,CAACrI,KAAK,CAAC;UAC5F,OAAO,YAAY;YAAE,OAAOqsB,kBAAkB,CAAChgB,eAAe,CAAC0E,MAAM,CAAC/Q,KAAK,CAAC;UAAE,CAAC;QACnF;MACJ,CAAC;MACDsO,gBAAgB,EAAE,SAAAA,CAAUie,KAAK,EAAE;QAC/B;AAChB;AACA;QACgB,IAAI,CAACje,gBAAgB,IAAIsb,QAAQ,KAAK2C,KAAK,CAAC3C,QAAQ,EAChD,OAAO,CAAC;QACZ,OAAOtb,gBAAgB,CAAC7V,OAAO,CAACqI,WAAW,EAAE,EAAEyrB,KAAK,CAACzrB,WAAW,EAAE,CAAC;MACvE,CAAC;MACD;AACZ;AACA;AACA;MACYwrB,qBAAqB,EAAE,SAAAA,CAAA,EAAY;QAC/B,OAAOjyB,aAAa,GAAG5B,OAAO,GAAGhR,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAAC6kC,qBAAqB,EAAE;MACnH,CAAC;MACD;AACZ;AACA;AACA;AACA;MACYhP,8BAA8B,EAAE71B,MAAM,GAChCA,MAAM,CAAC61B,8BAA8B,GACrC,YAAY;QACV,OAAO56B,aAAa,CAAC,SAAS,CAAC,CAAC+6B,SAAS,CAAChlB,OAAO,CAAC+yB,0BAA0B,EAAE,KAAK,EAAE,IAAI,CAAC;MAC9F,CAAC;MACL;AACZ;AACA;MACYhT,WAAW,EAAE,SAAAA,CAAA,EAAY;QAAE,OAAO11B,KAAK,CAACoE,QAAQ;MAAE,CAAC;MACnD;AACZ;AACA;MACY4Z,WAAW,EAAE,SAAAA,CAAA,EAAY;QAAE,OAAOjY,QAAQ;MAAE,CAAC;MAC7C;AACZ;AACA;MACYwgC,cAAc,EAAE,SAAAA,CAAUxlC,GAAG,EAAE;QAAE,OAAOuP,YAAY,CAACvP,GAAG,CAAC;MAAE,CAAC;MAAE2oC,cAAc,EAAE,SAAAA,CAAU3oC,GAAG,EAAE3C,KAAK,EAAE;QAAE,OAAQkS,YAAY,CAACvP,GAAG,CAAC,GAAG3C,KAAK;MAAG,CAAC;MAC3I;AACZ;AACA;AACA;AACA;MACYu5B,eAAe,EAAE,SAAAA,CAAA,EAAY;QAAE,OAAOrnB,YAAY;MAAE,CAAC;MACrD;AACZ;AACA;AACA;MACY6xB,aAAa,EAAE,SAAAA,CAAUwH,UAAU,EAAE;QACjC,IAAIh0B,OAAO,CAACuzB,SAAS,KAAKS,UAAU,EAChC;QACJh0B,OAAO,CAACuzB,SAAS,GAAGS,UAAU;QAC9Bh0B,OAAO,CAAC8yB,cAAc,EAAE;MAC5B,CAAC;MACD;AACZ;AACA;AACA;AACA;AACA;AACA;MACYzf,oBAAoB,EAAE,SAAAA,CAAUnX,MAAM,EAAE+3B,SAAS,EAAE;QAC/C,IAAIA,SAAS,KAAK,KAAK,CAAC,EAAE;UAAEA,SAAS,GAAG,IAAI;QAAE;QAC9C,OAAO5gB,oBAAoB,CAACrT,OAAO,EAAE9D,MAAM,EAAE7R,KAAK,EAAE4pC,SAAS,CAAC;MAClE,CAAC;MACD;MACA;AACZ;AACA;MACY9gB,QAAQ,EAAE,SAAAA,CAAU/nB,GAAG,EAAE3C,KAAK,EAAE;QAC5B;QACA,IAAIuX,OAAO,CAACiT,QAAQ,CAAC7nB,GAAG,CAAC,EACrB4U,OAAO,CAAC6wB,WAAW,CAACzlC,GAAG,CAAC;QAC5BqW,MAAM,CAACjO,GAAG,CAACpI,GAAG,EAAE3C,KAAK,CAAC;QACtBkS,YAAY,CAACvP,GAAG,CAAC,GAAG3C,KAAK,CAACmB,GAAG,EAAE;QAC/BspC,iBAAiB,CAAC9nC,GAAG,EAAE3C,KAAK,CAAC;MACjC,CAAC;MACD;AACZ;AACA;MACYooC,WAAW,EAAE,SAAAA,CAAUzlC,GAAG,EAAE;QACxB,IAAImB,EAAE;QACNkV,MAAM,CAAC6W,MAAM,CAACltB,GAAG,CAAC;QAClB,CAACmB,EAAE,GAAGslC,kBAAkB,CAACjoC,GAAG,CAACwB,GAAG,CAAC,MAAM,IAAI,IAAImB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,EAAE;QAC5EslC,kBAAkB,CAACvZ,MAAM,CAACltB,GAAG,CAAC;QAC9B,OAAOuP,YAAY,CAACvP,GAAG,CAAC;QACxBmmC,0BAA0B,CAACnmC,GAAG,EAAEgV,WAAW,CAAC;MAChD,CAAC;MACD;AACZ;AACA;MACY6S,QAAQ,EAAE,SAAAA,CAAU7nB,GAAG,EAAE;QAAE,OAAOqW,MAAM,CAAClO,GAAG,CAACnI,GAAG,CAAC;MAAE,CAAC;MACpD;AACZ;AACA;AACA;MACY8nB,QAAQ,EAAE,SAAAA,CAAU9nB,GAAG,EAAE8oC,YAAY,EAAE;QACnC,IAAIzrC,KAAK,GAAGgZ,MAAM,CAAC7X,GAAG,CAACwB,GAAG,CAAC;QAC3B,IAAI3C,KAAK,KAAKkG,SAAS,IAAIulC,YAAY,KAAKvlC,SAAS,EAAE;UACnDlG,KAAK,GAAG2pB,WAAW,CAAC8hB,YAAY,CAAC;UACjCl0B,OAAO,CAACmT,QAAQ,CAAC/nB,GAAG,EAAE3C,KAAK,CAAC;QAChC;QACA,OAAOA,KAAK;MAChB,CAAC;MACD;AACZ;AACA;MACYoI,YAAY,EAAE,SAAAA,CAAUmW,QAAQ,EAAE;QAAE,OAAOvF,MAAM,CAACjY,OAAO,CAACwd,QAAQ,CAAC;MAAE,CAAC;MACtE;AACZ;AACA;AACA;AACA;MACYkN,SAAS,EAAE,SAAAA,CAAU9oB,GAAG,EAAE;QAAE,IAAImB,EAAE;QAAE,OAAO,CAACA,EAAE,GAAGoO,YAAY,CAACvP,GAAG,CAAC,MAAM,IAAI,IAAImB,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG+kC,qBAAqB,CAAClhC,QAAQ,EAAEhF,GAAG,EAAE0P,OAAO,CAAC;MAAE,CAAC;MACrJ;AACZ;AACA;AACA;MACYqZ,aAAa,EAAE,SAAAA,CAAU/oB,GAAG,EAAE3C,KAAK,EAAE;QACjCupC,UAAU,CAAC5mC,GAAG,CAAC,GAAG3C,KAAK;MAC3B,CAAC;MACD;AACZ;AACA;AACA;MACYiwB,aAAa,EAAE,SAAAA,CAAUttB,GAAG,EAAE;QAC1B,IAAIstB,aAAa,EAAE;UACf,IAAIxc,MAAM,GAAGwc,aAAa,CAACruB,KAAK,EAAEe,GAAG,CAAC;UACtC,IAAI8Q,MAAM,KAAKvN,SAAS,IAAI,CAACqG,aAAa,CAACkH,MAAM,CAAC,EAC9C,OAAOA,MAAM;QACrB;QACA,OAAO81B,UAAU,CAAC5mC,GAAG,CAAC;MAC1B;IAAE,CAAC,EAAE6kC,UAAU,CAAC,EAAE;MAClB;AACZ;AACA;MACYmB,KAAK,EAAE,SAAAA,CAAA,EAAY;QACfe,YAAY,EAAE;QACd,OAAO/xB,WAAW;MACtB,CAAC;MACD;AACZ;AACA;MACY0yB,cAAc,EAAE,SAAAA,CAAA,EAAY;QACxB7oC,aAAa,CAAC,SAAS,CAAC,CAAC4mB,MAAM,CAACA,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC;MACxD,CAAC;MACD;AACZ;AACA;AACA;AACA;AACA;MACYphB,UAAU,EAAEohB,MAAM;MAClB;AACZ;AACA;AACA;MACYthB,QAAQ,EAAE,SAAAA,CAAU4kC,QAAQ,EAAE;QAC1B9pC,KAAK,GAAG8pC,QAAQ;QAChBlE,UAAU,CAACG,mBAAmB,CAAC+D,QAAQ,CAAC;QACxCrC,gBAAgB,GAAGrB,2BAA2B,CAACzwB,OAAO,EAAEQ,2BAA2B,CAACnW,KAAK,CAAC,EAAEynC,gBAAgB,CAAC;MACjH,CAAC;MAAEtgC,QAAQ,EAAE,SAAAA,CAAA,EAAY;QAAE,OAAOnH,KAAK;MAAE,CAAC;MAC1C;MACA;AACZ;AACA;MACYspB,UAAU,EAAE,SAAAA,CAAUppB,IAAI,EAAE;QAAE,IAAIgC,EAAE;QAAE,OAAO,CAACA,EAAE,GAAGlC,KAAK,CAACiH,QAAQ,MAAM,IAAI,IAAI/E,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAChC,IAAI,CAAC;MAAE,CAAC;MACnH;AACZ;AACA;MACYmhB,oBAAoB,EAAE,SAAAA,CAAA,EAAY;QAAE,OAAOrhB,KAAK,CAAC4X,UAAU;MAAE,CAAC;MAC9D;AACZ;AACA;MACYiV,iBAAiB,EAAE,SAAAA,CAAUkd,aAAa,EAAE;QACxC,IAAIA,aAAa,KAAK,KAAK,CAAC,EAAE;UAAEA,aAAa,GAAG,KAAK;QAAE;QACvD,IAAIA,aAAa,EACb,OAAOplC,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAACkoB,iBAAiB,EAAE;QACrF,IAAI,CAACvV,qBAAqB,EAAE;UACxB,IAAI0yB,SAAS,GAAG,CAACrlC,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAACkoB,iBAAiB,EAAE,KAAK,CAAC,CAAC;UAClG,IAAI7sB,KAAK,CAACiF,OAAO,KAAKX,SAAS,EAAE;YAC7B0lC,SAAS,CAAC/kC,OAAO,GAAGjF,KAAK,CAACiF,OAAO;UACrC;UACA,OAAO+kC,SAAS;QACpB;QACA,IAAI7mC,OAAO,GAAG,CAAC,CAAC;QAChB,KAAK,IAAInB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGioC,eAAe,EAAEjoC,CAAC,EAAE,EAAE;UACtC,IAAIC,MAAM,GAAGioC,YAAY,CAACloC,CAAC,CAAC;UAC5B,IAAIkG,IAAI,GAAGlI,KAAK,CAACiC,MAAM,CAAC;UACxB,IAAIqE,cAAc,CAAC4B,IAAI,CAAC,IAAIA,IAAI,KAAK,KAAK,EAAE;YACxC/E,OAAO,CAAClB,MAAM,CAAC,GAAGiG,IAAI;UAC1B;QACJ;QACA,OAAO/E,OAAO;MAClB,CAAC;MACD;MACA;AACZ;AACA;AACA;MACYq2B,sBAAsB,EAAE,SAAAA,CAAA,EAAY;QAChCjpB,UAAU,CAACxQ,SAAS,GAAG,IAAI;QAC3B4V,OAAO,CAACgzB,UAAU,CAACpjB,GAAG,CAAC5P,OAAO,CAAC;MACnC,CAAC;MACD;AACZ;AACA;AACA;MACYukB,oBAAoB,EAAE,SAAAA,CAAA,EAAY;QAC9B3pB,UAAU,CAAC2xB,cAAc,GAAG,IAAI;MACpC,CAAC;MACDvG,sBAAsB,EAAE,SAAAA,CAAA,EAAY;QAChChmB,OAAO,CAAC2nB,mBAAmB,EAAE;QAC7B/sB,UAAU,CAAC2xB,cAAc,GAAG,KAAK;MACrC,CAAC;MAAErN,cAAc,EAAE,SAAAA,CAAA,EAAY;QAAE,OAAOrkB,WAAW;MAAE,CAAC;MAAE25B,aAAa,EAAE,SAAAA,CAAUC,aAAa,EAAE;QAC5F9C,UAAU,GAAG8C,aAAa;MAC9B,CAAC;MAAEvC,iBAAiB,EAAE,SAAAA,CAAA,EAAY;QAC9B,OAAOt3B,UAAU,CAACxQ,SAAS,IACvBwQ,UAAU,CAACc,UAAU,IACrBb,WAAW,CAACa,UAAU;MAC9B,CAAC;MACD;AACZ;AACA;MACY+rB,oBAAoB,EAAE,SAAAA,CAAUtL,IAAI,EAAEla,UAAU,EAAEglB,UAAU,EAAE;QAC1D,IAAIA,UAAU,KAAK,KAAK,CAAC,EAAE;UAAEA,UAAU,GAAG,KAAK;QAAE;QACjD,IAAIjpB,QAAQ,GAAGgC,OAAO,CAACmtB,8BAA8B,EAAE,CAAChR,IAAI,CAAC;QAC7D,IAAI5vB,EAAE,GAAG06B,UAAU,GACbrsB,UAAU,CAACkiB,cAAc,CAACX,IAAI,CAAC,GAC/BvhB,UAAU,CAACsB,MAAM,CAACigB,IAAI,CAAC;UAAElB,GAAG,GAAG1uB,EAAE,CAAC0uB,GAAG;UAAEC,GAAG,GAAG3uB,EAAE,CAAC2uB,GAAG;QACzD,IAAIvvB,MAAM,GAAGuvB,GAAG,GAAGD,GAAG;QACtBjd,QAAQ,CAACuT,cAAc,EAAE;QACzBvT,QAAQ,CAACxK,GAAG,CAACynB,GAAG,CAAC;QACjBjd,QAAQ,CAACxK,GAAG,CAACynB,GAAG,CAAC,CAAC,CAAC;QACnBjd,QAAQ,CAACqT,QAAQ,CAAC,UAAU7gB,CAAC,EAAE;UAC3BwP,OAAO,CAACqiB,uBAAuB,CAAClG,IAAI,EAAE3rB,CAAC,EAAEA,CAAC,GAAG7E,MAAM,EAAEs7B,UAAU,CAAC;QACpE,CAAC,CAAC;QACF,OAAOjnB,OAAO,CAAC6sB,kBAAkB,CAAC1Q,IAAI,EAAEne,QAAQ,EAAE,CAAC,EAAEiE,UAAU,CAAC;MACpE,CAAC;MACD;AACZ;AACA;MACY0lB,mBAAmB,EAAE,SAAAA,CAAA,EAAY;QAC7B9L,QAAQ,CAAC,UAAUM,IAAI,EAAE;UACrB,OAAOnc,OAAO,CAACmtB,8BAA8B,EAAE,CAAChR,IAAI,CAAC,CAACxN,IAAI,EAAE;QAChE,CAAC,CAAC;MACN,CAAC;MACD;AACZ;AACA;AACA;AACA;MACYyQ,kBAAkB,EAAE,SAAAA,CAAUsV,aAAa,EAAE;QACzC,IAAIA,aAAa,KAAK,KAAK,CAAC,EAAE;UAAEA,aAAa,GAAG,IAAI;QAAE;QACtD,IAAIC,WAAW,GAAGvV,kBAAkB,CAAChvB,QAAQ,EAAE0K,OAAO,CAAC;QACvD,IAAI,CAAC45B,aAAa,EACd/S,mBAAmB,CAACgT,WAAW,EAAEh6B,YAAY,CAAC;QAClD,OAAOg6B,WAAW;MACtB,CAAC;MACD;AACZ;AACA;AACA;MACYxH,8BAA8B,EAAE,SAAAA,CAAA,EAAY;QACxC4E,wBAAwB,KAAKA,wBAAwB,GAAG;UACpD78B,CAAC,EAAEkd,WAAW,CAAC,CAAC,CAAC;UACjBjd,CAAC,EAAEid,WAAW,CAAC,CAAC;QACpB,CAAC,CAAC;QACF,OAAO2f,wBAAwB;MACnC,CAAC;MACD;AACZ;AACA;AACA;MACY1P,uBAAuB,EAAE,SAAAA,CAAUlG,IAAI,EAAElB,GAAG,EAAEC,GAAG,EAAE+L,UAAU,EAAE;QAC3D,IAAIA,UAAU,KAAK,KAAK,CAAC,EAAE;UAAEA,UAAU,GAAG,KAAK;QAAE;QACjD,IAAI/qB,MAAM;QACV,IAAI+qB,UAAU,EAAE;UACZ,IAAI,CAACrsB,UAAU,CAACkiB,cAAc,EAAE;YAC5BliB,UAAU,CAACkiB,cAAc,GAAGvB,OAAO,EAAE;UACzC;UACArf,MAAM,GAAGtB,UAAU,CAACkiB,cAAc,CAACX,IAAI,CAAC;QAC5C,CAAC,MACI;UACDvhB,UAAU,CAACkiB,cAAc,GAAGnuB,SAAS;UACrCuN,MAAM,GAAGtB,UAAU,CAACsB,MAAM,CAACigB,IAAI,CAAC;QACpC;QACAvhB,UAAU,CAACc,UAAU,GAAG,IAAI;QAC5BQ,MAAM,CAAC+e,GAAG,GAAGA,GAAG;QAChB/e,MAAM,CAACgf,GAAG,GAAGA,GAAG;QAChB;QACA0W,qBAAqB,GAAG,IAAI;QAC5B3B,UAAU,CAAC2E,mBAAmB,EAAE;MACpC,CAAC;MACD;AACZ;AACA;AACA;AACA;AACA;MACYpV,sBAAsB,EAAE,SAAAA,CAAUqV,KAAK,EAAEpZ,GAAG,EAAE;QAC1C,IAAIA,GAAG,KAAK,KAAK,CAAC,EAAE;UAAEA,GAAG,GAAG5gB,WAAW,CAAC9F,MAAM;QAAE;QAChD,IAAIxI,EAAE,GAAGyT,OAAO,CAACmtB,8BAA8B,EAAE;UAAEj4B,CAAC,GAAG3I,EAAE,CAAC2I,CAAC;UAAEC,CAAC,GAAG5I,EAAE,CAAC4I,CAAC;QACrE,IAAI2/B,YAAY,GAAG,CAACl6B,UAAU,CAACkiB,cAAc,IACzC,CAACliB,UAAU,CAAC2xB,cAAc,IAC1B,CAACr3B,CAAC,CAACgd,WAAW,EAAE,IAChB,CAAC/c,CAAC,CAAC+c,WAAW,EAAE;QACpB,IAAI2iB,KAAK,IAAIC,YAAY,EAAE;UACvBjZ,QAAQ,CAAC,UAAUM,IAAI,EAAE;YACrB,IAAI5vB,EAAE,GAAGkvB,GAAG,CAACU,IAAI,CAAC;cAAElB,GAAG,GAAG1uB,EAAE,CAAC0uB,GAAG;cAAEC,GAAG,GAAG3uB,EAAE,CAAC2uB,GAAG;YAC9Clb,OAAO,CAACqiB,uBAAuB,CAAClG,IAAI,EAAElB,GAAG,EAAEC,GAAG,CAAC;UACnD,CAAC,CAAC;QACN;MACJ,CAAC;MACD;AACZ;AACA;AACA;AACA;MACY2S,iBAAiB,EAAE,SAAAA,CAAU9+B,MAAM,EAAE;QACjCkiC,qBAAqB,CAACjxB,OAAO,CAAC;QAC9BA,OAAO,CAAC+0B,kBAAkB,CAACl6B,WAAW,CAAC9F,MAAM,EAAEiL,OAAO,CAACuf,eAAe,IAAI1kB,WAAW,CAAC9F,MAAM,EAAEhG,MAAM,CAAC;MACzG,CAAC;MACD;AACZ;AACA;MACYy1B,cAAc,EAAE,SAAAA,CAAA,EAAY;QAAE,OAAOA,cAAc,CAACxkB,OAAO,EAAE5P,QAAQ,EAAE/F,KAAK,CAAC;MAAE,CAAC;MAAEo6B,gBAAgB,EAAE,SAAAA,CAAA,EAAY;QAAE,OAAOA,gBAAgB,CAACr0B,QAAQ,EAAEgQ,WAAW,CAAC;MAAE,CAAC;MAAEoyB,sBAAsB,EAAEA,sBAAsB;MACnNO,0BAA0B,EAAE,SAAAA,CAAA,EAAY;QACpC/yB,OAAO,CAACgzB,UAAU,CAACxpC,OAAO,CAACwrC,4BAA4B,CAAC;QACxD;AAChB;AACA;AACA;AACA;AACA;QACgB/qC,aAAa,CAAC,SAAS,CAAC,CAAC+6B,SAAS,CAAC+N,0BAA0B,EAAE,KAAK,EAAE,IAAI,CAAC;QAC3E;MACJ,CAAC;;MACD3Q,mBAAmB,EAAE,SAAAA,CAAA,EAAY;QAC7B,IAAID,gBAAgB,KAAKxzB,SAAS,EAAE;UAChC,IAAIsmC,WAAW,GAAG,KAAK;UACvB;UACA,KAAK,IAAI5oC,CAAC,GAAG2T,OAAO,CAAC4yB,IAAI,CAACjnC,MAAM,GAAG,CAAC,EAAEU,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;YAC/C,IAAI6oC,QAAQ,GAAGl1B,OAAO,CAAC4yB,IAAI,CAACvmC,CAAC,CAAC;YAC9B,IAAI6oC,QAAQ,CAACt6B,UAAU,CAACxQ,SAAS,EAAE;cAC/B6qC,WAAW,GAAGC,QAAQ;cACtB;YACJ;UACJ;UACA/S,gBAAgB,GAAG8S,WAAW;QAClC;QACA,OAAO9S,gBAAgB;MAC3B,CAAC;MACDgT,wBAAwB,EAAE,SAAAA,CAAA,EAAY;QAClC,IAAIC,cAAc,GAAGp1B,OAAO,CAACoiB,mBAAmB,EAAE;QAClD,IAAI,CAACxnB,UAAU,CAACkiB,cAAc,IAAI,CAACsY,cAAc,EAC7C;QACJxY,eAAe,CAAChiB,UAAU,EAAEw6B,cAAc,CAACx6B,UAAU,CAAC;QACtD,IAAIqlB,WAAW,CAACmV,cAAc,CAAC,EAAE;UAC7B,IAAIl5B,MAAM,GAAGtB,UAAU,CAACsB,MAAM;UAC9BolB,kBAAkB,CAACplB,MAAM,EAAEA,MAAM,EAAEk5B,cAAc,CAACpT,eAAe,EAAE,CAAC;QACxE;MACJ,CAAC;MACDrD,oBAAoB,EAAE,SAAAA,CAAA,EAAY;QAC9B,OAAO1sB,OAAO,CAAC5H,KAAK,CAACgrC,qBAAqB,CAAC;MAC/C,CAAC;MACD;AACZ;AACA;MACY3B,OAAO,EAAE,SAAAA,CAAU4B,OAAO,EAAE;QACxB9D,cAAc,GAAG8D,OAAO,CAAC16B,UAAU;QACnC62B,gBAAgB,GAAG6D,OAAO,CAACtT,eAAe,EAAE;QAC5C;AAChB;AACA;QACgB0P,gCAAgC,KAAK,IAAI,IAAIA,gCAAgC,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,gCAAgC,EAAE;QACtIA,gCAAgC,GAAG3oC,SAAS,CAACyf,IAAI,CAAC8sB,OAAO,CAACC,eAAe,CAACv1B,OAAO,CAAC6kB,8BAA8B,CAAC,EAAEyQ,OAAO,CAACE,yBAAyB,CAAC,YAAY;UAC7J,IAAIjpC,EAAE;UACN,IAAIyT,OAAO,CAACvS,SAAS,EAAE;YACnBuS,OAAO,CAACkuB,QAAQ,GAAGhF,QAAQ,CAACiF,OAAO;UACvC,CAAC,MACI;YACD,CAAC5hC,EAAE,GAAGyT,OAAO,CAAC+sB,kBAAkB,MAAM,IAAI,IAAIxgC,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACyD,IAAI,CAACgQ,OAAO,CAAC;UAC3F;QACJ,CAAC,CAAC,CAAC;MACP,CAAC;MACD;MACAvS,SAAS,EAAE,IAAI;MAAEygC,QAAQ,EAAEhF,QAAQ,CAACuM;IAAS,CAAC,CAAC;IACnD,OAAOz1B,OAAO;EAClB,CAAC;AACL,CAAC;AACD,SAASg1B,4BAA4BA,CAACztB,KAAK,EAAE;EACzCA,KAAK,CAAC4tB,wBAAwB,EAAE;AACpC;AACA,SAASlC,0BAA0BA,CAAC1rB,KAAK,EAAE;EACvCA,KAAK,CAACirB,sBAAsB,EAAE;AAClC;AACA,IAAI+B,YAAY,GAAG7rC,KAAK,CAACulB,aAAa,CAAC,CAAC,SAAS,CAAC,EAAEvlB,KAAK,CAACwhB,MAAM,CAAC+L,oBAAoB,CAAC,CAAC;AACvF,IAAIqe,eAAe,GAAGC,YAAY,CAAC5oC,MAAM;AAEzC,IAAI+pC,cAAc,GAAG,IAAIhhC,GAAG,CAAC,CACzB,OAAO,EACP,QAAQ,EACR,KAAK,EACL,MAAM,EACN,OAAO,EACP,QAAQ,EACR,GAAG,EACH,GAAG,CACN,CAAC;AACF,IAAIihC,eAAe,GAAG,SAAAA,CAAUvqC,GAAG,EAAE;EAAE,OAAOsqC,cAAc,CAACniC,GAAG,CAACnI,GAAG,CAAC;AAAE,CAAC;AACxE,IAAIwqC,gBAAgB,GAAG,SAAAA,CAAU15B,MAAM,EAAE;EACrC,OAAO5T,MAAM,CAACiB,IAAI,CAAC2S,MAAM,CAAC,CAAC5R,IAAI,CAACqrC,eAAe,CAAC;AACpD,CAAC;AACD,IAAIE,mBAAmB,GAAG,SAAAA,CAAUptC,KAAK,EAAEyiB,EAAE,EAAE;EAC3C;EACA;EACAziB,KAAK,CAAC+K,GAAG,CAAC0X,EAAE,EAAE,KAAK,CAAC;EACpBziB,KAAK,CAAC+K,GAAG,CAAC0X,EAAE,CAAC;AACjB,CAAC;AACD,IAAI4qB,aAAa,GAAG,SAAAA,CAAUtlC,CAAC,EAAE;EAC7B,OAAOA,CAAC,KAAK1H,eAAe,CAACgO,MAAM,IAAItG,CAAC,KAAK1H,eAAe,CAACqO,EAAE;AACnE,CAAC;AACD,IAAI4+B,oBAAoB;AACxB,CAAC,UAAUA,oBAAoB,EAAE;EAC7BA,oBAAoB,CAAC,OAAO,CAAC,GAAG,OAAO;EACvCA,oBAAoB,CAAC,QAAQ,CAAC,GAAG,QAAQ;EACzCA,oBAAoB,CAAC,MAAM,CAAC,GAAG,MAAM;EACrCA,oBAAoB,CAAC,OAAO,CAAC,GAAG,OAAO;EACvCA,oBAAoB,CAAC,KAAK,CAAC,GAAG,KAAK;EACnCA,oBAAoB,CAAC,QAAQ,CAAC,GAAG,QAAQ;AAC7C,CAAC,EAAEA,oBAAoB,KAAKA,oBAAoB,GAAG,CAAC,CAAC,CAAC,CAAC;AACvD,IAAIC,gBAAgB,GAAG,SAAAA,CAAUC,MAAM,EAAEC,GAAG,EAAE;EAC1C,OAAOtnB,UAAU,CAACqnB,MAAM,CAACE,KAAK,CAAC,IAAI,CAAC,CAACD,GAAG,CAAC,CAAC;AAC9C,CAAC;AACD,IAAIE,sBAAsB,GAAG,SAAAA,CAAUC,IAAI,EAAEC,IAAI,EAAE;EAAE,OAAO,UAAUC,KAAK,EAAEhqC,EAAE,EAAE;IAC7E,IAAImJ,SAAS,GAAGnJ,EAAE,CAACmJ,SAAS;IAC5B,IAAIA,SAAS,KAAK,MAAM,IAAI,CAACA,SAAS,EAClC,OAAO,CAAC;IACZ,IAAI8gC,QAAQ,GAAG9gC,SAAS,CAAC6zB,KAAK,CAAC,oBAAoB,CAAC;IACpD,IAAIiN,QAAQ,EAAE;MACV,OAAOR,gBAAgB,CAACQ,QAAQ,CAAC,CAAC,CAAC,EAAEF,IAAI,CAAC;IAC9C,CAAC,MACI;MACD,IAAIL,MAAM,GAAGvgC,SAAS,CAAC6zB,KAAK,CAAC,kBAAkB,CAAC;MAChD,IAAI0M,MAAM,EAAE;QACR,OAAOD,gBAAgB,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEI,IAAI,CAAC;MAC5C,CAAC,MACI;QACD,OAAO,CAAC;MACZ;IACJ;EACJ,CAAC;AAAE,CAAC;AACJ,IAAI1gC,aAAa,GAAG,IAAIjB,GAAG,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AAC5C,IAAI+hC,6BAA6B,GAAGtiC,cAAc,CAACmY,MAAM,CAAC,UAAUlhB,GAAG,EAAE;EAAE,OAAO,CAACuK,aAAa,CAACpC,GAAG,CAACnI,GAAG,CAAC;AAAE,CAAC,CAAC;AAC7G,SAASsrC,+BAA+BA,CAAC7qC,aAAa,EAAE;EACpD,IAAI8qC,iBAAiB,GAAG,EAAE;EAC1BF,6BAA6B,CAACjtC,OAAO,CAAC,UAAU4B,GAAG,EAAE;IACjD,IAAI3C,KAAK,GAAGoD,aAAa,CAACqnB,QAAQ,CAAC9nB,GAAG,CAAC;IACvC,IAAI3C,KAAK,KAAKkG,SAAS,EAAE;MACrBgoC,iBAAiB,CAACnqC,IAAI,CAAC,CAACpB,GAAG,EAAE3C,KAAK,CAACmB,GAAG,EAAE,CAAC,CAAC;MAC1CnB,KAAK,CAAC+K,GAAG,CAACpI,GAAG,CAACsL,UAAU,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IAC9C;EACJ,CAAC,CAAC;EACF;EACA,IAAIigC,iBAAiB,CAAChrC,MAAM,EACxBE,aAAa,CAAC4D,UAAU,EAAE;EAC9B,OAAOknC,iBAAiB;AAC5B;AACA,IAAIC,gBAAgB,GAAG;EACnB;EACA9+B,KAAK,EAAE,SAAAA,CAAUvL,EAAE,EAAE;IACjB,IAAI2I,CAAC,GAAG3I,EAAE,CAAC2I,CAAC;IACZ,OAAOA,CAAC,CAACgmB,GAAG,GAAGhmB,CAAC,CAAC+lB,GAAG;EACxB,CAAC;EACDjjB,MAAM,EAAE,SAAAA,CAAUzL,EAAE,EAAE;IAClB,IAAI4I,CAAC,GAAG5I,EAAE,CAAC4I,CAAC;IACZ,OAAOA,CAAC,CAAC+lB,GAAG,GAAG/lB,CAAC,CAAC8lB,GAAG;EACxB,CAAC;EACD9iB,GAAG,EAAE,SAAAA,CAAUo+B,KAAK,EAAEhqC,EAAE,EAAE;IACtB,IAAI4L,GAAG,GAAG5L,EAAE,CAAC4L,GAAG;IAChB,OAAOyW,UAAU,CAACzW,GAAG,CAAC;EAC1B,CAAC;EACDG,IAAI,EAAE,SAAAA,CAAUi+B,KAAK,EAAEhqC,EAAE,EAAE;IACvB,IAAI+L,IAAI,GAAG/L,EAAE,CAAC+L,IAAI;IAClB,OAAOsW,UAAU,CAACtW,IAAI,CAAC;EAC3B,CAAC;EACDD,MAAM,EAAE,SAAAA,CAAU9L,EAAE,EAAEgJ,EAAE,EAAE;IACtB,IAAIJ,CAAC,GAAG5I,EAAE,CAAC4I,CAAC;IACZ,IAAIgD,GAAG,GAAG5C,EAAE,CAAC4C,GAAG;IAChB,OAAOyW,UAAU,CAACzW,GAAG,CAAC,IAAIhD,CAAC,CAAC+lB,GAAG,GAAG/lB,CAAC,CAAC8lB,GAAG,CAAC;EAC5C,CAAC;EACD7iB,KAAK,EAAE,SAAAA,CAAU7L,EAAE,EAAEgJ,EAAE,EAAE;IACrB,IAAIL,CAAC,GAAG3I,EAAE,CAAC2I,CAAC;IACZ,IAAIoD,IAAI,GAAG/C,EAAE,CAAC+C,IAAI;IAClB,OAAOsW,UAAU,CAACtW,IAAI,CAAC,IAAIpD,CAAC,CAACgmB,GAAG,GAAGhmB,CAAC,CAAC+lB,GAAG,CAAC;EAC7C,CAAC;EACD;EACA/lB,CAAC,EAAEkhC,sBAAsB,CAAC,CAAC,EAAE,EAAE,CAAC;EAChCjhC,CAAC,EAAEihC,sBAAsB,CAAC,CAAC,EAAE,EAAE;AACnC,CAAC;AACD,IAAIS,wBAAwB,GAAG,SAAAA,CAAU36B,MAAM,EAAErQ,aAAa,EAAEirC,WAAW,EAAE;EACzE,IAAIC,UAAU,GAAGlrC,aAAa,CAACuzB,kBAAkB,EAAE;EACnD,IAAIpf,OAAO,GAAGnU,aAAa,CAACwc,WAAW,EAAE;EACzC,IAAI2uB,oBAAoB,GAAGnN,gBAAgB,CAAC7pB,OAAO,CAAC;EACpD,IAAIi3B,OAAO,GAAGD,oBAAoB,CAACC,OAAO;IAAE9+B,GAAG,GAAG6+B,oBAAoB,CAAC7+B,GAAG;IAAEG,IAAI,GAAG0+B,oBAAoB,CAAC1+B,IAAI;IAAED,MAAM,GAAG2+B,oBAAoB,CAAC3+B,MAAM;IAAED,KAAK,GAAG4+B,oBAAoB,CAAC5+B,KAAK;IAAE1C,SAAS,GAAGshC,oBAAoB,CAACthC,SAAS;EAClO,IAAIwhC,mBAAmB,GAAG;IAAE/+B,GAAG,EAAEA,GAAG;IAAEG,IAAI,EAAEA,IAAI;IAAED,MAAM,EAAEA,MAAM;IAAED,KAAK,EAAEA,KAAK;IAAE1C,SAAS,EAAEA;EAAU,CAAC;EACtG;EACA;EACA,IAAIuhC,OAAO,KAAK,MAAM,EAAE;IACpBprC,aAAa,CAACkoC,cAAc,CAAC,SAAS,EAAE73B,MAAM,CAAC+6B,OAAO,IAAI,OAAO,CAAC;EACtE;EACA;EACAprC,aAAa,CAAC4D,UAAU,EAAE;EAC1B,IAAI0nC,UAAU,GAAGtrC,aAAa,CAACuzB,kBAAkB,EAAE;EACnD0X,WAAW,CAACttC,OAAO,CAAC,UAAU4B,GAAG,EAAE;IAC/B;IACA;IACA,IAAI3C,KAAK,GAAGoD,aAAa,CAACqnB,QAAQ,CAAC9nB,GAAG,CAAC;IACvCyqC,mBAAmB,CAACptC,KAAK,EAAEmuC,gBAAgB,CAACxrC,GAAG,CAAC,CAAC2rC,UAAU,EAAEG,mBAAmB,CAAC,CAAC;IAClFh7B,MAAM,CAAC9Q,GAAG,CAAC,GAAGwrC,gBAAgB,CAACxrC,GAAG,CAAC,CAAC+rC,UAAU,EAAEH,oBAAoB,CAAC;EACzE,CAAC,CAAC;EACF,OAAO96B,MAAM;AACjB,CAAC;AACD,IAAIk7B,gCAAgC,GAAG,SAAAA,CAAUvrC,aAAa,EAAEqQ,MAAM,EAAEuB,MAAM,EAAEuE,aAAa,EAAE;EAC3F,IAAIvE,MAAM,KAAK,KAAK,CAAC,EAAE;IAAEA,MAAM,GAAG,CAAC,CAAC;EAAE;EACtC,IAAIuE,aAAa,KAAK,KAAK,CAAC,EAAE;IAAEA,aAAa,GAAG,CAAC,CAAC;EAAE;EACpD9F,MAAM,GAAGxT,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAEwP,MAAM,CAAC;EACnC8F,aAAa,GAAGtZ,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAEsV,aAAa,CAAC;EACjD,IAAIq1B,oBAAoB,GAAG/uC,MAAM,CAACiB,IAAI,CAAC2S,MAAM,CAAC,CAACoQ,MAAM,CAACqpB,eAAe,CAAC;EACtE;EACA;EACA,IAAI2B,sBAAsB,GAAG,EAAE;EAC/B,IAAIC,mCAAmC,GAAG,KAAK;EAC/C,IAAIC,oBAAoB,GAAG,EAAE;EAC7BH,oBAAoB,CAAC7tC,OAAO,CAAC,UAAU4B,GAAG,EAAE;IACxC,IAAI3C,KAAK,GAAGoD,aAAa,CAACqnB,QAAQ,CAAC9nB,GAAG,CAAC;IACvC,IAAI,CAACS,aAAa,CAAConB,QAAQ,CAAC7nB,GAAG,CAAC,EAC5B;IACJ,IAAIgiB,IAAI,GAAG3P,MAAM,CAACrS,GAAG,CAAC;IACtB,IAAI8f,EAAE,GAAGhP,MAAM,CAAC9Q,GAAG,CAAC;IACpB,IAAIqsC,QAAQ,GAAG7kB,sBAAsB,CAACxF,IAAI,CAAC;IAC3C,IAAIsqB,MAAM;IACV;IACA;IACA;IACA;IACA,IAAI92B,iBAAiB,CAACsK,EAAE,CAAC,EAAE;MACvB,IAAIysB,YAAY,GAAGzsB,EAAE,CAACvf,MAAM;MAC5B,KAAK,IAAIU,CAAC,GAAG6e,EAAE,CAAC,CAAC,CAAC,KAAK,IAAI,GAAG,CAAC,GAAG,CAAC,EAAE7e,CAAC,GAAGsrC,YAAY,EAAEtrC,CAAC,EAAE,EAAE;QACxD,IAAI,CAACqrC,MAAM,EAAE;UACTA,MAAM,GAAG9kB,sBAAsB,CAAC1H,EAAE,CAAC7e,CAAC,CAAC,CAAC;UACtCxD,SAAS,CAACuD,SAAS,CAACsrC,MAAM,KAAKD,QAAQ,IAClC3B,aAAa,CAAC2B,QAAQ,CAAC,IAAI3B,aAAa,CAAC4B,MAAM,CAAE,EAAE,8DAA8D,CAAC;QAC3H,CAAC,MACI;UACD7uC,SAAS,CAACuD,SAAS,CAACwmB,sBAAsB,CAAC1H,EAAE,CAAC7e,CAAC,CAAC,CAAC,KAAKqrC,MAAM,EAAE,wCAAwC,CAAC;QAC3G;MACJ;IACJ,CAAC,MACI;MACDA,MAAM,GAAG9kB,sBAAsB,CAAC1H,EAAE,CAAC;IACvC;IACA,IAAIusB,QAAQ,KAAKC,MAAM,EAAE;MACrB;MACA;MACA,IAAI5B,aAAa,CAAC2B,QAAQ,CAAC,IAAI3B,aAAa,CAAC4B,MAAM,CAAC,EAAE;QAClD,IAAIpqC,OAAO,GAAG7E,KAAK,CAACmB,GAAG,EAAE;QACzB,IAAI,OAAO0D,OAAO,KAAK,QAAQ,EAAE;UAC7B7E,KAAK,CAAC+K,GAAG,CAACob,UAAU,CAACthB,OAAO,CAAC,CAAC;QAClC;QACA,IAAI,OAAO4d,EAAE,KAAK,QAAQ,EAAE;UACxBhP,MAAM,CAAC9Q,GAAG,CAAC,GAAGwjB,UAAU,CAAC1D,EAAE,CAAC;QAChC,CAAC,MACI,IAAIza,KAAK,CAACC,OAAO,CAACwa,EAAE,CAAC,IAAIwsB,MAAM,KAAK5uC,eAAe,CAACqO,EAAE,EAAE;UACzD+E,MAAM,CAAC9Q,GAAG,CAAC,GAAG8f,EAAE,CAACyC,GAAG,CAACiB,UAAU,CAAC;QACpC;MACJ,CAAC,MACI,IAAI,CAAC6oB,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,QAAQ,CAAC/hC,SAAS,MAC3EgiC,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAAChiC,SAAS,CAAC,KACjE0X,IAAI,KAAK,CAAC,IAAIlC,EAAE,KAAK,CAAC,CAAC,EAAE;QAC1B;QACA;QACA,IAAIkC,IAAI,KAAK,CAAC,EAAE;UACZ3kB,KAAK,CAAC+K,GAAG,CAACkkC,MAAM,CAAChiC,SAAS,CAAC0X,IAAI,CAAC,CAAC;QACrC,CAAC,MACI;UACDlR,MAAM,CAAC9Q,GAAG,CAAC,GAAGqsC,QAAQ,CAAC/hC,SAAS,CAACwV,EAAE,CAAC;QACxC;MACJ,CAAC,MACI;QACD;QACA;QACA,IAAI,CAACqsB,mCAAmC,EAAE;UACtCD,sBAAsB,GAAGZ,+BAA+B,CAAC7qC,aAAa,CAAC;UACvE0rC,mCAAmC,GAAG,IAAI;QAC9C;QACAC,oBAAoB,CAAChrC,IAAI,CAACpB,GAAG,CAAC;QAC9B4W,aAAa,CAAC5W,GAAG,CAAC,GACd4W,aAAa,CAAC5W,GAAG,CAAC,KAAKuD,SAAS,GAC1BqT,aAAa,CAAC5W,GAAG,CAAC,GAClB8Q,MAAM,CAAC9Q,GAAG,CAAC;QACrByqC,mBAAmB,CAACptC,KAAK,EAAEyiB,EAAE,CAAC;MAClC;IACJ;EACJ,CAAC,CAAC;EACF,IAAIssB,oBAAoB,CAAC7rC,MAAM,EAAE;IAC7B,IAAIisC,eAAe,GAAGf,wBAAwB,CAAC36B,MAAM,EAAErQ,aAAa,EAAE2rC,oBAAoB,CAAC;IAC3F;IACA,IAAIF,sBAAsB,CAAC3rC,MAAM,EAAE;MAC/B2rC,sBAAsB,CAAC9tC,OAAO,CAAC,UAAU+C,EAAE,EAAE;QACzC,IAAIgJ,EAAE,GAAG7M,KAAK,CAACwhB,MAAM,CAAC3d,EAAE,EAAE,CAAC,CAAC;UAAEnB,GAAG,GAAGmK,EAAE,CAAC,CAAC,CAAC;UAAE9M,KAAK,GAAG8M,EAAE,CAAC,CAAC,CAAC;QACxD1J,aAAa,CAACqnB,QAAQ,CAAC9nB,GAAG,CAAC,CAACoI,GAAG,CAAC/K,KAAK,CAAC;MAC1C,CAAC,CAAC;IACN;IACA;IACAoD,aAAa,CAAC4D,UAAU,EAAE;IAC1B,OAAO;MAAEyM,MAAM,EAAE07B,eAAe;MAAE51B,aAAa,EAAEA;IAAc,CAAC;EACpE,CAAC,MACI;IACD,OAAO;MAAE9F,MAAM,EAAEA,MAAM;MAAE8F,aAAa,EAAEA;IAAc,CAAC;EAC3D;AACJ,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS61B,cAAcA,CAAChsC,aAAa,EAAEqQ,MAAM,EAAEuB,MAAM,EAAEuE,aAAa,EAAE;EAClE,OAAO4zB,gBAAgB,CAAC15B,MAAM,CAAC,GACzBk7B,gCAAgC,CAACvrC,aAAa,EAAEqQ,MAAM,EAAEuB,MAAM,EAAEuE,aAAa,CAAC,GAC9E;IAAE9F,MAAM,EAAEA,MAAM;IAAE8F,aAAa,EAAEA;EAAc,CAAC;AAC1D;;AAEA;AACA;AACA;AACA;AACA,IAAI81B,eAAe,GAAG,SAAAA,CAAUjsC,aAAa,EAAEqQ,MAAM,EAAEuB,MAAM,EAAEuE,aAAa,EAAE;EAC1E,IAAID,QAAQ,GAAGgoB,mBAAmB,CAACl+B,aAAa,EAAEqQ,MAAM,EAAE8F,aAAa,CAAC;EACxE9F,MAAM,GAAG6F,QAAQ,CAAC7F,MAAM;EACxB8F,aAAa,GAAGD,QAAQ,CAACC,aAAa;EACtC,OAAO61B,cAAc,CAAChsC,aAAa,EAAEqQ,MAAM,EAAEuB,MAAM,EAAEuE,aAAa,CAAC;AACvE,CAAC;AAED,SAAS+1B,kBAAkBA,CAAC/3B,OAAO,EAAE;EACjC,OAAO3R,MAAM,CAACw7B,gBAAgB,CAAC7pB,OAAO,CAAC;AAC3C;AACA,IAAIg4B,UAAU,GAAG;EACb7G,QAAQ,EAAE,KAAK;EACfG,qBAAqB,EAAE,SAAAA,CAAU2G,UAAU,EAAE7sC,GAAG,EAAE;IAC9C,IAAIuJ,eAAe,CAACvJ,GAAG,CAAC,EAAE;MACtB,IAAI8sC,WAAW,GAAG1rB,mBAAmB,CAACphB,GAAG,CAAC;MAC1C,OAAO8sC,WAAW,GAAGA,WAAW,CAACz8B,OAAO,IAAI,CAAC,GAAG,CAAC;IACrD,CAAC,MACI;MACD,IAAI08B,aAAa,GAAGJ,kBAAkB,CAACE,UAAU,CAAC;MAClD,OAAQ,CAACxhC,eAAe,CAACrL,GAAG,CAAC,GACvB+sC,aAAa,CAACrO,gBAAgB,CAAC1+B,GAAG,CAAC,GACnC+sC,aAAa,CAAC/sC,GAAG,CAAC,KAAK,CAAC;IAClC;EACJ,CAAC;EACDyqB,gBAAgB,EAAE,SAAAA,CAAUthB,CAAC,EAAEC,CAAC,EAAE;IAC9B;AACR;AACA;AACA;AACA;IACQ,OAAOD,CAAC,CAAC6jC,uBAAuB,CAAC5jC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EACpD,CAAC;EACDkkB,aAAa,EAAE,SAAAA,CAAUruB,KAAK,EAAEe,GAAG,EAAE;IACjC,IAAImB,EAAE;IACN,OAAO,CAACA,EAAE,GAAGlC,KAAK,CAAC4Q,KAAK,MAAM,IAAI,IAAI1O,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACnB,GAAG,CAAC;EAC1E,CAAC;EACDg0B,kBAAkB,EAAE,SAAAA,CAAUpf,OAAO,EAAEzT,EAAE,EAAE;IACvC,IAAIK,kBAAkB,GAAGL,EAAE,CAACK,kBAAkB;IAC9C,OAAO2xB,cAAc,CAACve,OAAO,EAAEpT,kBAAkB,CAAC;EACtD,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACI43B,cAAc,EAAE,SAAAA,CAAUxkB,OAAO,EAAEi4B,UAAU,EAAE5tC,KAAK,EAAE;IAClD,IAAIoL,iBAAiB,GAAGpL,KAAK,CAACoL,iBAAiB;IAC/CwiC,UAAU,CAACh9B,KAAK,CAACvF,SAAS,GAAGD,iBAAiB,GACxCA,iBAAiB,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,GACzB,MAAM;IACZ;IACAuK,OAAO,CAAC8yB,cAAc,EAAE;EAC5B,CAAC;EACDrO,gBAAgB,EAAE,SAAAA,CAAUr0B,QAAQ,EAAEioC,YAAY,EAAE;IAChDjoC,QAAQ,CAAC6K,KAAK,CAACvF,SAAS,GAAG2iC,YAAY,CAACp9B,KAAK,CAACvF,SAAS;EAC3D,CAAC;EACD67B,0BAA0B,EAAE,SAAAA,CAAUnmC,GAAG,EAAEmB,EAAE,EAAE;IAC3C,IAAI2O,IAAI,GAAG3O,EAAE,CAAC2O,IAAI;MAAED,KAAK,GAAG1O,EAAE,CAAC0O,KAAK;IACpC,OAAOC,IAAI,CAAC9P,GAAG,CAAC;IAChB,OAAO6P,KAAK,CAAC7P,GAAG,CAAC;EACrB,CAAC;EACD;AACJ;AACA;AACA;EACIioB,oBAAoB,EAAE,SAAAA,CAAUrT,OAAO,EAAEzT,EAAE,EAAEgJ,EAAE,EAAEi+B,SAAS,EAAE;IACxD,IAAIh3B,eAAe,GAAGjH,EAAE,CAACiH,eAAe;IACxC,IAAIg3B,SAAS,KAAK,KAAK,CAAC,EAAE;MAAEA,SAAS,GAAG,IAAI;IAAE;IAC9C,IAAIvxB,UAAU,GAAG1V,EAAE,CAAC0V,UAAU;MAAED,aAAa,GAAGzV,EAAE,CAACyV,aAAa;MAAE9F,MAAM,GAAGxT,KAAK,CAACsW,MAAM,CAACzS,EAAE,EAAE,CAAC,YAAY,EAAE,eAAe,CAAC,CAAC;IAC5H,IAAIkR,MAAM,GAAG4W,SAAS,CAACnY,MAAM,EAAE+F,UAAU,IAAI,CAAC,CAAC,EAAEjC,OAAO,CAAC;IACzD;AACR;AACA;IACQ,IAAIxD,eAAe,EAAE;MACjB,IAAIwF,aAAa,EACbA,aAAa,GAAGxF,eAAe,CAACwF,aAAa,CAAC;MAClD,IAAI9F,MAAM,EACNA,MAAM,GAAGM,eAAe,CAACN,MAAM,CAAC;MACpC,IAAIuB,MAAM,EACNA,MAAM,GAAGjB,eAAe,CAACiB,MAAM,CAAC;IACxC;IACA,IAAI+1B,SAAS,EAAE;MACX1f,uBAAuB,CAAC9T,OAAO,EAAE9D,MAAM,EAAEuB,MAAM,CAAC;MAChD,IAAI66B,MAAM,GAAGR,eAAe,CAAC93B,OAAO,EAAE9D,MAAM,EAAEuB,MAAM,EAAEuE,aAAa,CAAC;MACpEA,aAAa,GAAGs2B,MAAM,CAACt2B,aAAa;MACpC9F,MAAM,GAAGo8B,MAAM,CAACp8B,MAAM;IAC1B;IACA,OAAOxT,KAAK,CAACgE,QAAQ,CAAC;MAAEuV,UAAU,EAAEA,UAAU;MAC1CD,aAAa,EAAEA;IAAc,CAAC,EAAE9F,MAAM,CAAC;EAC/C,CAAC;EACDsE,2BAA2B,EAAEF,6BAA6B;EAC1D8wB,KAAK,EAAE,SAAAA,CAAUpxB,OAAO,EAAEI,WAAW,EAAEzF,YAAY,EAAEC,UAAU,EAAEC,WAAW,EAAEC,OAAO,EAAEzQ,KAAK,EAAE;IAC1F,IAAI2V,OAAO,CAACuzB,SAAS,KAAK5kC,SAAS,EAAE;MACjCyR,WAAW,CAACnF,KAAK,CAAC+4B,UAAU,GAAGh0B,OAAO,CAACuzB,SAAS,GAC1C,SAAS,GACT,QAAQ;IAClB;IACA,IAAIgF,oBAAoB,GAAG39B,UAAU,CAACxQ,SAAS,IAAIyQ,WAAW,CAACa,UAAU;IACzEjB,eAAe,CAAC2F,WAAW,EAAEzF,YAAY,EAAEC,UAAU,EAAEC,WAAW,EAAEC,OAAO,EAAEzQ,KAAK,CAACoL,iBAAiB,EAAE8iC,oBAAoB,GAAGhJ,8BAA8B,GAAG5gC,SAAS,EAAE4pC,oBAAoB,GACvL3I,oCAAoC,GACpCjhC,SAAS,CAAC;EACpB,CAAC;EACDkiB,MAAM,EAAE9Q;AACZ,CAAC;AACD,IAAIy4B,iBAAiB,GAAG3sC,aAAa,CAACmsC,UAAU,CAAC;AAEjD,IAAIS,gBAAgB,GAAG5sC,aAAa,CAACnD,KAAK,CAACgE,QAAQ,CAAChE,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAEsrC,UAAU,CAAC,EAAE;EAAEtf,aAAa,EAAE,SAAAA,CAAUruB,KAAK,EAAEe,GAAG,EAAE;IACnH,OAAOf,KAAK,CAACe,GAAG,CAAC;EACrB,CAAC;EACDkmC,qBAAqB,EAAE,SAAAA,CAAU2G,UAAU,EAAE7sC,GAAG,EAAE;IAC9C,IAAImB,EAAE;IACN,IAAIoI,eAAe,CAACvJ,GAAG,CAAC,EAAE;MACtB,OAAO,CAAC,CAACmB,EAAE,GAAGigB,mBAAmB,CAACphB,GAAG,CAAC,MAAM,IAAI,IAAImB,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACkP,OAAO,KAAK,CAAC;IACjG;IACArQ,GAAG,GAAG,CAAC8U,mBAAmB,CAAC3M,GAAG,CAACnI,GAAG,CAAC,GAAGuU,WAAW,CAACvU,GAAG,CAAC,GAAGA,GAAG;IAC5D,OAAO6sC,UAAU,CAACS,YAAY,CAACttC,GAAG,CAAC;EACvC,CAAC;EACDoV,2BAA2B,EAAEA,2BAA2B;EACxD4wB,KAAK,EAAE,SAAAA,CAAUuH,QAAQ,EAAEv4B,WAAW,EAAEzF,YAAY,EAAEC,UAAU,EAAEC,WAAW,EAAEC,OAAO,EAAEzQ,KAAK,EAAE;IAC3F,IAAIkuC,oBAAoB,GAAG39B,UAAU,CAACxQ,SAAS,IAAIyQ,WAAW,CAACa,UAAU;IACzEiD,aAAa,CAACyB,WAAW,EAAEzF,YAAY,EAAEC,UAAU,EAAEC,WAAW,EAAEC,OAAO,EAAEzQ,KAAK,CAACoL,iBAAiB,EAAE8iC,oBAAoB,GAAGhJ,8BAA8B,GAAG5gC,SAAS,EAAE4pC,oBAAoB,GACrL3I,oCAAoC,GACpCjhC,SAAS,CAAC;EACpB,CAAC;EAAEkiB,MAAM,EAAE1Q;AAAU,CAAC,CAAC,CAAC;AAE5B,IAAIy4B,sBAAsB,GAAG,SAAAA,CAAUvtC,SAAS,EAAEyP,OAAO,EAAE;EACvD,OAAOpH,cAAc,CAACrI,SAAS,CAAC,GAC1BotC,gBAAgB,CAAC39B,OAAO,EAAE;IAAEjF,0BAA0B,EAAE;EAAM,CAAC,CAAC,GAChE2iC,iBAAiB,CAAC19B,OAAO,EAAE;IAAEjF,0BAA0B,EAAE;EAAK,CAAC,CAAC;AAC1E,CAAC;AAED,IAAIgjC,aAAa,GAAGnwC,KAAK,CAACgE,QAAQ,CAAChE,KAAK,CAACgE,QAAQ,CAAChE,KAAK,CAACgE,QAAQ,CAAChE,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAE8nB,UAAU,CAAC,EAAE7L,iBAAiB,CAAC,EAAE/d,IAAI,CAAC,EAAEskC,gBAAgB,CAAC;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA,IAAI4J,MAAM,GAAG,aAAc9lC,iBAAiB,CAAC,UAAU3H,SAAS,EAAE0D,MAAM,EAAE;EACtE,OAAO0T,qBAAqB,CAACpX,SAAS,EAAE0D,MAAM,EAAE8pC,aAAa,EAAED,sBAAsB,CAAC;AAC1F,CAAC,CAAC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,wBAAwBA,CAAC3tC,GAAG,EAAE;EACnC,OAAOqH,qBAAqB,CAACgQ,qBAAqB,CAACrX,GAAG,EAAE;IAAEkS,kBAAkB,EAAE;EAAM,CAAC,EAAEu7B,aAAa,EAAED,sBAAsB,CAAC,CAAC;AAClI;;AAEA;AACA;AACA;AACA,IAAII,CAAC,GAAGhmC,iBAAiB,CAACyP,qBAAqB,CAAC;AAEhD,SAASw2B,cAAcA,CAAA,EAAG;EACtB,IAAIC,YAAY,GAAGtwC,KAAK,CAACyE,MAAM,CAAC,KAAK,CAAC;EACtC,IAAId,EAAE,GAAG7D,KAAK,CAACwhB,MAAM,CAACthB,KAAK,CAACuwC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;IAAEC,iBAAiB,GAAG7sC,EAAE,CAAC,CAAC,CAAC;IAAE8sC,oBAAoB,GAAG9sC,EAAE,CAAC,CAAC,CAAC;EACpGkb,gBAAgB,CAAC,YAAY;IAAE,OAAQyxB,YAAY,CAAC5rC,OAAO,GAAG,IAAI;EAAG,CAAC,CAAC;EACvE,OAAO1E,KAAK,CAACuH,WAAW,CAAC,YAAY;IACjC,CAAC+oC,YAAY,CAAC5rC,OAAO,IAAI+rC,oBAAoB,CAACD,iBAAiB,GAAG,CAAC,CAAC;EACxE,CAAC,EAAE,CAACA,iBAAiB,CAAC,CAAC;AAC3B;AAEA,IAAIhqC,UAAU,GAAG,CAAC;AAClB,SAASkqC,aAAaA,CAAA,EAAG;EACrB,IAAI1rC,EAAE,GAAGwB,UAAU;EACnBA,UAAU,EAAE;EACZ,OAAOxB,EAAE;AACb;AACA,IAAI2rC,aAAa,GAAG,SAAAA,CAAUhtC,EAAE,EAAE;EAC9B,IAAIwyB,QAAQ,GAAGxyB,EAAE,CAACwyB,QAAQ;IAAEzvB,OAAO,GAAG/C,EAAE,CAAC+C,OAAO;IAAE7B,SAAS,GAAGlB,EAAE,CAACkB,SAAS;IAAEC,cAAc,GAAGnB,EAAE,CAACmB,cAAc;IAAEyD,MAAM,GAAG5E,EAAE,CAAC4E,MAAM;IAAEqoC,qBAAqB,GAAGjtC,EAAE,CAACitC,qBAAqB;EACpL,IAAIC,gBAAgB,GAAGvsC,WAAW,CAACwsC,cAAc,CAAC;EAClD,IAAI9rC,EAAE,GAAGV,WAAW,CAACosC,aAAa,CAAC;EACnC,IAAI9rC,OAAO,GAAG5E,KAAK,CAACyJ,OAAO,CAAC,YAAY;IAAE,OAAQ;MAC9CzE,EAAE,EAAEA,EAAE;MACN0B,OAAO,EAAEA,OAAO;MAChB7B,SAAS,EAAEA,SAAS;MACpB0D,MAAM,EAAEA,MAAM;MACdzD,cAAc,EAAE,SAAAA,CAAUisC,OAAO,EAAE;QAC/BF,gBAAgB,CAACjmC,GAAG,CAACmmC,OAAO,EAAE,IAAI,CAAC;QACnC,IAAIC,WAAW,GAAG,IAAI;QACtBH,gBAAgB,CAACjwC,OAAO,CAAC,UAAUqwC,UAAU,EAAE;UAC3C,IAAI,CAACA,UAAU,EACXD,WAAW,GAAG,KAAK;QAC3B,CAAC,CAAC;QACFA,WAAW,KAAKlsC,cAAc,KAAK,IAAI,IAAIA,cAAc,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,cAAc,EAAE,CAAC;MACrG,CAAC;MACDC,QAAQ,EAAE,SAAAA,CAAUgsC,OAAO,EAAE;QACzBF,gBAAgB,CAACjmC,GAAG,CAACmmC,OAAO,EAAE,KAAK,CAAC;QACpC,OAAO,YAAY;UAAE,OAAOF,gBAAgB,CAACnhB,MAAM,CAACqhB,OAAO,CAAC;QAAE,CAAC;MACnE;IACJ,CAAC;EAAG,CAAC;EACL;AACJ;AACA;AACA;AACA;EACIH,qBAAqB,GAAG7qC,SAAS,GAAG,CAAClB,SAAS,CAAC,CAAC;EAChD7E,KAAK,CAACyJ,OAAO,CAAC,YAAY;IACtBonC,gBAAgB,CAACjwC,OAAO,CAAC,UAAUswC,CAAC,EAAE1uC,GAAG,EAAE;MAAE,OAAOquC,gBAAgB,CAACjmC,GAAG,CAACpI,GAAG,EAAE,KAAK,CAAC;IAAE,CAAC,CAAC;EAC5F,CAAC,EAAE,CAACqC,SAAS,CAAC,CAAC;EACf;AACJ;AACA;AACA;EACI1D,gBAAgB,CAAC+D,SAAS,CAAC,YAAY;IACnC,CAACL,SAAS,IAAI,CAACgsC,gBAAgB,CAACvhC,IAAI,KAAKxK,cAAc,KAAK,IAAI,IAAIA,cAAc,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,cAAc,EAAE,CAAC;EAC9H,CAAC,EAAE,CAACD,SAAS,CAAC,CAAC;EACf,OAAQ1D,gBAAgB,CAAC0C,aAAa,CAACQ,eAAe,CAAC6F,QAAQ,EAAE;IAAErK,KAAK,EAAE+E;EAAQ,CAAC,EAAEuxB,QAAQ,CAAC;AAClG,CAAC;AACD,SAAS2a,cAAcA,CAAA,EAAG;EACtB,OAAO,IAAItmC,GAAG,EAAE;AACpB;AAEA,SAAS2mC,WAAWA,CAACxyB,KAAK,EAAE;EACxB,OAAOA,KAAK,CAACnc,GAAG,IAAI,EAAE;AAC1B;AACA,SAAS4uC,iBAAiBA,CAACjb,QAAQ,EAAEkb,WAAW,EAAE;EAC9C,IAAIC,YAAY,GAAGjuC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GAAG,IAAIuI,GAAG,EAAE,GAAG,IAAI;EAC3EqqB,QAAQ,CAACv1B,OAAO,CAAC,UAAU+d,KAAK,EAAE;IAC9B,IAAInc,GAAG,GAAG2uC,WAAW,CAACxyB,KAAK,CAAC;IAC5B,IAAItb,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,IAAI+tC,YAAY,EAAE;MACvD,IAAIA,YAAY,CAAC3mC,GAAG,CAACnI,GAAG,CAAC,EAAE;QACvB+uC,OAAO,CAACC,IAAI,CAAC,qDAAqD,GAAGhvC,GAAG,GAAG,oBAAoB,CAAC;MACpG;MACA8uC,YAAY,CAACtqB,GAAG,CAACxkB,GAAG,CAAC;IACzB;IACA6uC,WAAW,CAACzmC,GAAG,CAACpI,GAAG,EAAEmc,KAAK,CAAC;EAC/B,CAAC,CAAC;AACN;AACA,SAAS8yB,YAAYA,CAACtb,QAAQ,EAAE;EAC5B,IAAIub,QAAQ,GAAG,EAAE;EACjB;EACA1xC,KAAK,CAAC2xC,QAAQ,CAAC/wC,OAAO,CAACu1B,QAAQ,EAAE,UAAUxX,KAAK,EAAE;IAC9C,IAAI3e,KAAK,CAAC4xC,cAAc,CAACjzB,KAAK,CAAC,EAC3B+yB,QAAQ,CAAC9tC,IAAI,CAAC+a,KAAK,CAAC;EAC5B,CAAC,CAAC;EACF,OAAO+yB,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIG,eAAe,GAAG,SAAAA,CAAUluC,EAAE,EAAE;EAChC,IAAIwyB,QAAQ,GAAGxyB,EAAE,CAACwyB,QAAQ;IAAE5tB,MAAM,GAAG5E,EAAE,CAAC4E,MAAM;IAAEoE,EAAE,GAAGhJ,EAAE,CAAC+C,OAAO;IAAEA,OAAO,GAAGiG,EAAE,KAAK,KAAK,CAAC,GAAG,IAAI,GAAGA,EAAE;IAAE7H,cAAc,GAAGnB,EAAE,CAACmB,cAAc;IAAEgtC,eAAe,GAAGnuC,EAAE,CAACmuC,eAAe;IAAE9kC,EAAE,GAAGrJ,EAAE,CAACitC,qBAAqB;IAAEA,qBAAqB,GAAG5jC,EAAE,KAAK,KAAK,CAAC,GAAG,IAAI,GAAGA,EAAE;EAChQ;EACA;EACA,IAAI+kC,WAAW,GAAG1B,cAAc,EAAE;EAClC,IAAI2B,aAAa,GAAGhyC,KAAK,CAACoD,UAAU,CAACqiC,mBAAmB,CAAC;EACzD,IAAIE,cAAc,CAACqM,aAAa,CAAC,EAAE;IAC/BD,WAAW,GAAGC,aAAa,CAACpM,WAAW;EAC3C;EACA,IAAI7X,eAAe,GAAG/tB,KAAK,CAACyE,MAAM,CAAC,IAAI,CAAC;EACxC;EACA,IAAIwtC,gBAAgB,GAAGR,YAAY,CAACtb,QAAQ,CAAC;EAC7C;EACA;EACA,IAAI+b,eAAe,GAAGlyC,KAAK,CAACyE,MAAM,CAACwtC,gBAAgB,CAAC;EACpD;EACA,IAAIZ,WAAW,GAAGrxC,KAAK,CAACyE,MAAM,CAAC,IAAI+F,GAAG,EAAE,CAAC,CACpC9F,OAAO;EACZ;EACA,IAAIytC,OAAO,GAAGnyC,KAAK,CAACyE,MAAM,CAAC,IAAIqH,GAAG,EAAE,CAAC,CAACpH,OAAO;EAC7C0sC,iBAAiB,CAACa,gBAAgB,EAAEZ,WAAW,CAAC;EAChD;EACA;EACA,IAAItjB,eAAe,CAACrpB,OAAO,EAAE;IACzBqpB,eAAe,CAACrpB,OAAO,GAAG,KAAK;IAC/B,OAAQvD,gBAAgB,CAAC0C,aAAa,CAAC1C,gBAAgB,CAAC8I,QAAQ,EAAE,IAAI,EAAEgoC,gBAAgB,CAACltB,GAAG,CAAC,UAAUpG,KAAK,EAAE;MAAE,OAAQxd,gBAAgB,CAAC0C,aAAa,CAAC8sC,aAAa,EAAE;QAAEnuC,GAAG,EAAE2uC,WAAW,CAACxyB,KAAK,CAAC;QAAE9Z,SAAS,EAAE,IAAI;QAAE6B,OAAO,EAAEA,OAAO,GAAGX,SAAS,GAAG,KAAK;QAAE6qC,qBAAqB,EAAEA;MAAsB,CAAC,EAAEjyB,KAAK,CAAC;IAAG,CAAC,CAAC,CAAC;EACxT;EACA;EACA,IAAIyzB,gBAAgB,GAAGtyC,KAAK,CAACulB,aAAa,CAAC,EAAE,EAAEvlB,KAAK,CAACwhB,MAAM,CAAC2wB,gBAAgB,CAAC,CAAC;EAC9E;EACA;EACA,IAAII,WAAW,GAAGH,eAAe,CAACxtC,OAAO,CAACqgB,GAAG,CAACosB,WAAW,CAAC;EAC1D,IAAImB,UAAU,GAAGL,gBAAgB,CAACltB,GAAG,CAACosB,WAAW,CAAC;EAClD;EACA,IAAIoB,UAAU,GAAGF,WAAW,CAACtvC,MAAM;EACnC,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8uC,UAAU,EAAE9uC,CAAC,EAAE,EAAE;IACjC,IAAIjB,GAAG,GAAG6vC,WAAW,CAAC5uC,CAAC,CAAC;IACxB,IAAI6uC,UAAU,CAACtnC,OAAO,CAACxI,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;MAChC2vC,OAAO,CAACnrB,GAAG,CAACxkB,GAAG,CAAC;IACpB,CAAC,MACI;MACD;MACA2vC,OAAO,CAACziB,MAAM,CAACltB,GAAG,CAAC;IACvB;EACJ;EACA;EACA;EACA,IAAIsvC,eAAe,IAAIK,OAAO,CAAC7iC,IAAI,EAAE;IACjC8iC,gBAAgB,GAAG,EAAE;EACzB;EACA;EACA;EACAD,OAAO,CAACvxC,OAAO,CAAC,UAAU4B,GAAG,EAAE;IAC3B;IACA,IAAI8vC,UAAU,CAACtnC,OAAO,CAACxI,GAAG,CAAC,KAAK,CAAC,CAAC,EAC9B;IACJ,IAAImc,KAAK,GAAG0yB,WAAW,CAACrwC,GAAG,CAACwB,GAAG,CAAC;IAChC,IAAI,CAACmc,KAAK,EACN;IACJ,IAAI6zB,cAAc,GAAGH,WAAW,CAACrnC,OAAO,CAACxI,GAAG,CAAC;IAC7C,IAAIiwC,MAAM,GAAG,SAAAA,CAAA,EAAY;MACrBpB,WAAW,CAAC3hB,MAAM,CAACltB,GAAG,CAAC;MACvB2vC,OAAO,CAACziB,MAAM,CAACltB,GAAG,CAAC;MACnB;MACA,IAAIkwC,WAAW,GAAGR,eAAe,CAACxtC,OAAO,CAACiuC,SAAS,CAAC,UAAUC,YAAY,EAAE;QAAE,OAAOA,YAAY,CAACpwC,GAAG,KAAKA,GAAG;MAAE,CAAC,CAAC;MACjH0vC,eAAe,CAACxtC,OAAO,CAACmiB,MAAM,CAAC6rB,WAAW,EAAE,CAAC,CAAC;MAC9C;MACA,IAAI,CAACP,OAAO,CAAC7iC,IAAI,EAAE;QACf4iC,eAAe,CAACxtC,OAAO,GAAGutC,gBAAgB;QAC1CF,WAAW,EAAE;QACbjtC,cAAc,IAAIA,cAAc,EAAE;MACtC;IACJ,CAAC;IACDstC,gBAAgB,CAACvrB,MAAM,CAAC2rB,cAAc,EAAE,CAAC,EAAErxC,gBAAgB,CAAC0C,aAAa,CAAC8sC,aAAa,EAAE;MAAEnuC,GAAG,EAAE2uC,WAAW,CAACxyB,KAAK,CAAC;MAAE9Z,SAAS,EAAE,KAAK;MAAEC,cAAc,EAAE2tC,MAAM;MAAElqC,MAAM,EAAEA,MAAM;MAAEqoC,qBAAqB,EAAEA;IAAsB,CAAC,EAAEjyB,KAAK,CAAC,CAAC;EACzO,CAAC,CAAC;EACF;EACA;EACAyzB,gBAAgB,GAAGA,gBAAgB,CAACrtB,GAAG,CAAC,UAAUpG,KAAK,EAAE;IACrD,IAAInc,GAAG,GAAGmc,KAAK,CAACnc,GAAG;IACnB,OAAO2vC,OAAO,CAACxnC,GAAG,CAACnI,GAAG,CAAC,GAAImc,KAAK,GAAKxd,gBAAgB,CAAC0C,aAAa,CAAC8sC,aAAa,EAAE;MAAEnuC,GAAG,EAAE2uC,WAAW,CAACxyB,KAAK,CAAC;MAAE9Z,SAAS,EAAE,IAAI;MAAE+rC,qBAAqB,EAAEA;IAAsB,CAAC,EAAEjyB,KAAK,CAAE;EAC1L,CAAC,CAAC;EACFuzB,eAAe,CAACxtC,OAAO,GAAG0tC,gBAAgB;EAC1C,IAAI/uC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,IACrCuuC,eAAe,IACfM,gBAAgB,CAACrvC,MAAM,GAAG,CAAC,EAAE;IAC7BwuC,OAAO,CAACC,IAAI,CAAC,6JAA6J,CAAC;EAC/K;EACA,OAAQrwC,gBAAgB,CAAC0C,aAAa,CAAC1C,gBAAgB,CAAC8I,QAAQ,EAAE,IAAI,EAAEkoC,OAAO,CAAC7iC,IAAI,GAC9E8iC,gBAAgB,GAChBA,gBAAgB,CAACrtB,GAAG,CAAC,UAAUpG,KAAK,EAAE;IAAE,OAAO3e,KAAK,CAAC6yC,YAAY,CAACl0B,KAAK,CAAC;EAAE,CAAC,CAAC,CAAC;AACvF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS7V,OAAOA,CAAC0b,IAAI,EAAElC,EAAE,EAAEjJ,UAAU,EAAE;EACnC,IAAIA,UAAU,KAAK,KAAK,CAAC,EAAE;IAAEA,UAAU,GAAG,CAAC,CAAC;EAAE;EAC9C,IAAIxZ,KAAK,GAAGuM,aAAa,CAACoY,IAAI,CAAC,GAAGA,IAAI,GAAGgF,WAAW,CAAChF,IAAI,CAAC;EAC1D0B,cAAc,CAAC,EAAE,EAAErmB,KAAK,EAAEyiB,EAAE,EAAEjJ,UAAU,CAAC;EACzC,OAAO;IACH0M,IAAI,EAAE,SAAAA,CAAA,EAAY;MAAE,OAAOlmB,KAAK,CAACkmB,IAAI,EAAE;IAAE;EAC7C,CAAC;AACL;AAEA,SAAS+sB,gBAAgBA,CAAA,EAAG;EACxB;AACJ;AACA;EACI,IAAI19B,QAAQ,GAAGoU,WAAW,CAAC,CAAC,CAAC;EAC7B,IAAItX,OAAO,GAAG;IACV6gC,IAAI,EAAEhtC,SAAS;IACfitC,MAAM,EAAEjtC,SAAS;IACjBktC,gBAAgB,EAAE,KAAK;IACvBC,qBAAqB,EAAE;EAC3B,CAAC;EACD,IAAIC,WAAW,GAAGrzC,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAEoO,OAAO,CAAC;EAC7C,IAAIkhC,SAAS,GAAG,CAAC,CAAC;EAClB,IAAIC,WAAW,GAAG,CAAC,CAAC;EACpB;AACJ;AACA;EACI,IAAIl1B,QAAQ,GAAG,KAAK;EACpB;AACJ;AACA;EACI,IAAIm1B,mBAAmB,GAAG,IAAI;EAC9B;AACJ;AACA;EACI,IAAIC,UAAU,GAAG,CAAC;EAClB,SAASC,uBAAuBA,CAAClgC,MAAM,EAAE+F,UAAU,EAAE;IACjD,IAAI05B,IAAI,GAAG7gC,OAAO,CAAC6gC,IAAI;MAAEC,MAAM,GAAG9gC,OAAO,CAAC8gC,MAAM;IAChD70B,QAAQ,GAAG,IAAI;IACfm1B,mBAAmB,GAAG,IAAI;IAC1B,IAAIG,UAAU,GAAG,KAAK;IACtB,IAAI5tB,QAAQ,GAAG,SAAAA,CAAA,EAAY;MACvB4tB,UAAU,GAAG,IAAI;MACjBV,IAAI,IAAIA,IAAI,CAAC7I,cAAc,EAAE;MAC7B8I,MAAM,IAAIA,MAAM,CAAC9I,cAAc,EAAE;IACrC,CAAC;IACD,IAAI1kB,UAAU,GAAG,SAAAA,CAAA,EAAY;MACzBrH,QAAQ,GAAG,KAAK;MAChB;AACZ;AACA;AACA;MACYm1B,mBAAmB,GAAGlzC,IAAI,CAAC8nB,YAAY,EAAE,CAACE,SAAS;IACvD,CAAC;IACD/O,UAAU,GAAGA,UAAU,IAAI8L,kBAAkB,CAAC9L,UAAU,EAAE,WAAW,CAAC;IACtE,OAAOvQ,OAAO,CAACsM,QAAQ,EAAE9B,MAAM,EAAExT,KAAK,CAACgE,QAAQ,CAAChE,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAEuV,UAAU,CAAC,EAAE;MAAEwM,QAAQ,EAAEA,QAAQ;MAAEL,UAAU,EAAE,SAAAA,CAAA,EAAY;QACtH,IAAI,CAACiuB,UAAU,EAAE;UACbr+B,QAAQ,CAACxK,GAAG,CAAC0I,MAAM,CAAC;UACpB;AACpB;AACA;AACA;UACoBjS,aAAa,CAAC,SAAS,CAAC,CAACk6B,IAAI,CAAC/V,UAAU,CAAC;QAC7C,CAAC,MACI;UACDA,UAAU,EAAE;QAChB;QACAK,QAAQ,EAAE;MACd;IAAE,CAAC,CAAC,CAAC;EACb;EACA,SAAS6tB,eAAeA,CAAA,EAAG;IACvB,IAAI/vC,EAAE,EAAEgJ,EAAE;IACV;AACR;AACA;AACA;AACA;IACQ,IAAIyb,SAAS,GAAGhoB,IAAI,CAAC8nB,YAAY,EAAE,CAACE,SAAS;IAC7C,IAAI2qB,IAAI,GAAG7gC,OAAO,CAAC6gC,IAAI;MAAEC,MAAM,GAAG9gC,OAAO,CAAC8gC,MAAM;IAChD,IAAI5qB,SAAS,KAAKmrB,UAAU,IAAI,CAACR,IAAI,EACjC;IACJQ,UAAU,GAAGnrB,SAAS;IACtB;AACR;AACA;AACA;IACQ,IAAIurB,gBAAgB,GAAGZ,IAAI,CAAC3Z,eAAe,EAAE;IAC7C15B,MAAM,CAACiU,MAAM,CAACy/B,SAAS,EAAEO,gBAAgB,CAAC;IAC1C,IAAIC,kBAAkB,GAAGZ,MAAM,GACzBA,MAAM,CAAC5Z,eAAe,EAAE,GACxBlnB,OAAO,CAAC2hC,UAAU;IACxBn0C,MAAM,CAACiU,MAAM,CAAC0/B,WAAW,EAAEO,kBAAkB,CAAC;IAC9C,IAAI3vC,CAAC,GAAGmR,QAAQ,CAACpU,GAAG,EAAE;IACtB;AACR;AACA;AACA;IACQ,IAAI8yC,iBAAiB,GAAG,CAACnwC,EAAE,GAAGgwC,gBAAgB,CAACriC,OAAO,MAAM,IAAI,IAAI3N,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,CAAC;IAC1F,IAAIowC,mBAAmB,GAAG,CAACpnC,EAAE,GAAGinC,kBAAkB,KAAK,IAAI,IAAIA,kBAAkB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,kBAAkB,CAACtiC,OAAO,MAAM,IAAI,IAAI3E,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,CAAC;IACtK,IAAIuF,OAAO,CAAC+gC,gBAAgB,IAAID,MAAM,EAAE;MACpCI,SAAS,CAAC9hC,OAAO,GAAGnR,SAAS,CAAC+X,GAAG;MACjC;AACZ;AACA;AACA;MACY86B,MAAM,CAACrI,SAAS,KAAK,KAAK,GAAG,CAAC,GAAGoJ,mBAAmB,EAAED,iBAAiB,EAAEE,eAAe,CAAC/vC,CAAC,CAAC,CAAC;MAC5FovC,WAAW,CAAC/hC,OAAO,GAAGY,OAAO,CAACghC,qBAAqB,GAC7Ca,mBAAmB,GACnB5zC,SAAS,CAAC+X,GAAG,CAAC67B,mBAAmB,EAAE,CAAC,EAAEE,gBAAgB,CAAChwC,CAAC,CAAC,CAAC;IACpE,CAAC,MACI,IAAI,CAAC+uC,MAAM,EAAE;MACdI,SAAS,CAAC9hC,OAAO,GAAGnR,SAAS,CAAC+X,GAAG,CAAC67B,mBAAmB,EAAED,iBAAiB,EAAE7vC,CAAC,CAAC;IAChF;IACAiwC,SAAS,CAACd,SAAS,EAAEC,WAAW,EAAEM,gBAAgB,EAAEC,kBAAkB,IAAI,CAAC,CAAC,EAAEvqC,OAAO,CAAC2pC,MAAM,CAAC,EAAE/uC,CAAC,CAAC;EACrG;EACA,OAAO;IACHka,QAAQ,EAAE,SAAAA,CAAA,EAAY;MAClB,OAAOi1B,SAAS,KACXj1B,QAAQ,IAAI/d,IAAI,CAAC8nB,YAAY,EAAE,CAACE,SAAS,KAAKkrB,mBAAmB,CAAC;IAC3E,CAAC;IACDa,QAAQ,EAAE,SAAAA,CAAU96B,UAAU,EAAE;MAC5B,OAAOm6B,uBAAuB,CAAC,CAAC,EAAEn6B,UAAU,CAAC;IACjD,CAAC;IACD+6B,MAAM,EAAE,SAAAA,CAAU/6B,UAAU,EAAE;MAC1B,IAAIg7B,eAAe,GAAG,CAAC;MACvB,IAAI,CAACniC,OAAO,CAAC2hC,UAAU,IAAI,CAAC3hC,OAAO,CAAC8gC,MAAM,EAAE;QACxC;AAChB;AACA;QACgBqB,eAAe,GAAG,CAAC;MACvB,CAAC,MACI,IAAIlB,WAAW,CAACJ,IAAI,KAAK7gC,OAAO,CAAC8gC,MAAM,IACxCG,WAAW,CAACH,MAAM,KAAK9gC,OAAO,CAAC6gC,IAAI,EAAE;QACrC;AAChB;AACA;QACgBsB,eAAe,GAAG,CAAC,GAAGj/B,QAAQ,CAACpU,GAAG,EAAE;MACxC;MACAoU,QAAQ,CAACxK,GAAG,CAACypC,eAAe,CAAC;MAC7B,OAAOb,uBAAuB,CAAC,CAAC,EAAEn6B,UAAU,CAAC;IACjD,CAAC;IACDi7B,KAAK,EAAE,SAAAA,CAAA,EAAY;MAAE,OAAOl/B,QAAQ,CAACxK,GAAG,CAAC,CAAC,CAAC;IAAE,CAAC;IAC9Cmb,IAAI,EAAE,SAAAA,CAAA,EAAY;MAAE,OAAO3Q,QAAQ,CAAC2Q,IAAI,EAAE;IAAE,CAAC;IAC7C2jB,iBAAiB,EAAE,SAAAA,CAAUtyB,OAAO,EAAE;MAClCs8B,eAAe,EAAE;MACjB,IAAIt8B,OAAO,KAAKlF,OAAO,CAAC6gC,IAAI,EAAE;QAC1B,OAAOK,SAAS;MACpB,CAAC,MACI,IAAIh8B,OAAO,KAAKlF,OAAO,CAAC8gC,MAAM,EAAE;QACjC,OAAOK,WAAW;MACtB;IACJ,CAAC;IACDkB,UAAU,EAAE,SAAAA,CAAUC,UAAU,EAAE;MAC9BrB,WAAW,GAAGjhC,OAAO;MACrBA,OAAO,GAAGsiC,UAAU;MACpBpB,SAAS,GAAG,CAAC,CAAC;MACdC,WAAW,GAAG,CAAC,CAAC;IACpB,CAAC;IACDja,eAAe,EAAE,SAAAA,CAAA,EAAY;MACzB,OAAOga,SAAS;IACpB;EACJ,CAAC;AACL;AACA,IAAIY,eAAe,GAAGS,QAAQ,CAAC,CAAC,EAAE,GAAG,EAAEt0C,SAAS,CAAC0gB,OAAO,CAAC;AACzD,IAAIozB,gBAAgB,GAAGQ,QAAQ,CAAC,GAAG,EAAE,IAAI,EAAEt0C,SAAS,CAACogB,MAAM,CAAC;AAC5D,SAASk0B,QAAQA,CAACpiB,GAAG,EAAEC,GAAG,EAAEoiB,MAAM,EAAE;EAChC,OAAO,UAAUzwC,CAAC,EAAE;IAChB;IACA,IAAIA,CAAC,GAAGouB,GAAG,EACP,OAAO,CAAC;IACZ,IAAIpuB,CAAC,GAAGquB,GAAG,EACP,OAAO,CAAC;IACZ,OAAOoiB,MAAM,CAACv0C,SAAS,CAACiV,QAAQ,CAACid,GAAG,EAAEC,GAAG,EAAEruB,CAAC,CAAC,CAAC;EAClD,CAAC;AACL;AACA,IAAI0wC,OAAO,GAAG,CAAC,SAAS,EAAE,UAAU,EAAE,YAAY,EAAE,aAAa,CAAC;AAClE,IAAIC,UAAU,GAAGD,OAAO,CAAC5xC,MAAM;AAC/B,SAASmxC,SAASA,CAACd,SAAS,EAAEC,WAAW,EAAEM,gBAAgB,EAAEC,kBAAkB,EAAEiB,gBAAgB,EAAE5wC,CAAC,EAAE;EAClG;AACJ;AACA;EACI,KAAK,IAAIR,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmxC,UAAU,EAAEnxC,CAAC,EAAE,EAAE;IACjC,IAAIqxC,WAAW,GAAG,QAAQ,GAAGH,OAAO,CAAClxC,CAAC,CAAC,GAAG,QAAQ;IAClD,IAAIsxC,YAAY,GAAGC,SAAS,CAACpB,kBAAkB,EAAEkB,WAAW,CAAC;IAC7D,IAAIG,UAAU,GAAGD,SAAS,CAACrB,gBAAgB,EAAEmB,WAAW,CAAC;IACzD,IAAIC,YAAY,KAAKhvC,SAAS,IAAIkvC,UAAU,KAAKlvC,SAAS,EACtD;IACJgvC,YAAY,KAAKA,YAAY,GAAG,CAAC,CAAC;IAClCE,UAAU,KAAKA,UAAU,GAAG,CAAC,CAAC;IAC9B;AACR;AACA;AACA;AACA;IACQ,IAAI,OAAOF,YAAY,KAAK,QAAQ,IAChC,OAAOE,UAAU,KAAK,QAAQ,EAAE;MAChC,IAAIpmC,MAAM,GAAGV,IAAI,CAACmkB,GAAG,CAACnyB,SAAS,CAAC+X,GAAG,CAAC68B,YAAY,EAAEE,UAAU,EAAEhxC,CAAC,CAAC,EAAE,CAAC,CAAC;MACpEmvC,SAAS,CAAC0B,WAAW,CAAC,GAAGzB,WAAW,CAACyB,WAAW,CAAC,GAAGjmC,MAAM;IAC9D;EACJ;EACA;AACJ;AACA;EACI,IAAI+kC,kBAAkB,CAACvjC,MAAM,IAAIsjC,gBAAgB,CAACtjC,MAAM,EAAE;IACtD,IAAIA,MAAM,GAAGlQ,SAAS,CAAC+X,GAAG,CAAC07B,kBAAkB,CAACvjC,MAAM,IAAI,CAAC,EAAEsjC,gBAAgB,CAACtjC,MAAM,IAAI,CAAC,EAAEpM,CAAC,CAAC;IAC3FmvC,SAAS,CAAC/iC,MAAM,GAAGgjC,WAAW,CAAChjC,MAAM,GAAGA,MAAM;EAClD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACwkC,gBAAgB,IACjBlB,gBAAgB,CAAC/wB,eAAe,IAChCgxB,kBAAkB,CAAChxB,eAAe,EAAE;IACpC;AACR;AACA;AACA;AACA;AACA;IACQwwB,SAAS,CAACxwB,eAAe,GAAGywB,WAAW,CAACzwB,eAAe,GAAGziB,SAAS,CAAC+0C,QAAQ,CAACtB,kBAAkB,CAAChxB,eAAe,EAAE+wB,gBAAgB,CAAC/wB,eAAe,CAAC,CAAC3e,CAAC,CAAC;EACzJ;AACJ;AACA,SAAS+wC,SAASA,CAACn8B,MAAM,EAAEs8B,UAAU,EAAE;EACnC,IAAIxxC,EAAE;EACN,OAAO,CAACA,EAAE,GAAGkV,MAAM,CAACs8B,UAAU,CAAC,MAAM,IAAI,IAAIxxC,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAGkV,MAAM,CAACjK,YAAY;AACzF;AAEA,SAASwmC,WAAWA,CAAA,EAAG;EACnB,IAAIxb,KAAK,GAAG,IAAI9tB,GAAG,EAAE;EACrB,IAAIgG,KAAK,GAAG;IAAEujC,aAAa,EAAE;EAAM,CAAC;EACpC,IAAIC,SAAS,GAAGx1C,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAEgO,KAAK,CAAC;EACzC,IAAI+hC,UAAU;EACd,IAAIld,eAAe;EACnB,IAAI8I,cAAc;EAClB,IAAIsJ,UAAU,GAAG+J,gBAAgB,EAAE;EACnC,IAAIyC,uBAAuB,GAAG,KAAK;EACnC,SAASC,oBAAoBA,CAAA,EAAG;IAC5B,OAAO1jC,KAAK,CAACkhC,MAAM,GAAGlhC,KAAK,CAACkhC,MAAM,CAACrc,eAAe,GAAGA,eAAe;EACxE;EACA,SAAS8e,eAAeA,CAAA,EAAG;IACvB,IAAI9xC,EAAE;IACN,OAAO,CAACA,EAAE,GAAGmO,KAAK,CAACkhC,MAAM,MAAM,IAAI,IAAIrvC,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC2yB,cAAc,EAAE,CAACnqB,MAAM;EAC9F;EACA,OAAO;IACH6a,GAAG,EAAE,SAAAA,CAAU5P,OAAO,EAAE;MACpBA,OAAO,CAACw0B,aAAa,CAAC7C,UAAU,CAAC;MACjCnP,KAAK,CAAC5S,GAAG,CAAC5P,OAAO,CAAC;MAClB;AACZ;AACA;MACY,IAAIqoB,cAAc,EACdroB,OAAO,CAACqoB,cAAc,GAAGA,cAAc;MAC3C,IAAI,CAAC3tB,KAAK,CAACihC,IAAI,EACXjhC,KAAK,CAACihC,IAAI,GAAG37B,OAAO;IAC5B,CAAC;IACD6uB,MAAM,EAAE,SAAAA,CAAU7uB,OAAO,EAAE;MACvBwiB,KAAK,CAAClK,MAAM,CAACtY,OAAO,CAAC;IACzB,CAAC;IACDs+B,OAAO,EAAE,SAAAA,CAAA,EAAY;MAAE,OAAO5jC,KAAK,CAACihC,IAAI;IAAE,CAAC;IAC3C4C,cAAc,EAAE,SAAAA,CAAA,EAAY;MACxB,IAAI,CAAC7jC,KAAK,CAACihC,IAAI,EACX;MACJc,UAAU,GAAG9K,UAAU,CAAC5qB,QAAQ,EAAE,GAC5B4qB,UAAU,CAAC3P,eAAe,EAAE,GAC5BtnB,KAAK,CAACihC,IAAI,CAAC3Z,eAAe,EAAE;MAClCzC,eAAe,GAAG7kB,KAAK,CAACihC,IAAI,CAACpc,eAAe;MAC5C,IAAIoJ,YAAY,GAAGxF,mBAAmB,CAACv5B,GAAG,CAAC8Q,KAAK,CAACihC,IAAI,CAAC;MACtD,IAAIhT,YAAY,IAAIA,YAAY,CAACpF,UAAU,EAAE;QACzC8E,cAAc,GAAGM,YAAY,CAACjF,cAAc;MAChD;IACJ,CAAC;IACD8a,aAAa,EAAE,SAAAA,CAAA,EAAY;MACvBnW,cAAc,GAAG9I,eAAe,GAAG5wB,SAAS;IAChD,CAAC;IACD8vC,mBAAmB,EAAE,SAAAA,CAAA,EAAY;MAC7B,IAAIlyC,EAAE;MACN2xC,SAAS,GAAGx1C,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAEgO,KAAK,CAAC;MACrC,IAAIihC,IAAI;MACR,IAAIC,MAAM;MACV,IAAI1nC,KAAK,GAAGzD,KAAK,CAAC2c,IAAI,CAACoV,KAAK,CAAC;MAC7B,KAAK,IAAIn2B,CAAC,GAAG6H,KAAK,CAACvI,MAAM,EAAEU,CAAC,EAAE,EAAEA,CAAC,IAAI,CAAC,EAAE;QACpC,IAAI2T,OAAO,GAAG9L,KAAK,CAAC7H,CAAC,CAAC;QACtB,IAAIsvC,IAAI,EACJC,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAGA,MAAM,GAAIA,MAAM,GAAG57B,OAAQ;QACtE27B,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,KAAK,CAAC,GAAGA,IAAI,GAAIA,IAAI,GAAG37B,OAAQ;QAC1D,IAAI27B,IAAI,IAAIC,MAAM,EACd;MACR;MACAlhC,KAAK,CAACihC,IAAI,GAAGA,IAAI;MACjBjhC,KAAK,CAACkhC,MAAM,GAAGA,MAAM;MACrBlhC,KAAK,CAACujC,aAAa,GAAG,CAAC,CAAC1xC,EAAE,GAAGmO,KAAK,CAACihC,IAAI,MAAM,IAAI,IAAIpvC,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC2hC,QAAQ,MAAMhF,QAAQ,CAACwV,OAAO;MAC/G/M,UAAU,CAACwL,UAAU,CAAC;QAClBxB,IAAI,EAAEA,IAAI;QACVC,MAAM,EAAEA,MAAM;QACda,UAAU,EAAEA,UAAU;QACtBZ,gBAAgB,EAAE,CAACD,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAACpsC,cAAc,MAAMmsC,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACnsC,cAAc;MACjK,CAAC,CAAC;MACF;MACA;MACA;MACAkL,KAAK,CAACihC,IAAI,KAAKuC,SAAS,CAACtC,MAAM,KAC1BsC,SAAS,CAACvC,IAAI,KAAKjhC,KAAK,CAACihC,IAAI,IAC1BuC,SAAS,CAACD,aAAa,KAAKvjC,KAAK,CAACujC,aAAa,CAAC,EAAE;QACtDE,uBAAuB,GAAG,IAAI;MAClC;IACJ,CAAC;IACDzsC,OAAO,EAAE,SAAAA,CAAU6V,KAAK,EAAEo3B,eAAe,EAAE;MACvC,IAAIpyC,EAAE;MACN,IAAIoyC,eAAe,KAAK,KAAK,CAAC,EAAE;QAAEA,eAAe,GAAG,KAAK;MAAE;MAC3D,IAAIp3B,KAAK,KAAK7M,KAAK,CAACihC,IAAI,EAAE;QACtB,IAAIgD,eAAe,EAAE;UACjB;AACpB;AACA;AACA;UACoBp3B,KAAK,CAACmsB,OAAO,CAACh5B,KAAK,CAACihC,IAAI,CAAC;QAC7B,CAAC,MACI;UACDp0B,KAAK,CAACilB,aAAa,CAAC,IAAI,CAAC;QAC7B;QACA,IAAIz9B,MAAM,GAAG,CAAC,CAAC;QACf,IAAIk9B,UAAU,GAAG,CAAC1/B,EAAE,GAAGmO,KAAK,CAACkhC,MAAM,MAAM,IAAI,IAAIrvC,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC61B,mBAAmB,EAAE;QAClG,IAAI6J,UAAU,EAAE;UACZ;AACpB;AACA;UACoBl9B,MAAM,CAACk9B,UAAU,GAAGA,UAAU;QAClC;QACA,IAAI1kB,KAAK,CAAC2mB,QAAQ,KAAKhF,QAAQ,CAACuM,QAAQ,EAAE;UACtC1mC,MAAM,CAACuxB,SAAS,GAAG8d,oBAAoB,EAAE;QAC7C,CAAC,MACI,IAAI72B,KAAK,CAAC2mB,QAAQ,KAAKhF,QAAQ,CAACwV,OAAO,EAAE;UAC1C3vC,MAAM,CAAC+8B,SAAS,GAAGuS,eAAe,EAAE;QACxC;QACA,IAAIF,uBAAuB,EAAE;UACzBA,uBAAuB,GAAG,KAAK;UAC/B,IAAIl8B,UAAU,GAAGsF,KAAK,CAACmE,oBAAoB,EAAE;UAC7CnE,KAAK,CAAC2mB,QAAQ,KAAKhF,QAAQ,CAACuM,QAAQ,GAC9B9D,UAAU,CAACqL,MAAM,CAAC/6B,UAAU,CAAC,GAC7B0vB,UAAU,CAACoL,QAAQ,CAAC96B,UAAU,CAAC;QACzC;QACAsF,KAAK,CAACsmB,iBAAiB,CAAC9+B,MAAM,CAAC;MACnC,CAAC,MACI;QACD,IAAI4vC,eAAe,EAAE;UACjBjkC,KAAK,CAACihC,IAAI,IAAIp0B,KAAK,CAACmsB,OAAO,CAACh5B,KAAK,CAACihC,IAAI,CAAC;QAC3C,CAAC,MACI;UACDp0B,KAAK,CAACilB,aAAa,CAAC,KAAK,CAAC;QAC9B;MACJ;IACJ;EACJ,CAAC;AACL;AAEA,SAASoS,WAAWA,CAACr3B,KAAK,EAAE;EACxB;EACA,IAAIs3B,SAAS,GAAG,KAAK;EACrB;EACA,IAAIC,WAAW,GAAG,CAAC,CAAC;EACpB;EACA,KAAK,IAAIzyC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4H,aAAa,CAACtI,MAAM,EAAEU,CAAC,EAAE,EAAE;IAC3C,IAAI8vB,IAAI,GAAGloB,aAAa,CAAC5H,CAAC,CAAC;IAC3B,IAAIjB,GAAG,GAAG,QAAQ,GAAG+wB,IAAI;IACzB;IACA;IACA,IAAI,CAAC5U,KAAK,CAAC0L,QAAQ,CAAC7nB,GAAG,CAAC,IAAImc,KAAK,CAACqpB,cAAc,CAACxlC,GAAG,CAAC,KAAK,CAAC,EACvD;IACJyzC,SAAS,GAAG,IAAI;IAChB;IACAC,WAAW,CAAC1zC,GAAG,CAAC,GAAGmc,KAAK,CAACqpB,cAAc,CAACxlC,GAAG,CAAC;IAC5Cmc,KAAK,CAACwsB,cAAc,CAAC3oC,GAAG,EAAE,CAAC,CAAC;EAChC;EACA;EACA,IAAI,CAACyzC,SAAS,EACV;EACJ;EACA;EACAt3B,KAAK,CAAC9X,UAAU,EAAE;EAClB;EACA,KAAK,IAAIrE,GAAG,IAAI0zC,WAAW,EAAE;IACzBv3B,KAAK,CAACwsB,cAAc,CAAC3oC,GAAG,EAAE0zC,WAAW,CAAC1zC,GAAG,CAAC,CAAC;EAC/C;EACA;EACA;EACAmc,KAAK,CAACurB,cAAc,EAAE;AAC1B;;AAEA;AACA;AACA;AACA,IAAIiM,mBAAmB,GAAG,aAAe,UAAUxT,MAAM,EAAE;EACvD7iC,KAAK,CAAC8iC,SAAS,CAACuT,mBAAmB,EAAExT,MAAM,CAAC;EAC5C,SAASwT,mBAAmBA,CAAA,EAAG;IAC3B,IAAIlvB,KAAK,GAAG0b,MAAM,KAAK,IAAI,IAAIA,MAAM,CAAChT,KAAK,CAAC,IAAI,EAAEkT,SAAS,CAAC,IAAI,IAAI;IACpE;AACR;AACA;IACQ5b,KAAK,CAACkP,QAAQ,GAAG,IAAIrqB,GAAG,EAAE;IAC1B;AACR;AACA;AACA;AACA;IACQmb,KAAK,CAACmvB,MAAM,GAAG,IAAI5rC,GAAG,EAAE;IACxB;AACR;AACA;AACA;IACQyc,KAAK,CAACovB,UAAU,GAAG,KAAK;IACxB;AACR;AACA;AACA;IACQpvB,KAAK,CAACqvB,eAAe,GAAG,KAAK;IAC7B;AACR;AACA;IACQrvB,KAAK,CAACsvB,eAAe,GAAG,KAAK;IAC7B;AACR;AACA;IACQtvB,KAAK,CAACuvB,WAAW,GAAG12C,KAAK,CAACgE,QAAQ,CAAChE,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAEohC,aAAa,EAAE,CAAC,EAAE;MAAEiB,UAAU,EAAE,SAAAA,CAAU8F,KAAK,EAAE;QAAE,OAAOhlB,KAAK,CAACwvB,cAAc,CAACxK,KAAK,CAAC;MAAE,CAAC;MAAErG,WAAW,EAAE,SAAAA,CAAA,EAAY;QACjK;QACA;QACA3e,KAAK,CAACuvB,WAAW,GAAG12C,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAEmjB,KAAK,CAACuvB,WAAW,CAAC;QACzDvvB,KAAK,CAACwvB,cAAc,CAAC,IAAI,CAAC;MAC9B,CAAC;MAAE1xC,QAAQ,EAAE,SAAAA,CAAU4Z,KAAK,EAAE;QAAE,OAAOsI,KAAK,CAACmP,QAAQ,CAACzX,KAAK,CAAC;MAAE,CAAC;MAAEsnB,MAAM,EAAE,SAAAA,CAAUtnB,KAAK,EAAE;QAAE,OAAOsI,KAAK,CAACyvB,WAAW,CAAC/3B,KAAK,CAAC;MAAE;IAAE,CAAC,CAAC;IACrI,OAAOsI,KAAK;EAChB;EACAkvB,mBAAmB,CAACjvC,SAAS,CAAC88B,iBAAiB,GAAG,YAAY;IAC1D,IAAI,CAACqS,UAAU,GAAG,IAAI;EAC1B,CAAC;EACDF,mBAAmB,CAACjvC,SAAS,CAACk/B,kBAAkB,GAAG,YAAY;IAC3D,IAAI,CAACvH,oBAAoB,EAAE;EAC/B,CAAC;EACDsX,mBAAmB,CAACjvC,SAAS,CAACyvC,qBAAqB,GAAG,YAAY;IAC9D,IAAI,CAACJ,eAAe,GAAG,IAAI;IAC3B,OAAO,IAAI;EACf,CAAC;EACDJ,mBAAmB,CAACjvC,SAAS,CAAC23B,oBAAoB,GAAG,YAAY;IAC7D,IAAI5X,KAAK,GAAG,IAAI;IAChB;AACR;AACA;IACQ,IAAI,CAACsvB,eAAe,GAAG,IAAI,CAACD,eAAe,GAAG,KAAK;IACnD,IAAItoC,IAAI,GAAG,IAAI,CAACvM,KAAK,CAACuM,IAAI;IAC1B;AACR;AACA;AACA;IACQ,IAAI,CAACmoB,QAAQ,CAACv1B,OAAO,CAAC,UAAU+d,KAAK,EAAE;MACnC,IAAI,CAACA,KAAK,CAAC9Z,SAAS,EAAE;QAClB8Z,KAAK,CAAC2mB,QAAQ,GAAGhF,QAAQ,CAACwV,OAAO;MACrC,CAAC,MACI,IAAIn3B,KAAK,CAAC2mB,QAAQ,KAAKhF,QAAQ,CAACuM,QAAQ,EAAE;QAC3CluB,KAAK,CAAC2mB,QAAQ,GACV3mB,KAAK,CAAC2mB,QAAQ,KAAKhF,QAAQ,CAACwV,OAAO,GAC7BxV,QAAQ,CAACuM,QAAQ,GACjBvM,QAAQ,CAACiF,OAAO;MAC9B;IACJ,CAAC,CAAC;IACF,IAAI,CAACqR,YAAY,EAAE;IACnB;AACR;AACA;IACQ,IAAI18B,OAAO,GAAG;MACV8qB,WAAW,EAAE,SAAAA,CAAUrmB,KAAK,EAAE;QAC1B,IAAIA,KAAK,CAACwY,WAAW,EAAE,KAAKpxB,SAAS,EAAE;UACnC,IAAI6zB,KAAK,GAAG3S,KAAK,CAAC4vB,QAAQ,CAACl4B,KAAK,CAAC;UACjCib,KAAK,CAAC9wB,OAAO,CAAC6V,KAAK,EAAE3Q,IAAI,KAAK,WAAW,CAAC;QAC9C,CAAC,MACI;UACD2Q,KAAK,CAACsmB,iBAAiB,EAAE;QAC7B;MACJ,CAAC;MACD7+B,MAAM,EAAE,IAAI,CAACxB,OAAO,CAAC3B;IACzB,CAAC;IACD;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACkzB,QAAQ,CAACv1B,OAAO,CAAC,UAAU+d,KAAK,EAAE;MAAE,OAAOsI,KAAK,CAACuvB,WAAW,CAACxvB,GAAG,CAACrI,KAAK,CAAC;IAAE,CAAC,CAAC;IAChF,IAAI,CAAC63B,WAAW,CAACpR,KAAK,CAAClrB,OAAO,CAAC;IAC/B;AACR;AACA;IACQ,IAAI,CAACk8B,MAAM,CAACx1C,OAAO,CAAC,UAAUg5B,KAAK,EAAE;MAAE,OAAOA,KAAK,CAACgc,aAAa,EAAE;IAAE,CAAC,CAAC;EAC3E,CAAC;EACDO,mBAAmB,CAACjvC,SAAS,CAAC0vC,YAAY,GAAG,YAAY;IACrD,IAAI,CAACR,MAAM,CAACx1C,OAAO,CAAC,UAAUg5B,KAAK,EAAE;MAAE,OAAOA,KAAK,CAACic,mBAAmB,EAAE;IAAE,CAAC,CAAC;EACjF,CAAC;EACDM,mBAAmB,CAACjvC,SAAS,CAACuvC,cAAc,GAAG,UAAUxK,KAAK,EAAE;IAC5D,IAAIA,KAAK,KAAK,KAAK,CAAC,EAAE;MAAEA,KAAK,GAAG,KAAK;IAAE;IACvC,IAAI,EAAEA,KAAK,IAAI,CAAC,IAAI,CAACqK,eAAe,CAAC,EACjC;IACJ;AACR;AACA;IACQ,IAAI,CAACA,eAAe,GAAG,IAAI;IAC3B;AACR;AACA;IACQ,IAAI,CAACngB,QAAQ,CAACv1B,OAAO,CAAC,UAAU+d,KAAK,EAAE;MACnCq3B,WAAW,CAACr3B,KAAK,CAAC;MAClB,IAAIA,KAAK,CAACoX,oBAAoB,EAAE,EAC5BpX,KAAK,CAACid,cAAc,EAAE;IAC9B,CAAC,CAAC;IACF;AACR;AACA;IACQ,IAAI,CAACzF,QAAQ,CAACv1B,OAAO,CAACi2B,mBAAmB,CAAC;IAC1C;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACuf,MAAM,CAACx1C,OAAO,CAAC,UAAUg5B,KAAK,EAAE;MAAE,OAAOA,KAAK,CAAC+b,cAAc,EAAE;IAAE,CAAC,CAAC;IACxE;AACR;AACA;IACQ,IAAI1J,KAAK,IAAI,CAAC,IAAI,CAACsK,eAAe,EAAE;MAChC,IAAI,CAACA,eAAe,GAAG,IAAI;MAC3B,IAAI,CAAC3Q,WAAW,EAAE;IACtB;EACJ,CAAC;EACDuQ,mBAAmB,CAACjvC,SAAS,CAACkvB,QAAQ,GAAG,UAAUzX,KAAK,EAAE;IACtD,IAAI,CAACwX,QAAQ,CAACnP,GAAG,CAACrI,KAAK,CAAC;IACxB,IAAI,CAACm4B,UAAU,CAACn4B,KAAK,CAAC;IACtBA,KAAK,CAAC2mB,QAAQ,GAAG,IAAI,CAAC+Q,UAAU,GAAG/V,QAAQ,CAACuM,QAAQ,GAAGvM,QAAQ,CAACiF,OAAO;EAC3E,CAAC;EACD4Q,mBAAmB,CAACjvC,SAAS,CAACwvC,WAAW,GAAG,UAAU/3B,KAAK,EAAE;IACzD,IAAI,CAAC83B,cAAc,EAAE;IACrB,IAAI,CAACtgB,QAAQ,CAACzG,MAAM,CAAC/Q,KAAK,CAAC;IAC3B,IAAI,CAACo4B,eAAe,CAACp4B,KAAK,CAAC;EAC/B,CAAC;EACDw3B,mBAAmB,CAACjvC,SAAS,CAAC4vC,UAAU,GAAG,UAAUn4B,KAAK,EAAE;IACxD,IAAIib,KAAK,GAAG,IAAI,CAACid,QAAQ,CAACl4B,KAAK,CAAC;IAChCib,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,KAAK,CAAC5S,GAAG,CAACrI,KAAK,CAAC;EAClE,CAAC;EACDw3B,mBAAmB,CAACjvC,SAAS,CAAC6vC,eAAe,GAAG,UAAUp4B,KAAK,EAAE;IAC7D,IAAIib,KAAK,GAAG,IAAI,CAACid,QAAQ,CAACl4B,KAAK,CAAC;IAChCib,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,KAAK,CAACqM,MAAM,CAACtnB,KAAK,CAAC;EACrE,CAAC;EACD;AACJ;AACA;AACA;EACIw3B,mBAAmB,CAACjvC,SAAS,CAAC2vC,QAAQ,GAAG,UAAUl4B,KAAK,EAAE;IACtD,IAAI3Z,EAAE,GAAG2Z,KAAK,CAACwY,WAAW,EAAE;IAC5B,IAAInyB,EAAE,KAAKe,SAAS,EAChB;IACJ;IACA,CAAC,IAAI,CAACqwC,MAAM,CAACzrC,GAAG,CAAC3F,EAAE,CAAC,IAAI,IAAI,CAACoxC,MAAM,CAACxrC,GAAG,CAAC5F,EAAE,EAAEowC,WAAW,EAAE,CAAC;IAC1D,OAAO,IAAI,CAACgB,MAAM,CAACp1C,GAAG,CAACgE,EAAE,CAAC;EAC9B,CAAC;EACDmxC,mBAAmB,CAACjvC,SAAS,CAAC+gB,MAAM,GAAG,YAAY;IAC/C,OAAQ9mB,gBAAgB,CAAC0C,aAAa,CAAC4hC,mBAAmB,CAACv7B,QAAQ,EAAE;MAAErK,KAAK,EAAE,IAAI,CAAC22C;IAAY,CAAC,EAAE,IAAI,CAAC/0C,KAAK,CAAC00B,QAAQ,CAAC;EAC1H,CAAC;EACDggB,mBAAmB,CAACa,WAAW,GAAG7yC,aAAa;EAC/C,OAAOgyC,mBAAmB;AAC9B,CAAC,CAACh1C,gBAAgB,CAACsB,SAAS,CAAE;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASw0C,YAAYA,CAACtzC,EAAE,EAAE;EACtB,IAAIwyB,QAAQ,GAAGxyB,EAAE,CAACwyB,QAAQ;IAAEhwB,MAAM,GAAGrG,KAAK,CAACsW,MAAM,CAACzS,EAAE,EAAE,CAAC,UAAU,CAAC,CAAC;EACnE;AACJ;AACA;EACIwC,MAAM,GAAGrG,KAAK,CAACgE,QAAQ,CAAChE,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAE9D,KAAK,CAACoD,UAAU,CAACW,mBAAmB,CAAC,CAAC,EAAEoC,MAAM,CAAC;EAC1F;AACJ;AACA;AACA;EACIA,MAAM,CAACjC,QAAQ,GAAGI,WAAW,CAAC,YAAY;IAAE,OAAO6B,MAAM,CAACjC,QAAQ;EAAE,CAAC,CAAC;EACtE;AACJ;AACA;AACA;EACI,IAAIgzC,oBAAoB,GAAG,OAAO/wC,MAAM,CAACkT,UAAU,KAAK,QAAQ,GAC1DlT,MAAM,CAACkT,UAAU,CAAC89B,QAAQ,EAAE,GAC5B,EAAE;EACR,IAAIvyC,OAAO,GAAG5E,KAAK,CAACyJ,OAAO,CAAC,YAAY;IAAE,OAAOtD,MAAM;EAAE,CAAC,EAAE,CACxD+wC,oBAAoB,EACpB/wC,MAAM,CAACnC,kBAAkB,CAC5B,CAAC;EACF,OAAQ7C,gBAAgB,CAAC0C,aAAa,CAACE,mBAAmB,CAACmG,QAAQ,EAAE;IAAErK,KAAK,EAAE+E;EAAQ,CAAC,EAAEuxB,QAAQ,CAAC;AACtG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASihB,UAAUA,CAACzzC,EAAE,EAAE;EACpB,IAAIwyB,QAAQ,GAAGxyB,EAAE,CAACwyB,QAAQ;IAAE5zB,QAAQ,GAAGoB,EAAE,CAACpB,QAAQ;IAAEoK,EAAE,GAAGhJ,EAAE,CAACf,MAAM;IAAEA,MAAM,GAAG+J,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,GAAGA,EAAE;EACvG,IAAIK,EAAE,GAAGlN,KAAK,CAACwhB,MAAM,CAACthB,KAAK,CAACuwC,QAAQ,CAAC,CAAC8G,YAAY,CAAC90C,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC;IAAE+0C,WAAW,GAAGtqC,EAAE,CAAC,CAAC,CAAC;EACtF,IAAIuqC,cAAc,GAAGv3C,KAAK,CAACyE,MAAM,CAACsB,SAAS,CAAC;EAC5C;AACJ;AACA;EACI,IAAI,CAACsxC,YAAY,CAAC90C,QAAQ,CAAC,EAAE;IACzB,IAAIgE,QAAQ,GAAGhE,QAAQ,CAACgE,QAAQ;MAAEixC,cAAc,GAAG13C,KAAK,CAACsW,MAAM,CAAC7T,QAAQ,EAAE,CAAC,UAAU,CAAC,CAAC;IACvFg1C,cAAc,CAAC7yC,OAAO,GAAG6B,QAAQ;IACjCjE,YAAY,CAACk1C,cAAc,CAAC;EAChC;EACAx3C,KAAK,CAACkF,SAAS,CAAC,YAAY;IACxB,IAAImyC,YAAY,CAAC90C,QAAQ,CAAC,EAAE;MACxBA,QAAQ,EAAE,CAAC6mB,IAAI,CAAC,UAAUzlB,EAAE,EAAE;QAC1B,IAAI4C,QAAQ,GAAG5C,EAAE,CAAC4C,QAAQ;UAAEixC,cAAc,GAAG13C,KAAK,CAACsW,MAAM,CAACzS,EAAE,EAAE,CAAC,UAAU,CAAC,CAAC;QAC3ErB,YAAY,CAACk1C,cAAc,CAAC;QAC5BD,cAAc,CAAC7yC,OAAO,GAAG6B,QAAQ;QACjC+wC,WAAW,CAAC,IAAI,CAAC;MACrB,CAAC,CAAC;IACN;EACJ,CAAC,EAAE,EAAE,CAAC;EACN,OAAQn2C,gBAAgB,CAAC0C,aAAa,CAACnB,WAAW,CAACwH,QAAQ,EAAE;IAAErK,KAAK,EAAE;MAAE0G,QAAQ,EAAEgxC,cAAc,CAAC7yC,OAAO;MAAE9B,MAAM,EAAEA;IAAO;EAAE,CAAC,EAAEuzB,QAAQ,CAAC;AAC3I;AACA,SAASkhB,YAAYA,CAAC90C,QAAQ,EAAE;EAC5B,OAAO,OAAOA,QAAQ,KAAK,UAAU;AACzC;;AAEA;AACA;AACA;AACA,IAAIk1C,YAAY,GAAG33C,KAAK,CAACgE,QAAQ,CAAChE,KAAK,CAACgE,QAAQ,CAAC;EAAEyC,QAAQ,EAAEypC;AAAuB,CAAC,EAAEpkB,UAAU,CAAC,EAAE7L,iBAAiB,CAAC;;AAEtH;AACA;AACA;AACA,IAAI23B,MAAM,GAAG53C,KAAK,CAACgE,QAAQ,CAAChE,KAAK,CAACgE,QAAQ,CAAChE,KAAK,CAACgE,QAAQ,CAAC,CAAC,CAAC,EAAE2zC,YAAY,CAAC,EAAEz1C,IAAI,CAAC,EAAEskC,gBAAgB,CAAC;;AAErG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASqR,cAAcA,CAACjxC,OAAO,EAAE;EAC7B,IAAI7G,KAAK,GAAGyE,WAAW,CAAC,YAAY;IAAE,OAAOklB,WAAW,CAAC9iB,OAAO,CAAC;EAAE,CAAC,CAAC;EACrE;AACJ;AACA;AACA;AACA;EACI,IAAIxC,QAAQ,GAAGlE,KAAK,CAACoD,UAAU,CAACW,mBAAmB,CAAC,CAACG,QAAQ;EAC7D,IAAIA,QAAQ,EAAE;IACV,IAAIP,EAAE,GAAG7D,KAAK,CAACwhB,MAAM,CAACthB,KAAK,CAACuwC,QAAQ,CAAC7pC,OAAO,CAAC,EAAE,CAAC,CAAC;MAAEkxC,WAAW,GAAGj0C,EAAE,CAAC,CAAC,CAAC;IACtE3D,KAAK,CAACkF,SAAS,CAAC,YAAY;MAAE,OAAOrF,KAAK,CAAC4oB,QAAQ,CAACmvB,WAAW,CAAC;IAAE,CAAC,EAAE,EAAE,CAAC;EAC5E;EACA,OAAO/3C,KAAK;AAChB;AAEA,SAASg4C,WAAWA,CAACh4C,KAAK,EAAEue,QAAQ,EAAE;EAClCpe,KAAK,CAACkF,SAAS,CAAC,YAAY;IACxB,IAAIkH,aAAa,CAACvM,KAAK,CAAC,EACpB,OAAOA,KAAK,CAAC4oB,QAAQ,CAACrK,QAAQ,CAAC;EACvC,CAAC,EAAE,CAACA,QAAQ,CAAC,CAAC;AAClB;AACA,SAAS05B,gBAAgBA,CAACj/B,MAAM,EAAEqB,OAAO,EAAE;EACvCla,KAAK,CAACkF,SAAS,CAAC,YAAY;IACxB,IAAI6hB,aAAa,GAAGlO,MAAM,CAACkM,GAAG,CAAC,UAAUllB,KAAK,EAAE;MAAE,OAAOA,KAAK,CAAC4oB,QAAQ,CAACvO,OAAO,CAAC;IAAE,CAAC,CAAC;IACpF,OAAO,YAAY;MAAE,OAAO6M,aAAa,CAACnmB,OAAO,CAAC,UAAUm3C,WAAW,EAAE;QAAE,OAAOA,WAAW,EAAE;MAAE,CAAC,CAAC;IAAE,CAAC;EAC1G,CAAC,CAAC;AACN;AAEA,SAASC,sBAAsBA,CAACn/B,MAAM,EAAEo/B,aAAa,EAAE;EACnD;AACJ;AACA;EACI,IAAIp4C,KAAK,GAAG83C,cAAc,CAACM,aAAa,EAAE,CAAC;EAC3C;AACJ;AACA;AACA;AACA;AACA;EACI,IAAIC,WAAW,GAAG,SAAAA,CAAA,EAAY;IAAE,OAAOr4C,KAAK,CAAC+K,GAAG,CAACqtC,aAAa,EAAE,CAAC;EAAE,CAAC;EACpE;AACJ;AACA;AACA;EACIC,WAAW,EAAE;EACb;AACJ;AACA;AACA;EACIJ,gBAAgB,CAACj/B,MAAM,EAAE,YAAY;IAAE,OAAOxX,aAAa,CAAC,SAAS,CAAC,CAAC6vB,MAAM,CAACgnB,WAAW,EAAE,KAAK,EAAE,IAAI,CAAC;EAAE,CAAC,CAAC;EAC3G,OAAOr4C,KAAK;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASs4C,iBAAiBA,CAACC,SAAS,EAAE;EAClC,IAAIv/B,MAAM,GAAG,EAAE;EACf,KAAK,IAAI+uB,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAG/E,SAAS,CAAC9/B,MAAM,EAAE6kC,EAAE,EAAE,EAAE;IAC1C/uB,MAAM,CAAC+uB,EAAE,GAAG,CAAC,CAAC,GAAG/E,SAAS,CAAC+E,EAAE,CAAC;EAClC;EACA;AACJ;AACA;EACI,IAAIyQ,YAAY,GAAGD,SAAS,CAACr1C,MAAM;EACnC,SAASu1C,UAAUA,CAAA,EAAG;IAClB,IAAIlW,MAAM,GAAG,EAAE;IACf,KAAK,IAAI3+B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG40C,YAAY,EAAE50C,CAAC,EAAE,EAAE;MACnC2+B,MAAM,IAAIgW,SAAS,CAAC30C,CAAC,CAAC;MACtB,IAAI5D,KAAK,GAAGgZ,MAAM,CAACpV,CAAC,CAAC;MACrB,IAAI5D,KAAK,EACLuiC,MAAM,IAAIvpB,MAAM,CAACpV,CAAC,CAAC,CAACzC,GAAG,EAAE;IACjC;IACA,OAAOohC,MAAM;EACjB;EACA,OAAO4V,sBAAsB,CAACn/B,MAAM,EAAEy/B,UAAU,CAAC;AACrD;AAEA,IAAIC,iBAAiB,GAAG,SAAAA,CAAU3wC,CAAC,EAAE;EACjC,OAAO,OAAOA,CAAC,KAAK,QAAQ,IAAIA,CAAC,CAACsQ,GAAG;AACzC,CAAC;AACD,IAAIsgC,QAAQ,GAAG,SAAAA,CAAU5wC,CAAC,EAAE;EAAE,OAAQ2wC,iBAAiB,CAAC3wC,CAAC,CAAC,GAAGA,CAAC,CAACsQ,GAAG,GAAGnS,SAAS;AAAG,CAAC;AAClF,SAAS+G,SAASA,CAAA,EAAG;EACjB,IAAI66B,IAAI,GAAG,EAAE;EACb,KAAK,IAAIC,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAG/E,SAAS,CAAC9/B,MAAM,EAAE6kC,EAAE,EAAE,EAAE;IAC1CD,IAAI,CAACC,EAAE,CAAC,GAAG/E,SAAS,CAAC+E,EAAE,CAAC;EAC5B;EACA,IAAI6Q,YAAY,GAAG,CAAC5wC,KAAK,CAACC,OAAO,CAAC6/B,IAAI,CAAC,CAAC,CAAC,CAAC;EAC1C,IAAI+Q,SAAS,GAAGD,YAAY,GAAG,CAAC,GAAG,CAAC,CAAC;EACrC,IAAIE,UAAU,GAAGhR,IAAI,CAAC,CAAC,GAAG+Q,SAAS,CAAC;EACpC,IAAIE,UAAU,GAAGjR,IAAI,CAAC,CAAC,GAAG+Q,SAAS,CAAC;EACpC,IAAIG,WAAW,GAAGlR,IAAI,CAAC,CAAC,GAAG+Q,SAAS,CAAC;EACrC,IAAIxmC,OAAO,GAAGy1B,IAAI,CAAC,CAAC,GAAG+Q,SAAS,CAAC;EACjC,IAAII,YAAY,GAAG34C,SAAS,CAAC44C,WAAW,CAACH,UAAU,EAAEC,WAAW,EAAE/4C,KAAK,CAACgE,QAAQ,CAAC;IAAEk1C,KAAK,EAAER,QAAQ,CAACK,WAAW,CAAC,CAAC,CAAC;EAAE,CAAC,EAAE3mC,OAAO,CAAC,CAAC;EAC/H,OAAOumC,YAAY,GAAGK,YAAY,CAACH,UAAU,CAAC,GAAGG,YAAY;AACjE;AAEA,SAASG,YAAYA,CAACC,KAAK,EAAEC,uBAAuB,EAAEN,WAAW,EAAE3mC,OAAO,EAAE;EACxE,IAAIknC,WAAW,GAAG,OAAOD,uBAAuB,KAAK,UAAU,GACzDA,uBAAuB,GACvBrsC,SAAS,CAACqsC,uBAAuB,EAAEN,WAAW,EAAE3mC,OAAO,CAAC;EAC9D,OAAOrK,KAAK,CAACC,OAAO,CAACoxC,KAAK,CAAC,GACrBG,gBAAgB,CAACH,KAAK,EAAEE,WAAW,CAAC,GACpCC,gBAAgB,CAAC,CAACH,KAAK,CAAC,EAAE,UAAUv1C,EAAE,EAAE;IACtC,IAAIgJ,EAAE,GAAG7M,KAAK,CAACwhB,MAAM,CAAC3d,EAAE,EAAE,CAAC,CAAC;MAAEwS,MAAM,GAAGxJ,EAAE,CAAC,CAAC,CAAC;IAC5C,OAAOysC,WAAW,CAACjjC,MAAM,CAAC;EAC9B,CAAC,CAAC;AACV;AACA,SAASkjC,gBAAgBA,CAACxgC,MAAM,EAAEugC,WAAW,EAAE;EAC3C,IAAIjjC,MAAM,GAAG7R,WAAW,CAAC,YAAY;IAAE,OAAO,EAAE;EAAE,CAAC,CAAC;EACpD,OAAO0zC,sBAAsB,CAACn/B,MAAM,EAAE,YAAY;IAC9C1C,MAAM,CAACpT,MAAM,GAAG,CAAC;IACjB,IAAIu2C,SAAS,GAAGzgC,MAAM,CAAC9V,MAAM;IAC7B,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG61C,SAAS,EAAE71C,CAAC,EAAE,EAAE;MAChC0S,MAAM,CAAC1S,CAAC,CAAC,GAAGoV,MAAM,CAACpV,CAAC,CAAC,CAACzC,GAAG,EAAE;IAC/B;IACA,OAAOo4C,WAAW,CAACjjC,MAAM,CAAC;EAC9B,CAAC,CAAC;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASojC,SAASA,CAAChmC,MAAM,EAAEpN,MAAM,EAAE;EAC/B,IAAIA,MAAM,KAAK,KAAK,CAAC,EAAE;IAAEA,MAAM,GAAG,CAAC,CAAC;EAAE;EACtC,IAAIjC,QAAQ,GAAGlE,KAAK,CAACoD,UAAU,CAACW,mBAAmB,CAAC,CAACG,QAAQ;EAC7D,IAAIs1C,qBAAqB,GAAGx5C,KAAK,CAACyE,MAAM,CAAC,IAAI,CAAC;EAC9C,IAAI5E,KAAK,GAAG83C,cAAc,CAACvrC,aAAa,CAACmH,MAAM,CAAC,GAAGA,MAAM,CAACvS,GAAG,EAAE,GAAGuS,MAAM,CAAC;EACzEvT,KAAK,CAACyJ,OAAO,CAAC,YAAY;IACtB,OAAO5J,KAAK,CAACgpB,MAAM,CAAC,UAAUjhB,CAAC,EAAEgD,GAAG,EAAE;MAClC;AACZ;AACA;AACA;MACY,IAAI1G,QAAQ,EACR,OAAO0G,GAAG,CAAChD,CAAC,CAAC;MACjB,IAAI4xC,qBAAqB,CAAC90C,OAAO,EAAE;QAC/B80C,qBAAqB,CAAC90C,OAAO,CAACqhB,IAAI,EAAE;MACxC;MACAyzB,qBAAqB,CAAC90C,OAAO,GAAGvE,SAAS,CAAC2I,OAAO,CAAChJ,KAAK,CAACgE,QAAQ,CAAChE,KAAK,CAACgE,QAAQ,CAAC;QAAE0gB,IAAI,EAAE3kB,KAAK,CAACmB,GAAG,EAAE;QAAEshB,EAAE,EAAE1a,CAAC;QAAEO,QAAQ,EAAEtI,KAAK,CAACuI,WAAW;MAAG,CAAC,EAAEjC,MAAM,CAAC,EAAE;QAAE0f,QAAQ,EAAEjb;MAAI,CAAC,CAAC,CAAC;MACzK,OAAO/K,KAAK,CAACmB,GAAG,EAAE;IACtB,CAAC,CAAC;EACN,CAAC,EAAEtB,MAAM,CAACmZ,MAAM,CAAC1S,MAAM,CAAC,CAAC;EACzB0xC,WAAW,CAACtkC,MAAM,EAAE,UAAU3L,CAAC,EAAE;IAAE,OAAO/H,KAAK,CAAC+K,GAAG,CAACob,UAAU,CAACpe,CAAC,CAAC,CAAC;EAAE,CAAC,CAAC;EACtE,OAAO/H,KAAK;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS45C,WAAWA,CAAC55C,KAAK,EAAE;EACxB,IAAIsI,QAAQ,GAAGwvC,cAAc,CAAC93C,KAAK,CAACuI,WAAW,EAAE,CAAC;EAClDpI,KAAK,CAACkF,SAAS,CAAC,YAAY;IACxB,OAAOrF,KAAK,CAACgoB,yBAAyB,CAACb,GAAG,CAAC,UAAU0yB,WAAW,EAAE;MAC9DvxC,QAAQ,CAACyC,GAAG,CAAC8uC,WAAW,CAAC;IAC7B,CAAC,CAAC;EACN,CAAC,EAAE,CAAC75C,KAAK,CAAC,CAAC;EACX,OAAOsI,QAAQ;AACnB;AAEA,SAASwxC,wBAAwBA,CAAA,EAAG;EAChC,OAAO;IACHC,OAAO,EAAEpwB,WAAW,CAAC,CAAC,CAAC;IACvBqwB,OAAO,EAAErwB,WAAW,CAAC,CAAC,CAAC;IACvBswB,eAAe,EAAEtwB,WAAW,CAAC,CAAC,CAAC;IAC/BuwB,eAAe,EAAEvwB,WAAW,CAAC,CAAC;EAClC,CAAC;AACL;AACA,SAASwwB,WAAWA,CAACllC,MAAM,EAAEmlC,SAAS,EAAEp6C,KAAK,EAAE;EAC3CA,KAAK,CAAC+K,GAAG,CAAC,CAACkK,MAAM,IAAI,CAACmlC,SAAS,GAAG,CAAC,GAAGnlC,MAAM,GAAGmlC,SAAS,CAAC;AAC7D;AACA,SAASC,mBAAmBA,CAACrhC,MAAM,EAAEshC,UAAU,EAAE;EAC7C,IAAIjpB,MAAM,GAAG,SAAAA,CAAA,EAAY;IACrB,IAAIvtB,EAAE,GAAGw2C,UAAU,EAAE;MAAEC,OAAO,GAAGz2C,EAAE,CAACy2C,OAAO;MAAEC,OAAO,GAAG12C,EAAE,CAAC02C,OAAO;MAAEC,UAAU,GAAG32C,EAAE,CAAC22C,UAAU;MAAEC,UAAU,GAAG52C,EAAE,CAAC42C,UAAU;IACzH;IACA1hC,MAAM,CAAC+gC,OAAO,CAAChvC,GAAG,CAACwvC,OAAO,CAAC;IAC3BvhC,MAAM,CAACghC,OAAO,CAACjvC,GAAG,CAACyvC,OAAO,CAAC;IAC3B;IACAL,WAAW,CAACI,OAAO,EAAEE,UAAU,EAAEzhC,MAAM,CAACihC,eAAe,CAAC;IACxDE,WAAW,CAACK,OAAO,EAAEE,UAAU,EAAE1hC,MAAM,CAACkhC,eAAe,CAAC;EAC5D,CAAC;EACD7oB,MAAM,EAAE;EACR,OAAOA,MAAM;AACjB;AAEA,IAAIspB,uBAAuB,GAAG,SAAAA,CAAUpjC,OAAO,EAAE;EAAE,OAAO,YAAY;IAClE,OAAO;MACHgjC,OAAO,EAAEhjC,OAAO,CAACqjC,UAAU;MAC3BJ,OAAO,EAAEjjC,OAAO,CAACsjC,SAAS;MAC1BJ,UAAU,EAAEljC,OAAO,CAACujC,WAAW,GAAGvjC,OAAO,CAACwjC,WAAW;MACrDL,UAAU,EAAEnjC,OAAO,CAACyjC,YAAY,GAAGzjC,OAAO,CAAC0jC;IAC/C,CAAC;EACL,CAAC;AAAE,CAAC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,gBAAgBA,CAACv2C,GAAG,EAAE;EAC3B,IAAIqU,MAAM,GAAGvU,WAAW,CAACq1C,wBAAwB,CAAC;EAClDj0C,yBAAyB,CAAC,YAAY;IAClC,IAAI0R,OAAO,GAAG5S,GAAG,CAACE,OAAO;IACzBzE,SAAS,CAACuD,SAAS,CAAC,CAAC,CAAC4T,OAAO,EAAE,+DAA+D,CAAC;IAC/F,IAAI,CAACA,OAAO,EACR;IACJ,IAAI4jC,kBAAkB,GAAGd,mBAAmB,CAACrhC,MAAM,EAAE2hC,uBAAuB,CAACpjC,OAAO,CAAC,CAAC;IACtF,IAAI6jC,cAAc,GAAGjhC,WAAW,CAAC5C,OAAO,EAAE,QAAQ,EAAE4jC,kBAAkB,EAAE;MAAEE,OAAO,EAAE;IAAK,CAAC,CAAC;IAC1F,IAAIC,cAAc,GAAGnhC,WAAW,CAAC5C,OAAO,EAAE,QAAQ,EAAE4jC,kBAAkB,CAAC;IACvE,OAAO,YAAY;MACfC,cAAc,IAAIA,cAAc,EAAE;MAClCE,cAAc,IAAIA,cAAc,EAAE;IACtC,CAAC;EACL,CAAC,EAAE,EAAE,CAAC;EACN,OAAOtiC,MAAM;AACjB;AAEA,IAAIuiC,oBAAoB;AACxB,SAASC,wBAAwBA,CAAA,EAAG;EAChC,OAAO;IACHjB,OAAO,EAAE30C,MAAM,CAAC61C,WAAW;IAC3BjB,OAAO,EAAE50C,MAAM,CAAC81C,WAAW;IAC3BjB,UAAU,EAAEkB,QAAQ,CAACC,IAAI,CAACC,WAAW,GAAGj2C,MAAM,CAACk2C,UAAU;IACzDpB,UAAU,EAAEiB,QAAQ,CAACC,IAAI,CAACG,YAAY,GAAGn2C,MAAM,CAACo2C;EACpD,CAAC;AACL;AACA,IAAIC,YAAY,GAAG,KAAK;AACxB,SAASC,iBAAiBA,CAAA,EAAG;EACzBD,YAAY,GAAG,IAAI;EACnB,IAAI,OAAOr2C,MAAM,KAAK,WAAW,EAC7B;EACJ,IAAIu1C,kBAAkB,GAAGd,mBAAmB,CAACkB,oBAAoB,EAAEC,wBAAwB,CAAC;EAC5FrhC,WAAW,CAACvU,MAAM,EAAE,QAAQ,EAAEu1C,kBAAkB,EAAE;IAAEE,OAAO,EAAE;EAAK,CAAC,CAAC;EACpElhC,WAAW,CAACvU,MAAM,EAAE,QAAQ,EAAEu1C,kBAAkB,CAAC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASgB,iBAAiBA,CAAA,EAAG;EACzB;AACJ;AACA;EACI,IAAI,CAACZ,oBAAoB,EAAE;IACvBA,oBAAoB,GAAGzB,wBAAwB,EAAE;EACrD;EACAj0C,yBAAyB,CAAC,YAAY;IAClC,CAACo2C,YAAY,IAAIC,iBAAiB,EAAE;EACxC,CAAC,EAAE,EAAE,CAAC;EACN,OAAOX,oBAAoB;AAC/B;;AAEA;AACA,IAAIa,oBAAoB;AACxB,SAASC,wBAAwBA,CAAA,EAAG;EAChCD,oBAAoB,GAAGzyB,WAAW,CAAC,IAAI,CAAC;EACxC,IAAI,OAAO/jB,MAAM,KAAK,WAAW,EAC7B;EACJ,IAAIA,MAAM,CAAC02C,UAAU,EAAE;IACnB,IAAIC,kBAAkB,GAAG32C,MAAM,CAAC02C,UAAU,CAAC,0BAA0B,CAAC;IACtE,IAAIE,2BAA2B,GAAG,SAAAA,CAAA,EAAY;MAC1C,OAAOJ,oBAAoB,CAACrxC,GAAG,CAACwxC,kBAAkB,CAACE,OAAO,CAAC;IAC/D,CAAC;IACDF,kBAAkB,CAACG,WAAW,CAACF,2BAA2B,CAAC;IAC3DA,2BAA2B,EAAE;EACjC,CAAC,MACI;IACDJ,oBAAoB,CAACrxC,GAAG,CAAC,KAAK,CAAC;EACnC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS4xC,gBAAgBA,CAAA,EAAG;EACxB;AACJ;AACA;EACI,CAACP,oBAAoB,IAAIC,wBAAwB,EAAE;EACnD,IAAIv4C,EAAE,GAAG7D,KAAK,CAACwhB,MAAM,CAACthB,KAAK,CAACuwC,QAAQ,CAAC0L,oBAAoB,CAACj7C,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC;IAAEy7C,kBAAkB,GAAG94C,EAAE,CAAC,CAAC,CAAC;IAAE+4C,qBAAqB,GAAG/4C,EAAE,CAAC,CAAC,CAAC;EAC/Hk0C,WAAW,CAACoE,oBAAoB,EAAES,qBAAqB,CAAC;EACxD,OAAOD,kBAAkB;AAC7B;;AAEA;AACA;AACA;AACA,SAASE,iBAAiBA,CAAA,EAAG;EACzB;AACJ;AACA;EACI,IAAItG,UAAU,GAAG,KAAK;EACtB;AACJ;AACA;AACA;EACI,IAAIuG,iBAAiB,GAAG,EAAE;EAC1B;AACJ;AACA;EACI,IAAIC,WAAW,GAAG,IAAI/wC,GAAG,EAAE;EAC3B,IAAIsa,QAAQ,GAAG;IACX6J,SAAS,EAAE,SAAAA,CAAUhtB,aAAa,EAAE;MAChC45C,WAAW,CAAC71B,GAAG,CAAC/jB,aAAa,CAAC;MAC9B,OAAO,YAAY;QAAE,OAAO,KAAK45C,WAAW,CAACntB,MAAM,CAACzsB,aAAa,CAAC;MAAE,CAAC;IACzE,CAAC;IACD8F,KAAK,EAAE,SAAAA,CAAUT,UAAU,EAAE4jB,kBAAkB,EAAE;MAC7C;AACZ;AACA;AACA;AACA;AACA;MACY,IAAImqB,UAAU,EAAE;QACZ,IAAIyG,YAAY,GAAG,EAAE;QACrBD,WAAW,CAACj8C,OAAO,CAAC,UAAUqC,aAAa,EAAE;UACzC65C,YAAY,CAACl5C,IAAI,CAAC8nB,oBAAoB,CAACzoB,aAAa,EAAEqF,UAAU,EAAE;YAC9D4jB,kBAAkB,EAAEA;UACxB,CAAC,CAAC,CAAC;QACP,CAAC,CAAC;QACF,OAAOjD,OAAO,CAAC6C,GAAG,CAACgxB,YAAY,CAAC;MACpC,CAAC,MACI;QACD,OAAO,IAAI7zB,OAAO,CAAC,UAAUC,OAAO,EAAE;UAClC0zB,iBAAiB,CAACh5C,IAAI,CAAC;YACnB9B,SAAS,EAAE,CAACwG,UAAU,EAAE4jB,kBAAkB,CAAC;YAC3ChD,OAAO,EAAEA;UACb,CAAC,CAAC;QACN,CAAC,CAAC;MACN;IACJ,CAAC;IACDte,GAAG,EAAE,SAAAA,CAAUtC,UAAU,EAAE;MACvBrI,SAAS,CAACuD,SAAS,CAAC6yC,UAAU,EAAE,+GAA+G,CAAC;MAChJ,OAAOwG,WAAW,CAACj8C,OAAO,CAAC,UAAUqC,aAAa,EAAE;QAChDgoB,SAAS,CAAChoB,aAAa,EAAEqF,UAAU,CAAC;MACxC,CAAC,CAAC;IACN,CAAC;IACDyd,IAAI,EAAE,SAAAA,CAAA,EAAY;MACd82B,WAAW,CAACj8C,OAAO,CAAC,UAAUqC,aAAa,EAAE;QACzCkmB,aAAa,CAAClmB,aAAa,CAAC;MAChC,CAAC,CAAC;IACN,CAAC;IACDwE,KAAK,EAAE,SAAAA,CAAA,EAAY;MACf4uC,UAAU,GAAG,IAAI;MACjBuG,iBAAiB,CAACh8C,OAAO,CAAC,UAAU+C,EAAE,EAAE;QACpC,IAAI7B,SAAS,GAAG6B,EAAE,CAAC7B,SAAS;UAAEonB,OAAO,GAAGvlB,EAAE,CAACulB,OAAO;QAClD9C,QAAQ,CAACrd,KAAK,CAAC4mB,KAAK,CAACvJ,QAAQ,EAAEtmB,KAAK,CAACulB,aAAa,CAAC,EAAE,EAAEvlB,KAAK,CAACwhB,MAAM,CAACxf,SAAS,CAAC,CAAC,CAAC,CAACsnB,IAAI,CAACF,OAAO,CAAC;MAClG,CAAC,CAAC;MACF,OAAO,YAAY;QACfmtB,UAAU,GAAG,KAAK;QAClBjwB,QAAQ,CAACL,IAAI,EAAE;MACnB,CAAC;IACL;EACJ,CAAC;EACD,OAAOK,QAAQ;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS22B,YAAYA,CAAA,EAAG;EACpB,IAAI32B,QAAQ,GAAG9hB,WAAW,CAACq4C,iBAAiB,CAAC;EAC7C38C,KAAK,CAACkF,SAAS,CAACkhB,QAAQ,CAAC3e,KAAK,EAAE,EAAE,CAAC;EACnC,OAAO2e,QAAQ;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS42B,QAAQA,CAAA,EAAG;EAChB,IAAI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"},"metadata":{},"sourceType":"script","externalDependencies":[]}